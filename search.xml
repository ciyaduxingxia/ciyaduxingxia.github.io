<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springcloud之feign用法及原理</title>
      <link href="2021/05/27/springcloud-zhi-feign/"/>
      <url>2021/05/27/springcloud-zhi-feign/</url>
      
        <content type="html"><![CDATA[<h2 id="springcloud之feign用法及原理"><a href="#springcloud之feign用法及原理" class="headerlink" title="springcloud之feign用法及原理"></a>springcloud之feign用法及原理</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><blockquote><p>Feign是声明式的web service客户端，它最核心的作用是为 HTTP 形式的 Rest API 提供了非常简洁高效的 RPC 调用方式，它让微服务之间的调用变得更简单了，类似controller调用service。重点注意Feign的主要目标是将Java Http 客户端变得简单，服务提供端不用Feign。Feign是spring cloud中服务消费端的调用框架,通常与ribbon,hystrix等组合使用。 如果说 Spring Cloud 其他成员解决的是系统级别的可用性，扩展性问题， 那么 OpenFeign 解决的则是与开发人员利益最为紧密的开发效率问题。</p></blockquote><h3 id="2-Feign的使用"><a href="#2-Feign的使用" class="headerlink" title="2.Feign的使用"></a>2.Feign的使用</h3><h4 id="2-1-服务提供端"><a href="#2-1-服务提供端" class="headerlink" title="2.1 服务提供端"></a>2.1 服务提供端</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//提供restful服务</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeptController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">DeptService</span> deptService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/dept/query/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Dept</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Dept</span> dept <span class="token operator">=</span> deptService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dept <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"错误id=>"</span><span class="token operator">+</span>id<span class="token operator">+</span><span class="token string">",部门信息不存在或输入id有误!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dept<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里 Feign 不需要发挥任何作用。</p><h4 id="2-2-服务消费端导入Feign依赖"><a href="#2-2-服务消费端导入Feign依赖" class="headerlink" title="2.2 服务消费端导入Feign依赖"></a>2.2 服务消费端导入Feign依赖</h4><p>项目中使用了maven作为依赖管理</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--feign--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-feign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--Ribbon--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--eureka client--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-eureka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为feign底层是使用了ribbon作为负载均衡的客户端，而ribbon的负载均衡也是依赖于eureka 获得各个服务的地址，所以要引入eureka-client。实际上服务消费端就需要引入eureka-client。</p><h4 id="2-3-服务消费端"><a href="#2-3-服务消费端" class="headerlink" title="2.3 服务消费端"></a>2.3 服务消费端</h4><p>SpringBootApplication启动类加上@EnableFeignClients的注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.itxxj.springcloud"</span><span class="token punctuation">)</span> <span class="token comment">//可以指定要扫描的包，会扫描包下所有带有@FeignClient的注解</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeptConsumer_feign</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">DeptConsumer_feign</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在application.yml中配置如下，也可以不配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">feign:  client: #feign的配置，连接超时及读取超时配置    config:      default:        connectTimeout: 5000        readTimeout: 5000        loggerLevel: basic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在接口内编写与要调用的服务相同的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SPRINGCLOUD-PROVIDER-DEPT"</span><span class="token punctuation">)</span> <span class="token comment">//这里的value是服务提供方的名字</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DeptClientService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//这里的地址要和实现类，即服务provider那边的一样</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/dept/query/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token class-name">Dept</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再直接利用 spring 的自动注入功能， 就可以使用服务端的接口了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeptConsumerController</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//如何调用provider，SpringCloud使用rest的http而不是用RPC</span>    <span class="token comment">//RestTemplate 通过url调用</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">;</span><span class="token comment">//提供多种便捷访问远程http服务的方法，简单的restful服务模板</span>    <span class="token comment">//通过Feign，它是以接口的形式来调用远程方法</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">DeptClientService</span> service<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/consumer/dept/get/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Dept</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Feign原理分析"><a href="#3-Feign原理分析" class="headerlink" title="3.Feign原理分析"></a>3.Feign原理分析</h3><p>在展开讲解工作原理前， 首先捋一下上文中， 我们完成 Feign 调用前所进行的操作：</p><ol><li>添加了 Spring Cloud OpenFeign 的依赖</li><li>在 SpringBoot 启动类上添加了注解 <code>@EnableFeignClients</code></li><li>按照 Feign 的规则定义接口 <code>DeptClientService</code>， 添加<code>@FeignClient</code> 注解</li><li>在需要使用 Feign 接口 <code>DeptClientService</code>的地方， 直接利用<code>@Resource</code>进行注入</li><li>使用接口完成对服务端的调用</li></ol><p>可以根据上面使用 Feign 的步骤大致猜测出整体的工作流程：</p><ol><li>SpringBoot 应用启动时， 由针对 <code>@EnableFeignClient </code>这一注解的处理逻辑触发程序扫描 classPath或指定包下所有被@FeignClient 注解的类， 这里以 <code>DeptClientService</code>为例， 将这些类解析为 BeanDefinition 注册到 Spring 容器中</li><li>Sping 容器在为某些用的 Feign 接口的 Bean 注入<code> DeptClientService</code>时， Spring 会尝试从容器中查找 <code>DeptClientService</code>的实现类</li><li>由于我们从来没有编写过 <code>DeptClientService</code>的实现类， 上面步骤获取到的 DeptClientService的实现类必然是 feign 框架通过扩展 spring 的 Bean 处理逻辑， 为 <code>DeptClientService</code>创建一个==动态接口代理对象==， 这里我们将其称为 <code>DeptClientServiceProxy </code>注册到spring 容器中。</li><li>Spring 最终在使用到 <code>DeptClientService</code>的 Bean 中注入了 <code>DeptClientServiceProxy</code> 这一实例。</li><li>当业务请求真实发生时， 对于 <code>DeptClientService</code>的调用被统一转发到了由 Feign 框架实现的 <code>InvocationHandler</code>中， <code>InvocationHandler</code> 负责将接口中的入参转换为 HTTP 的形式， 发到服务端， 最后再解析 HTTP 响应， 将结果转换为 Java 对象， 予以返回。</li></ol><p>上面整个流程可以进一步简化理解为：</p><ol><li>我们定义的接口 <code>DeptClientService</code>由于添加了注解 <code>@FeignClient</code>, 最终产生了一个==虚假的实现类代理==</li><li>使用这个接口的地方， 最终拿到的都是一个假的代理实现类 <code>DeptClientServiceProxy</code></li><li>所有发生在 <code>DeptClientServiceProxy</code> 上的调用， 都被转交给 Feign 框架， 翻译成 HTTP 的形式发送出去， 并得到返回结果， 再翻译回接口定义的返回值形式。</li></ol><p>所以说从这个流程可以看出Feign确实是对SpringCloud的Http形式的调用进行了封装。而Feign 的核心实现原理就是java 原生支持的基于接口的动态代理</p><h3 id="4-Feign源码分析"><a href="#4-Feign源码分析" class="headerlink" title="4.Feign源码分析"></a>4.Feign源码分析</h3><p>FeignClient 的扫描与注册是基于 Spring 框架的 Bean 管理机制实现的。这里简单叙述 SpringBoot 应用中的扫描触发流程：</p><blockquote><p>SpringApplication.run() –&gt;<br>SpringApplication.refresh() –&gt;<br>AbstractApplicationContext.refresh() –&gt;<br>AbstractApplicationContext.invokeBeanFactoryPostProcessors() –&gt;<br>AbstractApplicationContext.invokeBeanDefinitionRegistryPostProcessors() –&gt;<br><code>补充知识点： 上面的 invokeBeanFactoryPostProcessors() 能触发invokeBeanDefinitionRegistryPostProcessors() 是因为 Spring 设计中，BeanDeifinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 的继承</code><br>PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors()–&gt;<br>ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()–&gt;<br>ConfigurationClassPostProcessor.processConfigBeanDefinitions()–&gt;<br>ConfigurationClassBeanDefinitionReader.loadBeanDefinitions()–&gt;<br>ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsFromRegistrars –&gt;<br>FeignClientsRegistrar.registerBeanDefinitions()</p></blockquote><p>到这里， 我们进入了 Feign 框架的逻辑 <code>FeignClientsRegistrar.registerBeanDefinitions()</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// registerDefaultConfiguration 方法内部从 SpringBoot 启动类上检查是否有 @EnableFeignClients, </span>    <span class="token comment">// 有该注解的话， 则完成 Feign 框架相关的一些配置内容注册</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerDefaultConfiguration</span><span class="token punctuation">(</span>metadata<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// registerFeignClients 方法内部从 classpath 中， 扫描获得 @FeignClient 修饰的类，将类的内容解析为 BeanDefinition , </span>    <span class="token comment">// 最终通过调用 Spring 框架中的 BeanDefinitionReaderUtils.resgisterBeanDefinition 将解析处理过的 FeignClient BeanDeifinition 添加到 spring 容器中</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerFeignClients</span><span class="token punctuation">(</span>metadata<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里值得进一步关注的是， <code>registerFeignClients</code> 方法内部， 调用了一个 <code>registerFeignClient</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">registerFeignClient</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">,</span>                                 <span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> attributes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> className <span class="token operator">=</span> annotationMetadata<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BeanDefinitionBuilder</span> definition <span class="token operator">=</span> <span class="token class-name">BeanDefinitionBuilder</span><span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">FeignClientFactoryBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>此处省一部分代码    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>此处省一部分代码    <span class="token class-name">BeanDefinitionHolder</span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">(</span>beanDefinition<span class="token punctuation">,</span> className<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> alias <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BeanDefinitionReaderUtils</span><span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>holder<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BeanDefinitionBuilder</span> <span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> beanClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">BeanDefinitionBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionBuilder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GenericBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span>beanDefinition<span class="token punctuation">.</span><span class="token function">setBeanClass</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> builder<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意！ 该方法的第二行通过调用<code>genericBeanDefinition</code>方法为 FeignClient 生成了一个 BeanDeifinition, 而该方法的入参是 <code>FeignClientFactoryBean.class</code></p><p>查看 <code>genericBeanDefinition</code> 的逻辑， 发现此处将 FeignClient 的 BeanDefinition 的 beanClass 设置成了<code>FeignClientFactoryBean.class</code> ， 也就是说 FeignClient 被注册成了一个工厂 bean(Factory Bean)。</p><p>这里简单说明下， 工厂 Bean 是一种特殊的 Bean, 对于 Bean 的消费者来说， 他逻辑上是感知不到这个 Bean 是普通的 Bean 还是工厂 Bean, 只是按照正常的获取 Bean 方式去调用， 但工厂bean 最后返回的实例不是工厂Bean 本身， 而是执行工厂 Bean 的 getObject 逻辑返回的示例。</p><p>查看一下 <code>FeignClientFactoryBean</code> 的 <code>getObject</code> 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">FeignContext</span> context <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">FeignContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Feign<span class="token punctuation">.</span>Builder</span> builder <span class="token operator">=</span> <span class="token function">feign</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略代码        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token function">loadBalance</span><span class="token punctuation">(</span>builder<span class="token punctuation">,</span> context<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HardCodedTarget</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略代码    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> targeter<span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> builder<span class="token punctuation">,</span> context<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HardCodedTarget</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看上面两个 return 所调用的方法， 最后发现都会统一使用到 <code>Targeter.target()</code> 方法， 该方法最终调用到 <code>Feign.target</code> 方法, 并进一步触发 <code>RefleactiveFeign.newInstance</code> 的执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">target</span><span class="token punctuation">(</span><span class="token class-name">FeignClientFactoryBean</span> factory<span class="token punctuation">,</span> <span class="token class-name">Builder</span> feign<span class="token punctuation">,</span> <span class="token class-name">FeignContext</span> context<span class="token punctuation">,</span> <span class="token class-name">HardCodedTarget</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> feign<span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">target</span><span class="token punctuation">(</span><span class="token class-name">Target</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">Target</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略代码    <span class="token class-name">InvocationHandler</span> handler <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> methodToHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">T</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略代码<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此， 我们找到了对于 Java 原生的动态代理的使用， 整个 feign 的核心工作原理就基本清晰了， 后续就只是 handler 如何把基于 Proxy 方法的调用转换为 HTTP 请求发出以及翻译回来的 HTTP 响应了， 属于按部就班的工作。这个后续待看。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>Spring Cloud OpenFeign 的核心工作原理经上文探究可以非常简单的总结为：</p><ol><li>通过 @EnableFeignCleints 触发 Spring 应用程序对 classpath 中 @FeignClient 修饰类的扫描</li><li>解析到 @FeignClient 修饰类后， Feign 框架通过扩展 Spring Bean Deifinition 的注册逻辑， 最终注册一个 FeignClientFacotoryBean 进入 Spring 容器</li><li>Spring 容器在初始化其他用到 @FeignClient 接口的类时， 获得的是 FeignClientFacotryBean 产生的一个代理对象 Proxy.</li><li>基于 java 原生的动态代理机制， 针对 Proxy 的调用， 都会被统一转发给 Feign 框架所定义的一个 InvocationHandler ， 由该 Handler 完成后续的 HTTP 转换， 发送， 接收， 翻译HTTP响应的工作</li></ol><p><img src="/.io//1.png" alt="Feign原理流程图"></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
          <category> feign </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud之hystrix</title>
      <link href="2021/05/27/springcloud-zhi-hystrix/"/>
      <url>2021/05/27/springcloud-zhi-hystrix/</url>
      
        <content type="html"><![CDATA[<h2 id="springcloud之hystrix"><a href="#springcloud之hystrix" class="headerlink" title="springcloud之hystrix"></a>springcloud之hystrix</h2><p>注：这是hystrix的文档翻译</p><h3 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h3><h4 id="1-1什么是Hystrix"><a href="#1-1什么是Hystrix" class="headerlink" title="1.1什么是Hystrix"></a>1.1什么是Hystrix</h4><p>在分布式环境中，不可避免地会遇到所依赖的服务挂掉的情况，Hystrix 可以通过增加 <strong>延迟容忍度</strong> 与 <strong>错误容忍度</strong>，来控制这些分布式系统的交互。Hystrix 在服务与服务之间建立了一个中间层，防止服务之间出现故障，并提供了失败时的 <strong>fallback</strong> 策略，来增加你系统的整体可靠性和弹性。</p><h4 id="1-2Hystrix-做了那些事情"><a href="#1-2Hystrix-做了那些事情" class="headerlink" title="1.2Hystrix 做了那些事情"></a>1.2Hystrix 做了那些事情</h4><p>Hystrix 提供了以下服务</p><ul><li>引入第三方的 client 类库，通过延迟与失败的检测，来保护服务与服务之间的调用（网络间调用最为典型）</li><li>阻止复杂的分布式系统中出现级联故障</li><li>快速失败与快速恢复机制</li><li>提供兜底方案（fallback）并在适当的时机进行服务降级</li><li>提供实时监控、报警与操作控制</li></ul><h4 id="1-3Hystrix-解决了什么问题"><a href="#1-3Hystrix-解决了什么问题" class="headerlink" title="1.3Hystrix 解决了什么问题"></a>1.3Hystrix 解决了什么问题</h4><p>在复杂的分布式架构中，服务之间都是相互依赖的，任何一个节点都不可避免会宕机。如果主节点不能从这些宕机节点中独立出来，那主节点将会面临被这些宕机的节点拖垮的风险。举个例子，如果一个应用依赖了 30 个服务，每个服务保证 99.99% 的时间是正常的，那可以计算出</p><blockquote><p>99.9930 = 99.7% uptime<br>0.3% of 1 billion requests = 3,000,000 failures<br>2+ hours downtime/month even if all dependencies have excellent uptime.</p></blockquote><p>完好情况下，请求流如下：</p><p><img src="/.io//1.png" alt="分布式架构请求图"></p><p>当一个依赖的节点坏掉时，将阻塞整个的用户请求：</p><p><img src="/.io//2.png" alt="微服务节点down掉"></p><p>流量高峰时，一个单节点的宕机或延迟，会迅速导致所有服务负载达到饱和。应用中任何一个可能通过网络访问其他服务的节点，都有可能成为造成潜在故障的来源。更严重的是，还可能导致服务之间的延迟增加，占用队列、线程等系统资源，从而导致多系统之间的级联故障（雪崩）。</p><p><img src="/.io//3.png" alt="雪崩"></p><p>更严重的是，当网络请求是通过第三方的一个黑盒客户端来发起时，实现细节都被隐藏起来了，而且还可能频繁变动，这样发生问题时就很难监控和改动。如果这个第三方还是通过传递依赖的，主应用程序中根本没有显示地写出调用的代码，那就更难了。</p><p>网络连接失败或者有延迟，服务将会产生故障或者响应变慢，最终反应成为一个 bug。</p><p>所有上述表现出来的故障或延迟，都需要一套管理机制，将节点变得相对独立，这样任何一个单节点故障，都至少不会拖垮整个系统的可用性。</p><h4 id="1-4Hystrix-的设计原则是什么"><a href="#1-4Hystrix-的设计原则是什么" class="headerlink" title="1.4Hystrix 的设计原则是什么"></a>1.4Hystrix 的设计原则是什么</h4><p>Hystrix 通过以下设计原则来运作:</p><ul><li>防止单个服务的故障，耗尽整个系统服务的容器（比如tomcat）的线程资源。</li><li>通过快速失败，取代放在队列中等待</li><li>提供在故障时的应急方法（fallback）</li><li>使用隔离技术 (如 bulkhead, swimlane, 和 circuit breaker patterns) 来限制任何一个依赖项的影响面</li><li>提供实时监控、报警等手段</li><li>提供低延迟的配置变更</li><li>防止客户端执行失败，不仅仅是执行网络请求的客户端</li></ul><h4 id="1-5Hystrix-是怎么实现它的设计目标的"><a href="#1-5Hystrix-是怎么实现它的设计目标的" class="headerlink" title="1.5Hystrix 是怎么实现它的设计目标的"></a>1.5Hystrix 是怎么实现它的设计目标的</h4><p>如下：</p><ul><li>将远程请求或简单的方法调用包装成 <code>HystrixCommand</code> 或者 <code>HystrixObservableCommand</code> 对象，启动一个单独的线程来运行。</li><li>你可以为服务调用定义一个超时时间，可以为默认值，或者你自定义设置该属性，使得99.5%的请求时间都在该时间以下。</li><li>为每一个依赖的服务都分配一个线程池，当该线程池满了之后，直接拒绝，这样就防止某一个依赖的服务出问题阻塞了整个系统的其他服务</li><li>记录成功数、失败数、超时数以及拒绝数等指标</li><li>设置一个熔断器，将所有请求在一段时间内打到这个熔断器提供的方法上，触发条件可以是手动的，也可以根据失败率自动调整。</li><li>实时监控配置与属性的变更</li></ul><p>当你启用 Hystrix 封装了原有的远程调用请求后，整个流程图变为下图所示。</p><p><img src="/.io//4.png" alt="Hystrix封装"></p><h4 id="1-6Hystrix是怎么工作的"><a href="#1-6Hystrix是怎么工作的" class="headerlink" title="1.6Hystrix是怎么工作的"></a>1.6Hystrix是怎么工作的</h4><p>下图显示通过Hystrix向服务依赖关系发出请求时会发生什么：</p><p><img src="/.io//1" alt="Hystrix工作流程"></p><p>具体将从以下几个方面进行描述：</p><h5 id="1-构建一个HystrixCommand或者HystrixObservableCommand-对象。"><a href="#1-构建一个HystrixCommand或者HystrixObservableCommand-对象。" class="headerlink" title="1.构建一个HystrixCommand或者HystrixObservableCommand 对象。"></a>1.构建一个HystrixCommand或者HystrixObservableCommand 对象。</h5><p>第一步是构建一个<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象来表示你对依赖关系的请求。 其中构造函数需要和请求时的参数一致。</p><p>构造<code>HystrixCommand</code>对象，如果依赖关系预期返回单个响应。 可以这样写：</p><pre><code>HystrixCommand command = new HystrixCommand(arg1, arg2);</code></pre><p>同理，可以构建<code>HystrixObservableCommand</code> ：</p><pre><code>HystrixObservableCommand command = new HystrixObservableCommand(arg1, arg2);</code></pre><h5 id="2-执行Command"><a href="#2-执行Command" class="headerlink" title="2.执行Command"></a>2.执行Command</h5><p>通过使用Hystrix命令对象的以下四种方法之一，可以执行该命令有四种方法（前两种方法仅适用于简单的<code>HystrixCommand</code>对象，并不适用于<code>HystrixObservableCommand</code>）：</p><ul><li><p>execute()–阻塞，，然后返回从依赖关系接收到的单个响应（或者在发生错误时抛出异常）</p></li><li><p>queue()–返回一个可以从依赖关系获得单个响应的future 对象</p></li><li><p>observe()–订阅Observable代表依赖关系的响应，并返回一个Observable，该Observable会复制该来源Observable</p></li><li><p>toObservable() –返回一个Observable，当您订阅它时，将执行Hystrix命令并发出其响应</p><p>  K             value   = command.execute();<br>  Future<K>     fValue  = command.queue();<br>  Observable<K> ohValue = command.observe();       //hot observable<br>  Observable<K> ocValue = command.toObservable();  //cold observable</K></K></K></p></li></ul><p>实际上，同步方法 execute() 底层逻辑是调用 queue().get()，然后 queue() 实际上是调用了  toObservable().toBlocking().toFuture()，也就是说所有 HystrixCommand 的逻辑都是走  Observable 实现</p><h5 id="3-是否请求缓存"><a href="#3-是否请求缓存" class="headerlink" title="3.是否请求缓存"></a>3.是否请求缓存</h5><p>如果为该命令启用请求缓存，并且如果缓存中对该请求的响应可用，则此缓存响应将立即以“可观察”的形式返回。</p><h5 id="4-是否开启熔断"><a href="#4-是否开启熔断" class="headerlink" title="4.是否开启熔断"></a>4.是否开启熔断</h5><p>当执行 command 时，Hystrix 会判断熔断是否开启，如果是开启状态则走 (8) 进行 Fallback 降级策略，如果未开启则走 (5) ，继续下一步判断是否可以执行 command。</p><h5 id="5-线程池-队列-信号量是否已经满负载"><a href="#5-线程池-队列-信号量是否已经满负载" class="headerlink" title="5.线程池/队列/信号量是否已经满负载"></a>5.线程池/队列/信号量是否已经满负载</h5><p>如果上述三者已达到阈值，Hystrix 就会直接走 (8) 进行 Fallback 降级策略</p><h5 id="6-HystrixObservableCommand-construct-或者-HystrixCommand-run"><a href="#6-HystrixObservableCommand-construct-或者-HystrixCommand-run" class="headerlink" title="6.HystrixObservableCommand.construct() 或者 HystrixCommand.run()"></a>6.HystrixObservableCommand.construct() 或者 HystrixCommand.run()</h5><p>在这里，Hystrix通过您为此目的编写的方法调用对依赖关系的请求，其中之一是：</p><ul><li><p>HystrixCommand.run（） - 返回单个响应或者引发异常</p></li><li><p>HystrixObservableCommand.construct（） - 返回一个发出响应的Observable或者发送一个onError通知</p></li></ul><p>如果run（）或construct（）方法超出了命令的超时值，则该线程将抛出一个TimeoutException（或者如果命令本身没有在自己的线程中运行，则会产生单独的计时器线程）。 在这种情况下，Hystrix将直接走 (8)获取Fallback，如果该方法不取消/中断，它会丢弃最终返回值run（）或construct（）方法。</p><p>如果该命令没有引发任何异常并返回响应，则Hystrix在执行某些日志记录和度量报告后返回此响应。 在run（）的情况下，Hystrix返回一个Observable，发出单个响应，然后进行一个onCompleted通知; 在construct（）的情况下，Hystrix返回由construct（）返回的相同的Observable。</p><h5 id="7-计算Circuit-的健康"><a href="#7-计算Circuit-的健康" class="headerlink" title="7.计算Circuit 的健康"></a>7.计算Circuit 的健康</h5><p>Hystrix向断路器报告成功，失败，拒绝和超时，该断路器维护了一系列的计算统计数据组。</p><p>它使用这些统计信息来确定电路何时“跳闸”，此时短路任何后续请求直到恢复时间过去，在首次检查某些健康检查之后，它再次关闭电路。</p><h5 id="8-获取Fallback"><a href="#8-获取Fallback" class="headerlink" title="8.获取Fallback"></a>8.获取Fallback</h5><p>当命令执行失败时，Hystrix试图恢复到你的回退：当construct（）或run（）（6）抛出异常时，当命令由于电路断开而短路时（4），当 命令的线程池和队列或信号量处于容量（5.），或者当命令超过其超时长度时。</p><p>编写Fallback ,它不一依赖于任何的网络依赖，从内存中获取获取通过其他的静态逻辑。如果你非要通过网络去获取Fallback,你可能需要些在获取服务的接口的逻辑上写一个HystrixCommand。</p><h5 id="9-返回成功的响应"><a href="#9-返回成功的响应" class="headerlink" title="9.返回成功的响应"></a>9.返回成功的响应</h5><p>如果 Hystrix command成功，如果Hystrix命令成功，它将以Observable的形式返回对呼叫者的响应。 根据在上述步骤2中调用命令的方式，此Observable可能会在返回给您之前进行转换：</p><p><img src="/.io//2" alt="返回成功响应"></p><ul><li>execute（） - 以与.queue（）相同的方式获取Future，然后在此Future上调用get（）来获取Observable发出的单个值</li><li>queue（） - 将Observable转换为BlockingObservable，以便将其转换为Future，然后返回此未来</li><li>observe（） - 立即订阅Observable并启动执行命令的流程; 返回一个Observable，当您订阅它时，重播排放和通知</li><li>toObservable（） - 返回Observable不变; 您必须订阅它才能实际开始导致命令执行的流程</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
          <category> hystrix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发</title>
      <link href="2021/05/26/bing-fa/"/>
      <url>2021/05/26/bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><ul><li><p><strong>线程数量和程序执行速度的关系</strong></p><p>并发编程的目的是为了让程序运行得更快，但是并不是启动得线程越多就能让程序最大限度地并发执行。在并发编程时，如果希望通过多线程执行任务让程序运行得更快会面临很多挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题。</p></li><li><p><strong>多线程并发的实现</strong></p><p>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短（一般是几十毫秒），所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。</p></li><li><p><strong>上下文切换的概念</strong></p><p>CPU是通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是在切换前会保存上一个任务的状态，以便下次再切换回这个任务时可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p></li><li><p><strong>减少上下文切换的方法</strong></p><ul><li><p>无锁并发编程：多线程竞争锁时会引起上下文切换，所以多线程处理数据时，可以通过一些方法来避免使用锁，例如将数据的id按照hash算法取模分段，不同的线程处理不同数据段的数据。</p></li><li><p>CAS算法：Java的atomic包使用CAS算法来更新数据而不需要加锁。</p></li><li><p>使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</p></li><li><p>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p></li></ul></li><li><p><strong>多线程避免死锁的方法</strong></p><ul><li>避免一个线程同时获得多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的问题。</li></ul></li></ul><hr><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>JMM的设计是为了屏蔽各种硬件和操作系统的内存方法差异，以实现Java程序在各种平台下都能达到一直的内存访问效果。在此之前的主流程序语言，例如C、C++等直接使用物理硬件和操作系统的内存模型，因此不同平台上内存模型的差异可能导致程序在一套平台上并发正常运行，而在另一套平台经常出错。</p><p>JMM必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但又必须定义得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性来获取更好的执行执行速度。直到JDK5，即实现了JSR-133之后，Java内存模型才算成熟完善了起来。</p><hr><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a><strong>主内存与工作内存</strong></h3><p>Java内存模型的主要目的是<strong>定义程序中各种变量的访问规则</strong>，即关注在<em><strong>虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</strong></em>。<code>此处的变量和Java语言中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数</code>，因为局部变量和方法参数是线程私有的，不会被共享，也就自然不存在竞争问题。为了获得更好的执行效率，Java内存模型1. <strong>没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互</strong>，也2. <strong>没有限制即时编译器是否要进行调整代码执行顺序</strong>这类优化措施。</p><p>Java内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><ul><li><p><strong>内存间的交互操作</strong></p><p>关于主内存与工作内存之间的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型定义了以下8种操作来完成。Java虚拟机实现时必须保证这些操作是原子性的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台有例外）。</p><ul><li><strong>lock（锁定）：</strong>作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li><strong>unlock（解锁）：</strong>作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。</li><li><strong>read（读取）：</strong>作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load操作使用。</li><li><strong>load（载入）：</strong>作用于工作内存的变量，它把read操作从主存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）：</strong>作用于工作内存的变量，它<strong>把工作内存中一个变量的值传递给执行引擎</strong>，每当虚拟机遇到一个需要使用变量的值的字节码执行时会执行这个操作。</li><li><strong>assign（赋值）：</strong>作用于工作内存的变量，它<strong>把一个从执行引擎接收的值赋给工作内存的变量</strong>，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）：</strong>作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li><strong>write（写入）：</strong>作用于主内存的变量，它把store操作从工作内存取到的变量值放入主内存的变量中。</li></ul><blockquote><p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意Java内存模型只要求这两种操作必须按顺序执行，但不要求是连续执行，也就是说read与load之间、store和write之间是可插入其他指令的，如对主内存的变量a、b进行访问时，一种可能的顺序是read a、read b、load b、load a。</p></blockquote><p>除了这8种操作外，Java内存模型还规定了必须满足的一些规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主存读取出来了但工作内存不接受，或者工作内存发起了回写但主内存不接受的情况。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li><strong>不允许一个线程在没有发生过任何assign操作的情况下把数据从线程的工作内存同步回主内存。</strong></li><li>一个新的变量只能在主内存中诞生，但不允许在工作内存中直接使用一个未被初始化（load和assign）的变量，即对一个变量实施use或store操作之前，必须先执行assign和load。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定就不允许对其执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。</li></ul><p>这8种内存访问的操作和这些规则，加上针对volatile的一些特殊规定，就能准确地描述出Java程序中哪些内存访问操作在并发下才是安全的。这种定义十分严谨但是过于复杂，之后Java将内存操作简化为lock、unlock、read和write四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变。</p></li></ul><hr><h3 id="针对volatile的特殊规则"><a href="#针对volatile的特殊规则" class="headerlink" title="针对volatile的特殊规则"></a>针对volatile的特殊规则</h3><ul><li><p><strong>作用：</strong></p><p>关键字volatile是Java虚拟机提供的最轻量级的同步机制，Java内存模型为volatile定义了一些特殊的访问规则。当一个变量被定义为volatile之后，它具备两种特性：</p><ul><li><p><strong>保证此变量对所有线程的可见性</strong></p><p>可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是立即可以得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。</p><p>volatile变量在各个线程的工作内存中不存在一致性问题（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但是由于每次使用前都要刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java中的运算操作符并非原子操作，这导致volatile变量的运算在并发下仍是不安全的。</p><ul><li><p><strong>静态变量i执行多线程i++的不安全问题</strong></p><p>通过反编译会发现一个自增语句是由4条字节码指令构成的，按顺序依次为getstatic、iconst_1、iadd、putstatic，当getstatic把i的值取到操作栈顶时，volatile关键字保证了i的值在此刻是正确的，但是在执行iconst_1、iadd这些指令时，其他线程可能已经改变了i的值，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的i值同步回了主内存之中。 </p></li></ul><p>注意：即使编译出来只有一条字节码指令也不能意味着这条指令就是一个原子操作，一条字节码指令在解释执行时，解释器要运行很多行代码才能实现它的语义。如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令。</p><p>​    由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然需要使用锁（synchronized、juc中的锁或原子类）来保证原子性：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他状态变量共同参与不变约束。</li></ul></li><li><p><strong>禁止指令重排序优化</strong></p></li></ul><blockquote><ol><li><p>什么是指令重排？</p><p>   在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列，一般而言，这个指令序列是会输出确定的结果；以确保每一次的执行都有确定的结果。但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化，在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序，在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。</p></li><li><p>数据依赖性</p><p> 主要指不同的程序指令之间的顺序是不允许进行交互的，即可称这些程序指令之间存在数据依赖性。</p><p> 主要的例子如下：</p><p> 名称     代码示例     说明<br> 写后读     a = 1;b = a;     写一个变量之后，再读这个位置。<br> 写后写     a = 1;a = 2;     写一个变量之后，再写这个变量。<br> 读后写     a = b;b = 1;     读一个变量之后，再写这个变量。</p><p> 经过分析，发现这里每组指令中都有写操作，这个写操作的位置是不允许变化的，否则将带来不一样的执行结果。编译器将不会对存在数据依赖性的程序指令进行重排，这里的依赖性仅仅指单线程情况下的数据依赖性；多线程并发情况下，此规则将失效。</p></li><li><p>控制依赖性</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 1</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>  <span class="token comment">// 2</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 例如指令1和指令2不存在数据依赖性但是存在控制依赖性即指令1控制指令2。如果操作3和操作4交换执行顺序，就会使结果出错。但是控制依赖性又会导致并行度降低。</p><p> 编译器和处理器为了提高并行度，使用<strong>猜测执行</strong>来克制控制依赖性对并发度的影响。以处理器猜测执行为例，该线程的处理器可以提前读取a，并且计算a*a的值，然后把结果放到<strong>重排序缓冲</strong>中。当操作3的条件判断为真，就把结果写入到变量i中。</p><p> <strong>但是在多线程程序中，对存在控制依赖关系的操作重排序，可能会改变程序的执行结果</strong></p></li><li><p>as-if-serial语义</p><p> as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p></li></ol></blockquote><p>​        普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p><p>​        使用volatile的变量进行写操作，汇编指令操作是带有lock前缀的，这个操作的作用相当于一个内存屏障，后面的指令不能重排到内存屏障之前的位置。<strong>只有一个处理器时不需要使用内存屏障</strong>，但如果有两个或更多的处理器访问同一块内存，且其中有一个在观测另一个，就需要使用内存屏障来保证一致性了。</p></li></ul><p>​        使用lock前缀的指令在多核处理器中会引发两件事：</p><ul><li><p>将当前处理器缓存行的数据写回到系统内存</p></li><li><p>这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效。</p><p>这种操作相当于对缓存中的变量做了一次store和write操作，可以让volatile变量的修改对其他处理器立即可见。</p></li><li><p><strong>volatile的内存语义</strong></p><p>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。从内存语义的角度来说，volatile的写-读与锁的释放-获取具有相同的内存效果。</p><ul><li><p><strong>volatile写的内存语义：</strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></li><li><p><strong>volatile读的内存语义：</strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p></li></ul><p>线程A写一个volatile变量，实质上是线程A向接下来要读这个volatile变量的某个线程发出了（其对共享变量所修改的）消息。线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。线程A写一个volatile变量，线程B读一个volatile变量，实质上是线程A通过主内存向线程B发送消息。</p></li><li><p><strong>volatile指令重排序的特点</strong></p><ul><li>当第二个操作是volatile写时，不管第一个操作是什么都不能重排序，这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li></ul></li><li><p>当第一个操作是volatile读时，不管第二个操作是什么都不能重排序，这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p></li><li><p>当第一个操作是volatile写，第二个操作是volatile读时不能重排序。</p></li><li><p><strong>volatile的内存屏障插入策略</strong></p><ul><li><p>在每个volatile写操作之前插入一个Store Store屏障,禁止之前的普通写和之后的volatile写重排序。</p></li><li><p>在每个volatile写操作之后插入一个Store Load屏障，防止之前的volatile写与之后可能有的volatile读/写重排序，也可以在每个volatile变量读之前插入该屏障，考虑到一般是读多于写所以选择用这种方式提升执行效率，也可以看出JMM在实现上的一个特点：首先确保正确性，然后再去追求效率。</p></li><li><p>在每个volatile读操作之后插入一个Load Load屏障，禁止之后的普通读操作和之前的volatile读重排序。</p></li><li><p>在每个volatile读操作之后插入一个Load Store屏障，禁止之后的普通写操作和之前的volatile读重排序。</p></li></ul></li><li><p><strong>关于volatile的优化</strong></p><p>可以通过追加字节的方式优化性能，例如JDK7中的队列集合类LinkedTransferQueue就是使用了追加字节的方式来优化队列出队和入队的性能。由于一些处理器的高速缓存行是64个字节宽，不支持部分填充缓存行，如果队列的头节点和尾节点都不足64字节，当一个处理器试图修改头节点时就会将整个缓存行锁定，那么在缓存一致性的作用下会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队又会频繁修改头节点和尾节点，因此多处理器情况下会严重影响队列的入队和出队效率。追加到64字节后就可以填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使它们的操作不会互相锁定。    </p><p>但以下两种场景不应该使用这种方式：①缓存行非64字节宽的处理器。②共享变量不会被频繁地写，因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定性能消耗。如果共享变量不被频繁写，锁的几率很小没有必要避免互相锁定。不过这种追加字节的方式在Java7可能不生效，因为Java7可以淘汰或重新排列无用字段，需要使用其他追加字节的方式。</p></li><li><p><strong>JSR-133增强volatile语义的原因</strong></p><p>在旧的内存模型中，虽然不允许volatile变量之间重排序，但允许volatile变量与普通变量重排序，可能导致内存不可见问题。在旧的内存模型中volatile的写-读没有锁的释放-获取所具有的内存语义，为了提供一种比锁更轻量级的线程通信机制，严格限制了编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p></li><li><p>关于指令重排序的补充</p><ul><li><p><strong>指令重排序的概念</strong></p><p>重排序指从源代码到指令序列的重排序，在执行程序时为了提高性能，编译器和处理器通常会对指令进行重排序，重排序分为三种类型：</p><ul><li><p>编译器优化的重排序：编译器在不改变单线程程序语义的前提下可以重新安排语句的执行顺序。</p></li><li><p>指令级并行的重排序：现代处理器才以来指令级并行技术ILP来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作操作看上去可能是乱序执行。</p></li></ul></li><li><p><strong>指令重排序的问题</strong></p><p>从Java源代码到最终实际执行的指令序列，会分别经历编译器优化重排序、指令级并行重排序和内存系统重排序，这些重排序可能会导致多线程程序出现内存可见性问题。</p><ul><li>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令（一组用于实现对内存操作顺序限制的处理器指令），通过内存屏障指令来禁止特定类型的处理器重排序。</li></ul><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的可见性内存保证。</p></li></ul></li></ul><hr><h3 id="针对long和double类型变量的特殊规则"><a href="#针对long和double类型变量的特殊规则" class="headerlink" title="针对long和double类型变量的特殊规则"></a>针对long和double类型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write这八种操作都具有原子性，但是对于64位的数据类型（long和double），在模型中定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write四个操作的原子性，这就是”long和double的非原子性协定“。</p><p>如果有多个线程共享一个未声明为volatile的long或double类型变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了”半个变量“的数值。这种情况很罕见，但带对于一些32位的Java虚拟机确实存在非原子性访问的风险。</p><hr><h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><ul><li><p><strong>原子性</strong></p><p>由Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，基本数据类型的访问读写都是具备原子性的（例外就是long和double的非原子性协定）。</p><p>如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足需求，尽管虚拟机还没有把lock和unlock开放给用户使用，但却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块synchronized关键字，因此synchronized具有原子性。</p><ul><li><p><strong>原子操作</strong></p><p>原子操作即不可被中断的一个或一系列操作，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><ul><li><p>通过总线锁定保证原子性：如果多个处理器同时对共享变量进行读改写操作（例如i++），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子性的，操作完之后共享变量的值会和期望的不一样。例如i=1，进行两次i++操作，但是结果可能为2。这是因为多个处理器同时从各自的缓存读取变量i，分别进行加1操作，然后分别写入系统内存中。如果想要保证读改写操作的原子性，就必须保证CPU1读改写共享变量时CPU2不能操作缓存了该共享变量内存地址的缓存。处理器使用总线锁来解决这个问题，总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞，该处理器就可以独占共享内存。（总线锁太消耗资源和影响效率，使用MESI）</p></li><li><p>通过缓存锁定来保证原子性：同一时刻只需要保存对某个内存地址的访问是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间其他处理器不能操作其他内存地址的数据，开销比较大，目前的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。频繁使用的内存会缓存在处理器的高速缓存里，原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁。缓存锁定是指内存区域如果被缓存在处理器的缓存行中并且在Lock操作期间被锁定，那么当它执行锁操作回写内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作原子性，因为缓存一致性会阻止同时修改由两个以上处理器缓存的内存区域，当其他处理器回写已被锁定的缓存行数据时会使缓存行无效。</p></li></ul></li><li><p><strong>Java中的原子操作实现</strong></p><p>Java中可以通过锁和循环CAS的方式来实现原子操作。</p><ul><li><p>锁机制保证了只有获得锁的线程才能操作锁定的内存区域，JVM内部实现了很多锁，除了偏向锁JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步代码块时使用循环CAS方式获取锁，退出时使用循环CAS释放锁。</p></li><li><p>JVM中的CAS操作利用了处理器提供的交换指令CMPXCHG实现，自旋CAS的基本思路就是循环进行CAS操作直到成功为止。从Java1.5开始JDK的并发包里提供了一些类来支持原子操作，例如AtomicBoolean（用原子方式更新的boolean值），AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值），这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p></li></ul></li></ul></li><li><p><strong>可见性</strong></p><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，因此volatile保证了多线程操作时变量的可见性。</p><p>除了volatile之外，Java还有两个关键字能实现可见性，分别是synchronized和final。</p><ul><li><p><strong>synchronized：</strong>同步块的可见性是指”对一个变量执行unlock之前，必须先把此变量同步回主内存中（执行store、write操作）。</p></li><li><p><strong>final：</strong>final的可见性是指被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去（this引用逃逸是一件很危险的事，其他线程有可能通过这个引用访问到初始化了一般的对象），那么在其他线程中就能看见final字段的值。</p><ul><li><p><strong>final域的重排序规则</strong></p><p>对于final域，编译器和处理器要遵守两个重排序规则：①在构造方法内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。②初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 </p></li><li><p><strong>写final域重排序的实现原理</strong></p><p>写final域的重排序规则禁止把final域的写重排序到构造方法之外，这个规则的实现包含以下两方面：①JMM禁止编译器把final域的写重排序到构造方法之外。②编译器会在final域的写之后，构造方法的return之前，插入一个Store Store屏障，这个屏障禁止把final域的写重排序到构造方法之外。</p><p>写final域的重排序可以确保在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p></li><li><p><strong>读final域重排序的实现原理</strong></p><p>读final域的重排序规则是，在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（仅针对处理器）。编译器会在读final域操作的前面插入一个Load Load屏障。</p><p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（例如alpha处理器），因此该规则就是专门针对这种处理器的。</p><p>读final域的重排序规则可以确保在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p></li><li><p><strong>final域为引用对象时重排序的特点</strong></p><p>对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造方法内对一个final引用的对象的成员域的写入，与随后在构造方法外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 </p></li><li><p><strong>final语义在X86处理器的实现原理</strong></p><p>写final域的重排序规则是要求编译器在final域的写之后，构造方法return之前插入一个Store Store屏障，读final域的重排序规则是要求编译器在读final域的操作前插入一个Load Load屏障。</p><p>由于X86处理器不会对写-写操作重排序，所以写final域需要的Store Store屏障会被省略。同样，由于X86处理器不会对存在间接依赖关系的操作做重排序，所以在X86处理器中读final域需要的Load Load屏障也会被省略掉。也就是说，X86处理器不会对final域的读/写插入任何内存屏障。</p></li><li><p><strong>JSR133增强final语义的原因</strong></p><p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如一个线程看到一个int类型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值会发现值变为1（被某个线程初始化之后的值）。最常见的例子就是旧的Java内存模型中String的值可能会改变。</p><p>为了修复该漏洞，JSR-133通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造方法中没有逸出），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造方法中被初始化之后的值。</p></li></ul></li></ul></li><li><p><strong>有序性</strong></p><p>Java内存模型的有序性可以总结为：在本线程内观察所有操作是有序的，在一个线程内观察另一个线程，所有操作都是无序的。前半句是指”线程内的as-if-serial语义“，后半句是指“指令重排序”和”工作内存与主内存同步延迟“现象。</p><p>Java提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一个时刻只允许一条线程对其进行lock操作“这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p></li></ul><hr><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><ul><li><p><strong>数据依赖性</strong></p><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时两个操作之间就存在数据依赖性。数据依赖分为以下三种类型：①写后读，写一个变量之后再读这个位置。②读后写，读一个变了之后再写这个变量。③写后写，写一个变量之后再写这个变量。</p><p>上述三种情况只要重排序两个操作的执行顺序，程序的执行结果就会被改变。编译器和处理器为了性能优化可能会对操作重排序，在重排序时会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序。这里说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p></li><li><p><strong>as- if-serial</strong></p><p>as-if-serial指不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵循该语义。为了遵循该语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但如果操作之间不存在数据依赖关系，这些操作就可能被重排序。</p><p>as-if-serial语义将单线程保护了起来，遵循as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按照程序的顺序执行的。as-if-serial使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><p>as-if-serial实例：例如计算一个圆的面积，A操作给半径赋值，B操作给圆周率赋值，C操作计算圆的面积。由于C依赖于A和B因此不会被重排到A和B的前面，但A和B之间没有数据依赖关系，所以程序的执行顺序可以是ABC或BAC，结果是一样的。</p></li><li><p><strong>控制依赖关系对指令重排序的影响</strong></p><p>当代码中存在控制依赖性时（例如A操作判断某标志位，B操作根据A的结果执行对应逻辑），会影响指令序列执行的并行度。为此编译器和处理会采用猜测执行来克服控制相关性对并行度的影响，可以提前计算出值保存到名为重排序缓冲的硬件缓存中，如果之前的控制条件满足就执行对应操作。</p><p>在单线程程序中，对存在控制依赖的操作重排序并不会改变程序的执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）。但在多线程程序中，对存在控制依赖的操作从排序可能会改变程序的执行结果。</p></li></ul><hr><h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h3><p>如果Java内存模型中所有有序性都依靠volatile和synchronized来完成，许多操作会变得过于繁杂，Java语言中有一个先行发生原则（happens-before），这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，可以通过几条简单规则解决并发环境下两个操作之间可能存在冲突的所有问题。</p><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改内存中共享变量的值、发送了消息、调用了方法等。</p><p>Java内存模型存在一些天然的happens-before关系，这些happens-before关系无需任何同步器协助，可以在编码中直接使用。如果两个操作的关系不在此列，并且无法从这些规则推导出来，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。</p><ul><li><strong>程序次序规则</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。</li><li><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。</li><li><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。</li><li><strong>线程启动规则</strong>：线程对象的start方法先行发生于此线程的每一个动作。</li><li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检测，可以通过join方法是否结束或isAlive方法的返回值等手段检测线程是否已经终止执行。</li><li><strong>线程中断规则</strong>：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interruptted方法检测是否有中断发生。</li><li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于它的finalize方法的开始。</li><li><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以得出操作A先行发生于操作C的结论。</li></ul><p><strong>happens-before的重排序策略：</strong></p><p>JMM将happens-before要求禁止的重排序分为了下面两类：会改变程序执行结果的重排序和不会改变程序执行结果的重排序。JMM对这两种不同性质的重排序采取了不同的策略，对于会改变程序执行结果的重排序JMM要求编译器和处理器必须禁止这种重排序；对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。</p><p>JMM向程序员提供happens-before规则能满足程序员的需求，其规则不但简单易懂而且也向程序员提供了足够强的内存可见性保证（有些内存保证性不一定真实存在，例如不改变执行结果的指令重排序对程序员是透明的）。</p><p>JMM对编译器和处理器的束缚已经尽可能地少，JMM遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。例如编译器分析某个锁只会单线程访问就消除该锁，某个volatile变量只会单线程访问就把它当作普通变量。</p><p><strong>happens-before的具体含义：</strong></p><p>①如果一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。这是JMM对程序员的承诺。</p><p>②两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序执行，如果重排序之后的执行结果与按照happens-before关系的执行结果一致，那么这种重排序是可以允许的。这是JMM对编译器和处理器的约束规则，JMM遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。JMM这么做的原因是程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行的语义不能被改变（即执行结果不能被改变）。因此happens-before关系的本质和as-if-serial一样。</p><p><strong>happens-before和as-if-serial的区别：</strong></p><p>as-if-serial语义保证单线程程序的执行结果不被改变，happens-before保证正确同步的多线程程序的执行结果不被改变。</p><p>as-if-serial语义给编写单线程程序的程序员创造了一种单线程程序是顺序执行的幻觉，happens-before关系给编写正确同步的多线程程序员创造了一种多线程程序是按照happens-before指定顺序执行的幻觉。</p><p>这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行的并行度。</p><hr><h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><ul><li><p><strong>JMM内存屏障分类</strong></p><ul><li>Load Load，确保Load1的数据装载先于Load2及所有后续装载指令的装载。</li><li>Store Store，确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储指令的存储。</li><li>Load Store，确保Load1数据装载先于Store2及所有后续存储指令刷新到内存。</li><li>Store Load，确保Store1数据对其他处理器变得可见（刷新到内存）先于Load2及所有后续装载指令的装载。</li></ul><p>Store Load会使该屏障之间的所有内存访问指令（存储和装载指令）完成之后才执行该屏障之后的内存访问指令。该指令是一个“全能型”屏障，同时具备其他三个屏障的效果，现代的多处理器大多支持该屏障，执行该屏障的开销很昂贵，因为当前处理器通常要把写缓冲区的数据全部刷新到内存中。</p></li><li><p><strong>数据竞争和顺序一致性</strong></p><p>当程序未正确同步时就可能存在数据竞争。JMM规范对数据竞争的定义如下：在一个线程中写一个变量，在另一个线程中读同一个变量，而且写和读没有通过同步来排序。当代码中包含数据竞争时程序的执行往往产生违反直觉的结果，如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p><p>JMM对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。这里的同步是指广义上的同步，包括对常用同步用语（synchronized、volatile和final）的正确使用。</p><ul><li><p><strong>顺序一致性内存模型的特点</strong></p><p>顺序一致性内存模型是一个理想化的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：①一个线程中的所有操作必须按照程序的顺序来执行。②不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序，在顺序一致性的内存模型中，每个操作都必须原子执行并且立即对所有线程可见。</p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。在任意时间点最多只能有一个线程可以连接到内存，当多个线程并发执行时，开关装置能把线程的所有内存读/写操作串行化（即在顺序一致性模型中所有操作之间具有全序关系）</p></li></ul></li><li><p><strong>未同步程序</strong></p><ul><li><p><strong>未同步程序的问题</strong></p><p>未同步程序在顺序一致性模型中虽然整体执行顺序无序但是所有线程都能看到一个一致的整体执行顺序。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><p>JMM中没有这个保证，未同步程序在JMM中不但整体的执行顺序无序，并且所有线程看到的操作执行顺序也可能不一致。比如当前线程把写过的数据缓存到本地内存，在没有刷新到主内存前，这个写操作仅对当前线程可见。从其他线程的角度会认为这个写操作并没有执行，只有当前线程把本地内存中写过的数据刷新回主内存之后这个写操作才对其他线程可见，这种情况下当前线程和其他线程看到的操作执行顺序不一致。</p></li><li><p><strong>未同步程序的执行特性</strong></p><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值要么是之前某个线程写入的值，要么是默认值，JMM保证线程读操作读取到的值不会无中生有。为了实现最小安全性，JVM在堆上分配对象时首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部同步这两个操作）。因此在已清零的内存空间分配对象时，域的默认初始化已经完成了。</p><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型的执行结果一致，因为如果想要保证一致需要禁止大量的处理器和编译器优化，这对程序执行性能会有很大影响。而且未同步程序在顺序一致性模型中执行时整体是无序的，结果无法预知，因此保证未同步执行程序在两个模型的执行结果一致没什么意义。</p></li><li><p><strong>未同步程序在JMM和顺序一致性模型的执行区别</strong></p><ul><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li><li>JMM不保证对64位的long类型和double类型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li></ul></li></ul></li><li><p><strong>总线的工作机制和好处</strong></p><p>在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称为总线事务。总线事务包括读事务和写事务。读事务从内存中传输数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中的一个或多个物理上连续的字，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和IO设备执行内存的读/写。</p><p>总线的工作机制可以把所有处理器对内存的访问以串行化的方式来执行，在任意时间点最多只能有一个处理器访问内存，这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p></li><li><p><strong>处理器内存模型的分类以及JMM对不同处理器的处理</strong></p><ul><li><p><strong>处理器分类</strong></p><ul><li>放松程序中写-读操作的顺序，由此产生了TSO内存模型。</li><li>在TSO的基础上继续放松程序中写-写操作的顺序，由此产生了PSO内存模型。</li><li>在TSO和PSO的基础上，继续放松程序中读-写（以两个操作之间不存在数据依赖性为前提）和读-读操作的顺序，由此产生了RMO和PowerPC内存模型。</li></ul></li><li><p><strong>JMM对不同处理器模型的处理</strong></p><p>不同的处理器模型，性能越好，内存模型的设计越弱，因为处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p></li></ul></li><li><p><strong>Java程序内存可见性保证的分类</strong></p><ul><li><p>单线程程序：单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在一致性模型中的执行结果相同。</p></li><li><p>正确同步的多线程程序：正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在一致性模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p></li><li><p>未同步/未正确同步的多线程程序：JMM为它们提供了最小安全性保证，线程执行读取到的值要么是之前某个线程写入的值，要么是默认值，但不保证该值是正确的。</p></li></ul></li><li><p><strong>JSR-133对旧内存模型的修补</strong></p><ul><li>增强volatile的内存语义，旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</li><li>增强final的内存语义，旧内存模型中多次读取同一个final变量的值可能会不相同，为此JSR-133为final增加了两个重排序规则。在保证final引用不会从构造方法逸出的情况下，final具有了初始化安全性。</li></ul></li></ul><h2 id="Java和线程"><a href="#Java和线程" class="headerlink" title="Java和线程"></a>Java和线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件IO等），又可以独立调度。目前线程是Java中进行处理器资源调度的最基本单位。</p><p>主流的操作系统都提供了线程实现，Java则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经调用过start方法且还未结束的java.lang.Thread类的实例就代表着一个线程。Thread类的所有关键方法都被声明为native，一个native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（也有可能是为了执行效率而使用native方法，通常最高效率的手段都是平台相关的手段）。</p><p>实现线程主要有三种方式：</p><ul><li><p><strong>使用内核线程实现（1:1实现）</strong></p><p>使用内核线程实现的方式也被称为1:1实现，内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为一个内核的分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核。</p><p>程序一般不会直接使用内核线程，而是使用内核线程的另一种高级接口即轻量级进程（Light Weight Process，LWP），轻量级进程就是通常所说的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程，这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。</p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程已经在系统调用中被阻塞了，也不会影响整个进程继续工作。轻量级进程也具有它的局限性：首先由于是基于内核线程实现的，所以各种线程操作，如创建、析构和同步等，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</p></li><li><p><strong>使用用户线程实现（1:N实现）</strong></p><p>使用用户线程实现的方式被称为1:N实现，从广义上说，一个线程只要不是内核线程就可以认为是用户线程（User Thread，UT）的一种，因此从该定义上来说轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用因此效率会受到限制，并不具备通常意义上的用户线程的优点。</p><p>狭义上的用户线程是指完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持更大规模的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1:N的关系称为一对多的线程模型。</p><p>用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核支援，所有的线程操作都需要用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”等问题变得难以解决。因为基于用户线程的实现的程序一般比较复杂，除了有明确的需求外一般的应用程序都不倾向使用用户线程，Java曾经使用过但最终又放弃了它。今年来许多新的以高并发为卖点的编程语言又普遍支持了用户线程，如Golang、Erlang等，使用户线程的使用率有所回升。</p></li><li><p><strong>使用用户线程加轻量级进程混合实现（N:M实现）</strong></p><p>线程除了依赖内核线程实现和用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为N:M实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然消耗低并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程和轻量级进程的数量比是不定的，是N:M的关系。</p><p>许多UNIX系列的操作系统都提供了这种混合的线程模型实现。</p></li></ul><hr><h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>Java线程如何实现并不受Java虚拟机规范的约束 ，这是一个与具体虚拟机相关的问题。Java线程早期在Classic虚拟机（JDK1.2之前）上是基于一种被称为绿色线程的用户线程实现的，但从JDK1.3开始，主流平台上的主流商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现。即采用1:1的线程模型。</p><p>以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己不会去干涉线程调度（可以设置线程优先级供操作系统调度参考），全权交给底层的操作系统处理。所以何时冻结或唤醒线程、该给线程分配多少CPU时间片、该把线程安排给哪个CPU核心去执行等都是由操作系统完成的，也都是由操作系统全权决定的。</p><p>还有一些例外的情况，例如用于JavaME的CLDC虚拟机，它同时支持两种线程模型，默认使用1:N的用户线程实现的线程模型，所有Java线程都映射到一个内核线程上；但它也可以使用另一种特殊的混合模型，Java线程依旧全部映射到一个内核线程上但是当Java线程要执行一个阻塞调用时，CLDC会为该调用单独开一个内核线程并且调度执行其他Java线程，等到那个阻塞调用完成之后再重新调度之前的Java线程继续执行。</p><p>另外一个例子时Solaris平台上的HotSpot虚拟机，由于操作系统的现场特性本来就可以同时支持1:1和N:M的线程模型，因此该平台上的虚拟机也对应提供了两个平台专有的虚拟机参数来明确指定虚拟机使用哪种线程模型。</p><p>操作系统支持怎样的线程模型，在很大程度上会影响上面的Java虚拟机的线程的是怎样映射的，这一点在不同平台上很难达成一致，因此《Java虚拟机规范》中没有限定Java线程实现的线程模型，线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编程和运行过程来说这些差异都是完全透明的。</p><hr><h3 id="Java线程的调度"><a href="#Java线程的调度" class="headerlink" title="Java线程的调度"></a>Java线程的调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，调度方式主要有两种，分别是协同式线程调度和抢占式线程调度。</p><p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完成之后，要主动通知系统切换到另一个线程上去。协同式多线程最大的好处就是实现简单，由于线程要把自己的事情干完之后才会进行线程切换，切换操作对线程自身是可知的，所以一般没有线程同步问题。它的缺点也很明显：线程执行的时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞。</p><p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程切换不由线程本身来决定。例如Java中的yield方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程自身是没有什么办法的。这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。Java使用的线程调度方式就是抢占式调度。</p><p>虽然Java线程调度是系统自动完成的，但我们依旧可以通过setPriority方法为线程设置优先级来为系统提供建议，为某些线程多分配一些时间，其他的一些线程可以少分配一些时间。Java中一共设置了10个级别的线程优先级，在两个线程同时处于可运行状态时优先级高的线程容易被操作系统选择执行。</p><p>不过线程优先级并不是一项稳定的调节手段，因为主流虚拟机上的Java线程是被映射到系统的原生线程上来实现的，所以线程调度最终的决定权还是在操作系统。尽管现代操作系统基本都提供了线程优先级的概念，但是并不见得能和Java线程的优先级一一对应，如Solaris中线程有2147483648种线程优先级，而Windows系统中就只有7种。如果操作系统的线程优先级比Java线程优先级更多，问题还比较容易处理，但如果比Java的优先级少，就不得不出现几个线程优先级对应一个操作系统优先级的情况了，在Windows种设置线程优先级1和2、3和4、6和7、8和9的效果是完全一样的。</p><hr><h3 id="Java线程的通信"><a href="#Java线程的通信" class="headerlink" title="Java线程的通信"></a>Java线程的通信</h3><p>通信是指线程之间以何种机制来交换信息，在命令式编程中线程之间的通信机制有两种，共享内存和消息传递。在共享内存的并发模型里线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里线程之间没有公共状态，线程之间必须通过发送消息来显示通信。</p><p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制，在共享内存的并发模型里同步是显示进行的，程序员必须显示指定某个方法或代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在接受之前，同步是隐式进行的。</p><p>Java并发采用共享内存模型，线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><hr><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul><li><p><strong>NEW：</strong>初始状态，创建后还没有启动的线程处于这种状态，此时还没有调用start()方法。</p></li><li><p><strong>RUNNABLE：</strong>运行状态，Java线程将操作系统中的就绪（Ready）和运行（Running）两种状态统称为运行中，此时线程有可能正在等待操作系统分配CPU时间片，也有可能正在执行。</p></li><li><p><strong>BLOCKED：</strong>阻塞状态，阻塞状态与等待状态的区别是阻塞状态在等待一个排它锁，在程序等待进入同步区域时线程将进入这种状态。</p></li><li><p><strong>WAITING：</strong>等待状态，表示线程进入等待状态，处于该状态的线程不会被分配CPU时间片，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>会导致线程陷入等待状态的方法：</p><ul><li>没有设置timeout参数的wait方法。</li><li>没有设置timeout参数的join方法。</li><li>LockSupport的park方法。</li></ul></li><li><p><strong>TIME_WAITING：</strong>限期等待状态，该状态不同于WAITING，可以在指定时间内自行返回。</p><p>会导致线程陷入限期等待状态的方法：</p><ul><li>设置了timeout参数的wait方法。</li><li>设置了timeout参数的join方法。</li><li>LockSupport的parkNanos方法。</li><li>LockSupport的parkUntil方法。</li></ul></li><li><p><strong>TERMINATED：</strong>终止状态，表示当前线程已经执行完毕。</p></li></ul><hr><h2 id="线程安全与锁"><a href="#线程安全与锁" class="headerlink" title="线程安全与锁"></a>线程安全与锁</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><blockquote><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。</p><p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>不过在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p></blockquote><h4 id="双重检验锁方式实现单例模式"><a href="#双重检验锁方式实现单例模式" class="headerlink" title="双重检验锁方式实现单例模式"></a>双重检验锁方式实现单例模式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//先判断对象有没有实例化过</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p>使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p></blockquote><p><strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p><em>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</em></p><h4 id="源码探析"><a href="#源码探析" class="headerlink" title="源码探析"></a>源码探析</h4><blockquote><ul><li><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p></li></ul><blockquote><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMoniter实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p><p>另外，**<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。**</p></blockquote><ul><li><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</li></ul></blockquote><h4 id="sychronized底层优化"><a href="#sychronized底层优化" class="headerlink" title="sychronized底层优化"></a>sychronized底层优化</h4><p>JDK1.6 对锁的实现引入了大量的<code>优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化</code>等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁</strong>状态，他们会随着竞争的激烈而逐渐升级。注意锁<em>可以升级不可降级</em>，这种策略是为了提高获得锁和释放锁的效率。具体可见:<a href="https://www.cnblogs.com/wuqinglong/p/9945618.html">Java6 及以上版本对 synchronized 的优化</a></p><h4 id="sychronized与ReentrantLock的区别"><a href="#sychronized与ReentrantLock的区别" class="headerlink" title="sychronized与ReentrantLock的区别"></a>sychronized与ReentrantLock的区别</h4><ul><li><h4 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h4></li><li><h4 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4></li><li><h4 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h4><ul><li><strong>等待可中断</strong></li><li><strong>可实现公平锁</strong> </li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong></li></ul></li></ul><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h4 id="Volatile和锁的内存语义"><a href="#Volatile和锁的内存语义" class="headerlink" title="Volatile和锁的内存语义"></a>Volatile和锁的内存语义</h4><blockquote><p>理解了volatile的内存语义，锁的内存语义就会好理解了。</p><pre><code>当线程获取锁时，JMM会把线程对应的本地内存置为无效，然后临界区的代码从主存中读入共享变量到工作内存。当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</code></pre><p>看完上面锁的内存语义，是不是感觉和volatile的内存语义很相像。对比锁和volatile的内存语义：</p><pre><code>锁的获取和volatile的读有相同的内存语义锁的释放和volatile的写有相同的内存语义</code></pre></blockquote><h4 id="前戏：CPU-缓存模型"><a href="#前戏：CPU-缓存模型" class="headerlink" title="前戏：CPU 缓存模型"></a>前戏：CPU 缓存模型</h4><blockquote><p><strong>为什么要弄一个 CPU 高速缓存呢？</strong></p><p>类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 <strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p><p>我们甚至可以把 <strong>内存可以看作外存的高速缓存</strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。</p><p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p></blockquote><h4 id="前戏：-JMM-Java-内存模型"><a href="#前戏：-JMM-Java-内存模型" class="headerlink" title="前戏： JMM(Java 内存模型)"></a>前戏： JMM(Java 内存模型)</h4><blockquote><p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p></blockquote><p><img src="/.io//1" alt="线程读取主内存数据"></p><p>要解决这个问题，就需要把变量声明为**<code>volatile</code>**，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>所以，**<code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**</p><h4 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h4><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h4 id="synchronized-关键字和-volatile-关键字的区别"><a href="#synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="synchronized 关键字和 volatile 关键字的区别"></a>synchronized 关键字和 volatile 关键字的区别</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ol><li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以**<code>volatile </code>性能肯定比<code>synchronized</code>关键字要好<strong>。但是</strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块**。</li><li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li><li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ol><blockquote><ul><li>当对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存</li><li>写操作会导致其他线程中的缓存无效</li><li>其他线程使用缓存时，发现本地工作内存中此变量无效，便从主内存中获取，这样获取到的变量便是最新的值，实现了线程的可见性。</li></ul><p><code>volatile</code>是通过编译器在生成字节码时，在指令序列中添加“<strong>内存屏障</strong>”来禁止指令重排序的。</p><p><code>volatile</code>在字节码层面，就是使用访问标志：<strong>ACC_VOLATILE</strong>来表示，供后续操作此变量时判断访问标志是否为ACC_VOLATILE，来决定是否遵循volatile的语义处理。</p></blockquote><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><blockquote><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p><p>再举个简单的例子：</p><p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p></blockquote><h3 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h3><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外地同步，或者在调用方进行任何其他地协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><p>这个定义要求线程安全的代码都必须具备一个共同特征：代码本身封装了所有必要的正确性保障手段，令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。</p><p>在Java中，按照线程安全的“安全程度”由强到弱，可以把Java中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><ul><li><p><strong>不可变</strong></p><p>在Java中，不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全的保障措施。只要一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。</p><p>在Java中，如果多线程共享的数据是一个基本类型数据，那么只要定义时使用final关键字修饰就可以保证它是不可变的。如果共享的数据是一个对象，需要保证对象自身的行为不会对其状态产生任何影响，才能保证这个对象的不可变性，例如可以将对象中带有状态的变量都声明为final类型，这样在构造器执行结束后它就是不可变的，例如Integer类将自己的成员变量使用fianl修饰保证不可变性。</p><p>不可变类型还有String、常用的枚举类型以及Long、Double等包装器类型、BigInterger和BigDecimal大数据类型，但不包括AtomicInteger和AtomicLong类型。</p></li><li><p><strong>绝对线程安全</strong></p><p>绝对线程安全的定义很严格，大部分Java API中标注自己是线程安全的类都不是绝对线程安全的，例如Vector容器，虽然它的方法都被synchronized修饰，保证了原子性、可见性和有序性、但是并不意味着调用它时就永远不需要同步手段了，例如多线程同时执行对Vector对象的get和remove操作，如果一个线程恰好在错误的时间删除了一个元素，导致get操作中遍历的索引不可用，那么get操作就会抛出索引越界异常。</p></li><li><p><strong>相对线程安全</strong></p><p>相对线程安全就是通常意义上讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用时不需要进行额外地保障措施，但是对于一些特定顺序地连续调用，就可能需要在调用端使用额外地同步手段来保证调用的正确性。</p><p>在Java中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Colletcions的synchronizedCollection()方法包装的集合等。</p></li><li><p><strong>线程兼容</strong></p><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们常说的一个类不是线程安全的通常就是这种情况，Java类库API中大部分的类都是线程兼容的，例如ArrayList和HashMap等。</p></li><li><p><strong>线程对立</strong></p><p>线程对立是指不管调用端是否采取了同步措施都无法在多线程环境中并发使用代码。由于Java语言天生支持多线程特性，线程对立这种排斥多线程的代码很少出现，而且通常都是有害的，应当尽量避免。</p><p>一个线程对立的例子就是Thread类的suspend和resume方法，如果有两个线程同时持有一个线程对象，一个尝试去中断，另一个尝试去恢复，在并发进行的情况下无论调用时是否进行了同步，目标线程都存在死锁风险：假如suspend中断的线程就是即将要执行resume的那个线程，那肯定就会产生死锁。因此这两个方法都已经被废弃了，常见线程对立的操作还有System.setIn()、System.setOut()等方法。</p></li></ul><hr><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li><p><strong>互斥同步</strong></p><p>互斥同步是一种最常见的也是最主要的并发正确性保障手段。同步是指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。互斥是方法，同步是目的。</p><p>在Java中最基本的互斥同步手段就是synchronized关键字，它是一种块结构的同步语法。synchronized关键字经过Javac编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象，如果代码中指定了对象参数，那么就以该对象作为锁定对象，如果没有明确指定，那么根据synchronized修饰的是方法类型（实例方法或类方法）来决定锁对象是实例对象还是类型对应的Class对象。</p><p>根据《Java虚拟机规范》的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了那个对象的锁，那么就把锁的计数器的值增加1，而在执行monitorexit指令时会将锁计数器的值减1。一旦计数器的值为0，锁随即就被释放了。如果获取锁对象失败，那当前线程就应该被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p><p>根据《Java虚拟机规范》对monitorenter和monitorexit的行为描述，可以得出两个关于synchronized的直接推论：</p><ul><li>被synchronized修饰的同步块对一条线程来说是可重入的，这意味同一条线程反复进入同步块也不会出现将自己锁死的情况。</li><li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库的锁那样强制已获得锁的线程释放锁，也无法强制正在等待锁的线程中断等待或超时退出。</li></ul><p>从执行成本的角度看，持有锁是一个重量级的操作。在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免陷入用户态到核心态的转换中，进行这些状态转换需要耗费很多的处理器时间。尤其是对于代码很简单的同步块，例如被synchronized修饰的getter和setter方法，状态转换消耗的时间甚至比用户代码本身执行的时间还要长。因此才说synchronized是Java中的一个重量级操作，不过Java之后也进行了相关的锁优化措施。</p><p>除了synchronized关键字之外，自JDK5起Java类库新提供了juc包，其中的Lock接口成为了另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面上去实现同步。</p><p>重入锁ReentrantLock是Lock接口最常见的一种实现，它与synchronized一样是可重入的，在基本用法上与synchronized也很相似，不过它增加了一些高级功能，主要包括以下三项：</p><ul><li><strong>等待可中断：</strong>是指持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待而处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li><li><strong>公平锁：</strong>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带有布尔值的构造器要求使用公平锁。不过一旦使用了公平锁，将会导致性能急剧下降，明显影响吞吐量。</li><li><strong>锁绑定多个条件：</strong>是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联时就不得不额外添加一个锁，而ReentrantLock无须这样做，可以多次调用newCondition()方法。</li></ul><p>在JDK5时ReentrantLock比synchronized性能有显著优势，而在JDK6中进行锁优化之后，二者的性能基本能够持平。</p><p>当synchronized和ReentrantLock都可以满足要求时可以优先考虑使用synchronized：</p><ul><li>synchronized是Java语法层面的同步，足够清晰也足够简单。</li><li>Lock应该确保在finally中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话可以由Java虚拟机来确保即使出现异常锁也能被正常释放。</li><li>尽管在JDK5时ReentrantLock的性能领先于synchronized，但从长远来看Java虚拟机更容易针对synchronized进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用Lock的话，Java虚拟机很难得知具体哪些锁对象是由特定线程持有的。</li></ul></li><li><p><strong>非阻塞同步</strong></p><p>互斥同步面临的主要问题是进行线程阻塞和唤醒带来的性能开销，因此这种同步也被称为阻塞同步。从解决方式来看，互斥同步属于一种悲观的并发策略，其总是认为只要不去做正确的同步措施那就肯定会出现问题，无论共享的数据是否真的会发生竞争，它都会进行加锁，这会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。</p><p>随着硬件指令集的发展，我们已经有了其他选择：基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进性操作，如果没有其他线程竞争共享数据操作就直接成功了；如果共享数据的确存在竞争，那再进行其他措施，例如不断重试直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步，使用这种措施的代码也被称为无锁编程。</p><p>之所以说乐观并发策略需要“硬件指令集的发展”，是因为我们必须要求操作和冲突检测这两个步骤具备原子性。如果在使用互斥同步来保证原子性就完全失去意义了，因此只能考硬件来实现这件事，硬件保证某些从语义上看起来需要多次操作的行为可以通过一条处理器指令就能完成，这类指令常用的有：测试并设置、获取并增加、交换、比较并交换（CAS）、加载链接/条件存储（LL/SC）。</p><p>其中测试并设置、获取并增加、交换这三条是20世纪就已经存在于大多数指令集中的处理器指令，后面两条是现代处理器新增的，而且这两条指令的目的和功能也是类似的。Java中最终暴露出来的是CAS操作。</p><ul><li><p><strong>CAS</strong></p><p>CAS指令需要有三个操作数，分别是内存位置（在Java中可以理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是不管是否更新了V的值都会返回V的旧值，上述的处理过程是原子操作，执行期间不会被其他线程打断。</p></li></ul><p>在JDK5之后，Java类库中才开始使用CAS操作，该操作由sun.misc.Unsafe类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供。HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件地内联进去了。不过由于Unsafe类设计时就不是给用户程序调用的类（Unsafe的getUnsafe方法限制了只有启动类加载器加载的Class才能访问它），因此在JDK9之前只有Java类库可以使用CAS，譬如juc包里的AtomicInteger类，其中的<code>compareAndSet()</code>和<code>getAndIncrement()</code>等方法都使用了Unsafe类的CAS操作来实现。如果用户程序也有使用CAS操作的需求，要么就采用反射手段突破Unsafe的访问限制，要么只能通过Java类库API来间接使用它。直到JDK9之后，Java类库才在VarHandle类中开放了面向用户程序使用的CAS操作。</p><p>AtomicIntegr的<code>incrementAndGet()</code>方法在一个无限循环中，不断尝试将一个比当前值大1的新值赋值给自己，如果失败了就说明执行CAS操作的时候旧值已经发生了变化，于是再次循环进行下一次操作直到成功为止。</p><p>尽管CAS既简单又高效，但这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，它存在一个逻辑漏洞：如果一个变量V初次读取的时候是A，并且在准备赋值的时候检查到它的值仍为A，这依旧不能说明它的值没有被其他线程更改过，因为这段时间内假设它的值先改为了B又改回了A，那么CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的ABA问题，juc包为了解决这个问题提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值得版本来保证CAS的正确性。不过目前这个类并不常用，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p></li><li><p><strong>无同步方案</strong></p><p>要保证线程安全，也并非一定要进行阻塞同步或非阻塞同步，同步与线程安全没有必然联系。同步只是保障存在共享数据竞争时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此有一些代码天生就是线程安全的。</p><ul><li><p><strong>可重入代码：</strong>这种代码又称纯代码，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里，可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，可重入性是更为基础的特性，它可以保证代码线程安全，即所有可重入的代码都是线程安全的，但并非所有线程安全的代码都是可重入的。</p><p>可重入代码有一些共同特征，例如不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入，不调用非可重入方法等。如果一个方法的返回结果是可预测的，只要输入了相同的数据就都能返回同样的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p></li><li><p><strong>线程本地存储：</strong>如果一段代码中所需要的数据必须与其他代码共享，那就判断这些共享数据的代码能否保证在同一线程中执行，如果可以就把共享数据的可见性限制在一个同一线程之内，这样无须同步也能保证线程之间不出现数据竞争的问题。</p><p>符合这种特定的应用并不少见，大部分使用消费队列的架构模式（如生产者-消费者模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是Web交互模型中的“一个请求对应一个服务器线程”的处理方式，这种处理方式的广泛使用使很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>在Java中可以使用ThreadLocal类来实现线程本地存储的功能，每个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以<code>ThreadLocal.threadLocalHashCode</code>为键，本地线程变量为值的K-V键值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的<code>threadLocalHashCode</code>值，使用这个值就可以在线程K-V键值对中找到对应的本地线程变量。</p></li></ul></li></ul><hr><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li><p><strong>锁的内存语义和实现</strong></p><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p><p>锁的释放与volatile写具有相同的内存语义，锁获取与volatile读具有相同的内存语义。线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。线程A释放这个锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p><p>公平锁和非公平锁释放时，最后都要写一个volatile变量state。公平锁获取锁时，首先会去读volatile变量，非公平锁获取锁时，首先会用CAS更新volatile变量的值，这个操作同时具有volatile读和volatile写的内存语义。因此锁的释放-获取内存语义的实现方式为：①利用volatile变量的写-读具有的内存语义。②利用CAS所附带的volatile读和volatile写的内存语义。</p></li></ul><p>高效并发是从JDK5升级到JDK6后的一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量资源去实现各种锁优化技术，如适应性自旋、锁消除、锁膨胀、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序地执行效率。</p><ul><li><p><strong>自旋锁与自适应自旋</strong></p><p>互斥同步对性能最大地影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。同时虚拟机开发团队也注意到了在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂机和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多核心处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>自旋锁在JDK1.4.2中就已经引入，只不过默认是关闭的，可以使用<code>-XX:+UseSpinning</code>参数来开启，在JDK6中就已经改为默认开启了。自旋等待不能代替阻塞，不说对处理器数量的要求，自选等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自选等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认次数是十次，用户可以使用<code>-XX:PreBlockSpin</code>来指定。</p><p>不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。在JDK6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能之间省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长以及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准。</p></li><li><p><strong>锁消除</strong></p><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上的数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p></li><li><p><strong>锁粗化</strong></p><p>原则上我们在编写代码时，总是推荐将同步块的作用范围限制得尽量小，只在共享数据得实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁得线程也能尽可能快拿到锁。</p><p>大多数情况下这种原则是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，那么即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能消耗。</p><p>如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p></li><li><p><strong>轻量级锁</strong></p><p>轻量级锁是JDK6时加入的新型锁机制，它名字中的“轻量级”是相对于操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。不过需要强调的是，轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>要理解轻量级锁以及偏向锁的原理和运作过程，就必须要对HotSpot虚拟机对象的内存布局（尤其是对象头部分）有所了解。HotSpot虚拟机的对象头分为两部分，第一部分是用于存储对象自身的运行时数据的，如哈希码、GC分代年龄等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称为”Mark Word“。这部分是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象数据类型的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。</p><p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间。对象除了未被锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记、可偏向等几种不同的状态。</p><ul><li><p><strong>轻量级锁的工作过程</strong></p><p>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为01状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝。</p><p>然后虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向锁记录的指针，如果这个更新操作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位将转变为”00“，表示此对象处于轻量级锁定状态。</p><p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程以及拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态变为”10”，此时Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也必须进入阻塞状态。</p></li><li><p><strong>轻量级锁的解锁过程</strong></p><p>它的解锁操作也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程复制的Mark Word替换回来。假如能够替换成功，那整个同步过程就顺利完成了，如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时唤醒被挂起的线程。</p></li></ul><p>轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的“这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销，但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p></li><li><p><strong>偏向锁</strong></p><p>偏向锁也是JDK6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都去掉，连CAS操作都不去做了。</p><p>偏向锁的意思就是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>假设当前虚拟机启用了偏向锁（启用参数<code>-XX:UseBiasedLocking</code>，这是自JDK6起HotSpot虚拟机的默认值），那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为”01“，把偏向模式设置为”1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</p><p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式马上就宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁那样去执行。</p><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的，有时使用参数<code>-XX:UseBiasedLocking</code>来禁止偏向锁优化反而能提升性能。</p></li><li><p><strong>锁优化问题总结</strong></p><ul><li><p><strong>锁优化</strong></p><p>JDK1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，在JDK1.6中，锁一共有4个状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，如果偏向锁升级成轻量级锁后就不能降级成偏向锁，这种只能升级不能降级的锁策略是为了提高获得锁和释放锁的效率。</p></li><li><p><strong>偏向锁的获得原理</strong></p><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步代码块并获取锁时，会在对象头和帧栈中的锁记录里存储锁偏向的线程ID，以后该线程再进入和退出同步代码块不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头（synchronized用的锁存在Java的对象头里）的Mark Word里是否存储着指向当前线程的偏向锁。</p><p>如果测试成功表示线程已经获得了锁，如果测试失败则需要再测试一下Mark Word（主要存储锁状态、对象的hashCode、对象的分代年龄、是否是偏向锁、锁标志位）中偏向锁的标识是否设置成了1（表示当前是偏向锁），如果设置了就尝试使用CAS将对象头的偏向锁指向当前线程，否则使用CAS竞争锁。 </p></li><li><p><strong>偏向锁的撤销原理</strong></p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（该时间点上没有正在执行的字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态则将对象头设为无锁状态；如果线程还活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 </p></li><li><p><strong>偏向锁的打开和关闭</strong></p><p>偏向锁在Java6和Java7中默认是开启的，但是它在应用程序启动几秒后才激活，如果有必要可以使用JVM参数来关闭延迟：-XX：BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况处于竞争状态，可以通过JVM参数来关闭偏向锁：-XX：UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p></li><li><p><strong>轻量级锁的加锁原理</strong></p><p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果成功那么当前线程获得锁，如果失败表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 </p></li><li><p><strong>轻量级锁的解锁原理</strong></p><p>轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功则表示没有竞争发生。如果失败则表示当前存在锁竞争，锁就会膨胀为重量级锁。</p><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞了），一旦锁升级为重量级锁，就不会再恢复到轻量级锁的状态。在这种情况下，其他线程视图获取锁时都会被阻塞，当持有锁的线程释放锁后才会唤醒这些线程，被唤醒的线程就会对锁资源进行新一轮的争夺。</p></li><li><p><strong>偏向锁、轻量级锁和重量级锁的区别</strong></p><p>①偏向锁的优点是加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距，缺点是如果线程间存在锁竞争会带来额外锁撤销的消耗，适用于只有一个线程访问同步代码块的场景。</p><p>②轻量级锁的优点是竞争的线程不会阻塞，提高了程序的响应速度，缺点是如果线程始终得不到锁会自旋消耗CPU，适用于追求响应时间和同步代码块执行非常快的场景。</p><p>③重量级锁的优点是线程竞争不使用自旋不会消耗CPU，缺点是线程会被阻塞，响应时间很慢，适应于追求吞吐量，同步代码块执行较慢的场景。</p></li></ul></li></ul><hr><h3 id="AQS相关问题"><a href="#AQS相关问题" class="headerlink" title="AQS相关问题"></a>AQS相关问题</h3><ul><li><p><strong>概念</strong></p><p>AQS是抽象队列同步器Abstract Queued Synchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者期望它成为实现大部分同步需求的基础。</p></li><li><p><strong>AQS的主要实现方式</strong></p><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState、setState和compareAndSetState）来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型地同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLacth等）。</p></li><li><p><strong>基于AQS实现的同步器有什么共同点</strong></p><p>①至少有一个acquire操作，这个操作阻塞调用线程，直到AQS的状态允许这个线程继续执行。FutureTask中的acquire操作为get方法调用。②至少有一个release操作，这个操作改变AQS的状态，改变后的状态可允许一个多多个阻塞线程解除阻塞。FutureTask中的release操作包括run方法和cancel方法。</p></li><li><p><strong>同步器和锁的联系</strong></p><p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面对的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所关注的领域。</p></li><li><p><strong>AQS的实现包括哪些方面</strong></p><p>队列同步器的从实现角度分为多方面，主要包括同步队列、独占式同步状态的获取与释放、共享式同步状态的获取与释放，以及超时获取同步状态等同步器的核心数据与模板方法。</p></li><li><p><strong>同步队列的原理</strong></p><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等构造成一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p></li><li><p><strong>同步队列的节点保存哪些信息</strong></p><p>同步队列中的节点用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。</p></li><li><p><strong>同步队列节点的等待状态有哪些类型</strong></p><p>①CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断需要从同步队列中取消等待，节点进入该状态将不会变化。②SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行。③CONDITION，值为-2，节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal方法后该节点将会从等待队列转移到同步队列中，加入到对同步状态的获取中。④PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件地被传播下去。⑤INITIAL，值为0，初始状态。</p></li><li><p><strong>独占式同步状态的获取和释放流程</strong></p><p>在获取同步状态时，同步器调用acquire方法，维护一个同步队列，使用tryAcquire方法安全地获取线程同步状态，获取状态失败的线程会构造同步节点并通过addWaiter方法被加入到同步队列的尾部，并在队列中进行自旋。之后会调用acquireQueued方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞节点被中断实现，移出队列或停止自旋的条件是前驱节点是头结点并且成功获取了同步状态。</p><p>在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后调用unparkSuccessor方法（该方法使用LockSupport唤醒处于等待状态的线程）唤醒头节点的后继节点，进而使后继节点重新尝试获取同步状态。</p></li><li><p><strong>为什么只有当前驱节点是头节点时才能够尝试获取同步状态</strong></p><p>头节点是成功获取到同步状态的节点，而头节点的线程释放同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</p><p>维护同步队列的FIFO原则，节点和节点在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节点，这样就使得节点的释放规则符合FIFO，并且也便于对过早通知的处理（过早通知是指前驱节点不是头结点的线程由于中断而被唤醒）。</p></li><li><p><strong>共享式同步状态的获取和释放流程</strong></p><p>在获取同步状态时，同步器调用acquireShared方法，该方法调用tryAcquireShared方法尝试获取同步状态，返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此在共享式获取锁的自旋过程中，成功获取到同步状态并退出自旋的条件就是该方法的返回值大于等于0。</p><p>释放同步状态时，调用releaseShared方法，释放同步状态之后将会唤醒后续处于等待状态的节点。对于能够支持多线程同时访问的并发组件，它和独占式的主要区别在于tryReleaseShared方法必须确保同步状态（或资源数）线程安全释放，一般通过循环和CAS来保证，因为释放同步状态的操作会同时来自多个线程。</p></li><li><p><strong>独占式超时获取同步状态的流程</strong></p><p>通过调用同步器的doAcquireNanos方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则返回false。该方法提供了传统Java同步操作（例如synchronized关键字）所不具备的特性。</p></li><li><p><strong>响应中断的同步状态获取过程</strong></p><p>在JDK1.5之前当一个线程获取不到锁而被阻塞到synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧阻塞在synchronized上等待着获取锁。在JDK1.5中，同步器提供了acquireInterruptibly方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立即返回并抛出InterruptedException。</p></li><li><p><strong>独占式超时获取同步状态的原理</strong></p><p>超时获取同步状态的过程可以被视为响应中断获取同步状态过程的“增强版”，doAcquireNanos方法在支持响应中断的基础上增加了超时获取的特性，针对超时获取，主要需要计算出需要睡眠的时间间隔nanosTimeout，为了防止过早通知，nanosTimeout的计算公式为nanosTimeout-=now-lastTime，其中now为当前唤醒时间，lastTime为上次唤醒时间，如果nanosTimeout大于0则表示超时时间未到，需要继续睡眠nanosTimeout纳秒，否则表示已经超时。</p></li><li><p><strong>独占式超时获取同步状态和独占式获取同步状态的区别</strong></p><p>在独占式超时获取同步状态的过程的doAcquireNanos中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。</p><p>如果当前线程获取同步状态失败，独占式超时获取同步状态中会判断是否超时，如果没有超时就重新计算超时间隔，然后使当前线程等待该间隔时间，如果在该时间内没有获取到同步状态就会从等待逻辑中自动返回。而独占式获取同步状态的过程中如果没有获取到同步状态就会使当前线程一直处于等待状态。</p></li><li><p><strong>超时时间过小时对超时等待的影响</strong></p><p>nanosTimeout过小时（小于等于1000纳秒），将不会使线程进行超时等待，而是进入快速自旋过程。因为非常短的超市等待无法做到精确，如果这时再进行超时等待相反会让nanosTimeout的超时从整体上表现得反而不精确，因此在超市非常短的情况下同步器会进入无条件的快速自旋。</p></li></ul><hr><h3 id="Lock相关问题"><a href="#Lock相关问题" class="headerlink" title="Lock相关问题"></a>Lock相关问题</h3><ul><li><p><strong>可重入锁</strong></p><p>重入锁就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁，除此之外该锁还支持获取锁的公平和非公平性选择。synchronized关键字隐式地支持重进入，ReentrantLock虽然不能像synchronized关键字一样支持隐式的重进入，但是在调用lock方法时已经获取到锁的线程能够再次调用lock方法获取锁而不被阻塞。</p></li><li><p><strong>锁的公平性</strong></p><p>如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反正就是不公平的。公平的获取锁也就是等待时间最长的线程优先获取锁，也可以说锁的获取是顺序的，ReentrantLock的构造方法中可以通过设置参数控制锁的公平性。</p><p>公平锁机制往往没有非公平锁的效率高，非公平锁地吞吐量更大，但是公平锁能够减少饥饿发生的概率，保证了锁地获取按照FIFO顺序，等待越久的请求越是能优先得到满足。</p></li><li><p><strong>重进入</strong></p><p>重进入指的是任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决两个问题：①线程再次获取锁，锁需要去识别获取锁的线程是否为当前占有锁的线程，如果是则再次获取成功。②锁的最终释放，线程重复n次获取了锁，随后在第n次释放该锁后，其他现场能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而被锁释放时，技术自减，当计数为0时表示锁已经成功释放。</p></li><li><p><strong>ReentrantLock的可重入的实现</strong></p><p>以非公平锁为例，通过nonfairTryAcquire方法获取锁，该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求则将同步状态值进行增加并返回true，表示获取同步状态成功。</p><p>成功获取锁的线程再次获取锁，只是增加了同步状态值，这就要求ReentrantLock在释放同步状态时减少同步状态值。如果该锁被获取了n次，那么前（n-1）次tryRelease方法必须都返回fasle，只有同步状态完全释放了才能返回true，可以看到该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p><p>对于非公平锁只要CAS设置同步状态成功则表示当前线程获取了锁，而公平锁则不同。公平锁使用tryAcquire方法，该方法与nonfairTryAcquire的唯一区别就是判断条件中多了对同步队列中当前节点是否有前驱节点的判断，如果该方法返回true表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。 </p></li><li><p><strong>读写锁</strong></p><p>像Mutex和ReentrantLock都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读写锁使得并发性相比一般的排他锁有了很大提升。</p></li><li><p><strong>读写锁的特点</strong></p><p>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。只需要在读操作时获取读锁，写操作时获取写锁即可，当写锁被获取时后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后所有操作继续执行，编程方式相对于使用等待/通知机制的实现方式而言变得简单明了。</p></li><li><p><strong>读写锁ReentrantReadWriteLock的特性</strong></p><ul><li>公平性选择：支持非公平（默认）和公平的锁获取方式吞吐量还是非公平性优于公平。</li><li>重进入：该锁支持重进入，以读写线程为例：读线程在获取了读锁之后能够再次获得读锁。而写线程在获取了写锁之后能再次获得写锁，同时也可以获取读锁。</li><li>锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁。</li></ul></li><li><p><strong>读写锁的状态的设计</strong></p><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整形变量）上维护多个读线程和一个写线程的状态。如果在一个int型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p><p>假设同步状态值为S，写状态等于S&amp;0x0000FFFF（将高17位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号右移16位），当写状态增加1时，等于S+1，当读状态增加1时，等于S+（1&lt;&lt;16）。根据状态的划分能得出一个推论：S不等于0时，当写状态等于0时，则读状态大于0，即读锁已被获取。</p></li><li><p><strong>写锁的获取和释放过程</strong></p><p>写锁是一个支持重进入的排他锁，如果当前线程已经获得了写锁则增加写状态，如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获得写锁的线程则当前线程进入等待状态。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p></li><li><p><strong>为什么存在读锁时写锁会阻塞</strong></p><p>读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取则其他读写线程的后续访问均被阻塞。</p></li><li><p><strong>读锁的获取和释放过程</strong></p><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写线程为0）时，读锁总会被成功地获取，而所做的只是线程安全地增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取则进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p><p>读锁的每次释放均会减少读状态，减少的值是（1&lt;&lt;16），读锁的每次释放是线程安全的，可能有多个读线程同时释放读锁。</p></li><li><p><strong>JDK1.6对读锁的改动</strong></p><p>获取读锁的实现从JDK1.5到JDK1.6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。</p></li><li><p><strong>锁降级</strong></p><p>锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级指的是把持住（当前拥有的）写锁，再获取到读锁，随后释放先前拥有的写锁的过程。</p></li><li><p><strong>锁降级中读锁的获取是否有必要</strong></p><p>是必要的，主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程A获取了写锁修改了数据，那么当前线程是无法感知线程A的数据更新的。如果当前线程获取读锁，即遵循锁降级的步骤，线程A将会被阻塞，直到当前线程使用数据并释放读锁之后，线程A才能获取写锁并进行数据更新。</p></li></ul><hr><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><ul><li><p><strong>Condition的作用</strong></p><p>Condition接口提供了类似Object监视器方法，与Lock配合可以实现等待/通知模式。Condition对象是由Lock对象创建出来的，因此Condition是依赖Lock对象的。一般会将Condition对象作为成员变量，当调用await方法后当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal方法，通知当前线程后，当前线程才从await方法返回并且在返回前已经获取了锁。</p></li><li><p><strong>Condition的实现</strong></p><p>ConditionObject是同步器AQS的内部类，因为Condition的操作需要获取相关的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个等待队列，该等待队列是Condition对象实现等待/通知功能的关键。Condition的实现主要包括了等待队列、等待和通知。</p></li><li><p><strong>等待队列的原理</strong></p><p>等待队列是一个FIFO队列，在队列中的每个节点都包含了一个线程引用，该线程就是在ConditionObject对象上等待的线程，如果一个线程调用了await方法，那么该线程会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步其中节点的定义，也就是说同步队列和等待队列中的节点类型都是同步器的静态内部类Node。</p><p>一个ConditionObject包含一个等待队列，ConditionObject拥有首节点和尾节点。Object拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。节点引用更新的过程并没有用CAS保证，因为调用await方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p></li><li><p><strong>await方法的原理</strong></p><p>如果从队列的角度看await方法，当调用await方法时相当于同步队列的首节点（获取了锁的节点）移动到Condition对象的等待队列中，首节点不会直接加入等待队列，而是通过addConditionWaiter方法把当前线程构造成一个新的节点并将其加入等待队列中。加入等待队列后，释放同步状态，唤醒同步队列中的后继节点然后进入等待状态。如果不是通过其他线程调用signal方法唤醒而是对await线程进行中断，会抛出InterruptedException。</p></li><li><p><strong>signal方法的原理</strong></p><p>该方法会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。调用该方法的前置条件是当前线程必须获取了锁，signal方法进行了检查，判断当前线程是否是获取了锁的线程，接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。被唤醒后的线程将从await方法中的while循环退出，进而调用同步器的acquireQueued方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）后，被唤醒的线程将从先前调用的await方法返回，此时该线程已成功获取了锁。signalAll方法相当于对等待队列中的每个节点执行一次signal方法，效果就是将等待队列中的节点全部移到到同步队列中并唤醒每个节点的线程。</p></li><li><p><strong>阻塞队列</strong></p><p>阻塞队列是一个支持两个附加操作的队列，这两个附加的操作支持阻塞的插入和移除方法。当队列满时，队列会阻塞插入元素的线程，直到队列不满。当队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者向队列里添加元素，消费者从队列中获取元素，阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p><ul><li><p><strong>Java中的阻塞队列</strong></p><ul><li><p>ArrayBlockingQueue，一个由数组结构组成的有界阻塞队列，按照FIFO的原则对元素排序，默认情况下不保证线程公平地访问队列，有可能先阻塞地线程最后才访问队列。</p></li><li><p>LinkedBlockingQueue，一个由链表结构组成的有界阻塞队列，队列的默认和最大长度为Integer的最大值，按照FIFO原则排序。</p></li><li><p>PriorityBlockingQueue，一个支持优先级排序的无界阻塞队列，默认情况下元素按照顺序升序排序。也可以自定义compareTo方法指定元素排序规则，或者初始化时指定构造方法的参数Comparator对元素排序，不能保证同优先级元素的顺序。</p></li><li><p>DelayQueue，一个支持延时获取元素的无界阻塞队列，使用优先级队列实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有延时期满时才能从队列中获取元素。适用于以下场景：①缓存系统的设计，一旦能从延迟队列获取元素说明缓存有效期到了。②定时任务调度，保存当天将要执行的任务和执行时间，一旦获取到任务就立刻开始执行。</p></li><li><p>SynchronousQueue，一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素。默认使用非公平策略，也支持公平策略，适用于传递性场景，吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p></li><li><p>LinkedTransferQueue，一个由链表结构组成的无界阻塞队列，相对于其他阻塞队列多了tryTransfer和transfer方法。transfe方法：如果当前有消费者正在等待接收元素，transfer方法可以把生产者传入的元素立刻传输给消费者，如果没有，会将元素放在队列的尾节点等到该元素被消费者消费了才返回。tryTransfer方法：用来试探生产者传入的元素能否直接传给消费者，如果没有消费者等待接收元素返回false，和transfer的区别时无论消费者是否接受都会立即返回，transfer是等到消费者消费了才返回。</p></li><li><p>LinkedBlockingDeque，一个由链表结构组成的双向阻塞队列，可以从队列的两端插入和移除元素，多了一个操作队列的入口，在多线程同时入队时就少了一半竞争。</p></li></ul></li><li><p><strong>阻塞队列的实现原理</strong></p><p>使用通知模式实现，所谓通知模式就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。JDK中使用了Condition条件对象来实现。当往队列里插入一个元素，如果队列不可用，那么阻塞生产者主要通过LockSupport.park(this)实现。</p></li></ul></li></ul><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h3><ol><li>什么是Fork/Join</li></ol><p><img src="/.io//1.png" alt="Fork/Join"></p><ol start="2"><li>Fork/Join的运行流程</li></ol><p><img src="/.io//2.png" alt="Fork/Join的运行流程图"></p><p><img src="/.io//3.png" alt="伪代码"></p><ol start="3"><li>工作窃取算法</li></ol><p>工作窃取算法指的是在多线程执行不同任务队列的过程，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。</p><p>工作窃取流程如下图所示：</p><p><img src="/.io//4.png" alt="工作窃取流程"></p><p>值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间竞争，我们通常使用<strong>双端队列</strong>来存储任务。被窃取的任务线程都从双端队列的头部拿任务执行，而窃取其他任务的线程从双端队列的尾部执行任务。</p><p>另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入阻塞状态以等待再次工作。</p><ol start="4"><li>Fork/Join的具体实现</li></ol><p>前面我们说Fork/Join框架简单来讲就是对任务的分割与子任务的合并，所以要实现这个框架，先要有任务。在Fork/Join框架里提供了抽象类ForkJoinTask来实现任务。</p><p>ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量的多。</p><p><strong>fork()方法：</strong>使用线程池中的空闲线程异步提交任务</p><p><img src="/.io//5.png" alt="fork()方法"></p><p>其实fork()只做了一件事，那就是把任务推入当前工作线程的工作队列里。</p><p><strong>join()方法：</strong>等待处理任务的线程处理完毕，获取返回值。</p><p><img src="/.io//6.png" alt="join()方法"></p><p><img src="/.io//7.png" alt="doJoin()方法"></p><blockquote><p>Thread.join()会使线程阻塞，而ForkJoinPool.join()会使线程免于阻塞，下面是ForkJoinPool.join()的流程图</p></blockquote><img src="/.io//8.png" alt="image-20210330220126169" style="zoom:125%;"><p>4.1. RecursiveAction和 RecursiveTask</p><p>通常情况下，在创建任务时我们一般不直接继承ForkJoinTask，而是继承它的继承类RecursiveAction和RecursiveTask。</p><blockquote><p>RecursiveAcion:无返回值</p><p>RecursiveTask:有返回值</p></blockquote><p>两个子类都有执行主要计算的方法Compute()</p><p>4.2. ForkJoinPool</p><p>ForkJoinPool是用于ForkJoinTask任务执行的线程池。ForkJoinPool管理着执行池中的线程和任务队列，此外，执行池是否还接受任务，显示线程的运行状态也是在这里处理。</p><p><img src="/.io//9.png" alt="ForkJoinPool"></p><p>4.3. WorkQueue</p><p>双端队列，ForkJoinTask存放在这里。</p><p>ForkJoinPool与传统线程池最显著的区别就是它维护了一个工作队列数组（volatile WorkQueue[] workQueues，ForkJoinPool中每个工作线程都维护着一个工作队列）。</p><p>4.4. runState</p><p>ForkJoinPool的运行状态。SHUTDOWN状态用负数表示，其他的用2次幂表示。</p><hr><h3 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h3><ul><li><p><strong>CountDownLatch</strong></p><p>允许一个或多个线程等待其他线程完成操作，构造方法接收一个int类型的参数作为计数器，如果要等待n个点就传入n。每次调用countDown方法时n就会减1，await方法会阻塞当前线程直到n变为0，由于countDown方法可用在任何地方，所以n个点既可以是n个线程也可以是1个线程里的n个执行步骤。用在多线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p></li><li><p><strong>CyclicBarrier</strong></p><p>CyclicBarrier是同步屏障，它的作用是让一组线程到达一个屏障（或同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被拦截的线程才会继续运行。构造方法中的参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier自己已到达屏障，然后当前线程被阻塞。还支持在构造方法中传入一个Runable类型的任务，当线程到达屏障时会优先执行该任务。适用于多线程计算数据，最后合并计算结果的应用场景。</p><ul><li><p><strong>CountDownLacth和CyclicBarrier的区别</strong></p><p>CountDownLacth的计数器只能用一次，而CyclicBarrier的计数器可使用reset方法重置，所以CyclicBarrier能处理更为复杂的业务场景，例如计算错误时可用重置计数器重新计算。CyclicBarrier还提供了其他有用的方法，例如getNumberWaiting可以获取CyclicBarrier阻塞的线程数量，isBroken方法用来了解阻塞的线程是否被中断。</p></li></ul></li><li><p><strong>Semaphore</strong></p><p>Semaphore是信号量，用来控制同时访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。信号量可以用于流量控制，特别是公共资源有限的应用场景，比如数据库连接。Semaphore的构造方法参数接收一个int型数字，表示可用的许可证数量，即最大并发数。使用acquire获得一个许可证，使用release方法归还许可证，还可以用tryAcquire尝试获得许可证。</p></li><li><p><strong>Exchanger</strong></p><p>Exchanger交换者是用于线程间协作的工具类，用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时这两个线程就可以交换数据，将本线程生产出的数据传递给对方。应用场景包括遗传算法、校对工作等。</p></li></ul><hr><h2 id="线程池和Executor框架"><a href="#线程池和Executor框架" class="headerlink" title="线程池和Executor框架"></a>线程池和Executor框架</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p><strong>线程池的好处</strong></p><ul><li>降低资源消耗，通过重复利用已创建的线程降低线程创建和消耗的开销。</li><li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就可以立即执行。</li><li>提高线程的可管理性，线程是稀缺资源，如果无限制地创建不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ul></li><li><p><strong>线程池的工作流程</strong></p><ul><li>线程池判断核心线程池是否已满，如果不是则创建一个新的工作线程来执行任务（工作线程数&lt;corePoolSize，这一步需要获取全局锁）。</li><li>如何核心线程池已经满了，判断工作队列是否已满，如果没有就将任务存储在工作队列中（工作线程数&gt;=corePoolSize）。</li><li>如果工作队列满了，判断线程池是否已满，如果没有就还是创建一个新的工作线程来执行任务（工作线程数&lt;maximumPoolSize）。</li><li>如果线程池已满，就按照线程池的拒绝执行策略来处理无法执行的任务（工作线程数&gt;maximumPoolSize）。</li></ul><p>线程池采取这种设计思路是为了在执行execute方法时尽可能地避免获取全局锁，在线程池完成预热之后，即当前工作线程数&gt;=corePoolSzie时，几乎所有的execute方法都是执行步骤2，不需要获取全局锁。</p></li><li><p><strong>工作线程的任务</strong></p><p>线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务之后，还会循环获取工作队列中的任务来执行。线程池中的线程执行任务分为两种情况：①在execute方法中创建一个线程时会让这个线程执行当前任务。②这个线程执行完任务之后，就会反复从阻塞工作队列中获取任务并执行。</p></li><li><p><strong>ThreadPoolExecutor创建参数</strong></p><ul><li>corePoolSize：线程池的基本大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池的基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有的基本线程。</li><li>workQueue：工作队列，用于保存等待执行任务的阻塞队列，可以选择以下的阻塞队列：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockQueue等。</li><li>maximumPoolSize：线程池允许的最大线程数，如果工作队列已满，并且创建的线程数小于最大线程数，则线程池还会创建新的线程执行任务，如果使用的时无界阻塞队列该参数是无意义的。</li><li>threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li><li>handler：拒绝策略，当队列和线程池都满了说明线程池处于饱和状态，那么必须采取一种拒绝策略处理新提交的任务，默认情况下使用AbortPolicy直接抛出异常，CallerRunsPolicy表示重新尝试提交该任务，DiscardOldestPolicy表示抛弃队列里最近的一个任务并执行当前任务，DiscardPolicy表示直接抛弃当前任务不处理。也可以自定义该策略。</li><li>keepAliveTime：线程活动的保持时间，线程池工作线程空闲后保持存活的时间，所以如果任务很多，且每个任务的执行时间较短，可以调大时间提高线程的利用率。</li><li>unit：线程活动保持时间的单位，有天、小时、分钟、毫秒、微秒、纳秒。</li></ul></li><li><p><strong>如何像线程池提交任务</strong></p><p>可以使用execute和submit方法向线程池提交任务。execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功了。submit方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过该对象可以判断任务是否执行成功，并且可以通过该对象的get方法获取返回值，get方法会阻塞当前线程直到任务完成，带超时参数的get方法会在指定时间内返回，这时任务可能还没有完成。</p></li><li><p><strong>关闭线程池的原理</strong></p><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。区别是shutdownNow首先将线程池的状态设为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设为SHUTDOWN，然后中断所有没有正在执行任务的线程。</p><p>只要调用了这两个方法中的一个，isShutdown方法就会返回true，当所有任务都已关闭后才表示线程池关闭成功，这时调用isTerminated方法会返回true。通常调用shutdown方法来关闭线程池，如果任务不一定要执行完则可以调用shutdownNow方法。</p></li><li><p><strong>合理设置线程池</strong></p><p>首先可以从以下角度分析：①任务的性质：CPU密集型任务、IO密集型任务和混合型任务。②任务的优先级：高、中和低。③任务的执行时间：长、中和短。④任务的依赖性：是否以来其他系统资源，如数据库连接。</p><p>性质不同的任务可以用不同规模的线程池分开处理，CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型任务如果可以拆分将其拆分为一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大那么分解后的吞吐量将高于串行执行的吞吐量，如果相差太大则没必要分解。</p><p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue处理。</p><p>执行时间不同的任务可以交给不同规模的线程池处理，或者使用优先级队列。</p><p>以来数据库连接池的任务，由于线程提交SQL后需要等待数据库返回的结果，等待的时间越长CPU空闲的时间就越长，因此线程数应该尽可能地设置大一些提高CPU的利用率。</p><p>建议使用有界队列，能增加系统的稳定性和预警能力，可以根据需要设置的稍微大一些。</p></li><li><p>线程池的监控</p><ul><li>taskCount，线程池需要执行的任务数量。</li><li>completedTaskCount，线程池在运行过程中已经完成的任务数量，小于或等于taskCount。</li><li>largestPoolSize，线程池里曾经创建过的最大线程数量，通过这个数据可以知道线程池是否曾经满过，如果该数值等于线程池的最大大小表示线程池曾经满过。</li><li>getPoolSize，获取线程池的线程数量，如果线程池不销毁的化线程池里的线程不会自动销毁，所以这个数值只增不减。</li><li>getActiveCount，获取活动的线程数。</li></ul><p>通过扩展线程池进行监控，可以继承线程池来自定义，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前来执行一些代码进行监控，例如监控任务的平均执行时间、最大执行时间和最小执行时间。</p></li><li><p><strong>使用无界阻塞队列对线程池的影响</strong></p><p>①当线程池中的线程数达到corePoolSize之后新任务将在无界队列中等待，因此线程池中的数量不会超过corePoolSize。②因此使用无界队列时maximumPoolSize和keepAliveTime均是无效参数。③由于使用无界队列，线程池不会拒绝任务。</p></li></ul><hr><h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><ul><li><p><strong>Executor框架的调度模型</strong></p><p>在HotSpot VM的线程模型中，Java线程被一对一映射为本地操作系统线程，Java线程启动时会创建一个本地操作系统线程，当该Java线程终止时，这个操作系统线程也会被回收，操作系统会调度所有线程并将它们分配给可用的CPU。</p><p>Executor框架的调度模型是一种两级调度模型。在上层，Java多线程程序通常把应用分解为若干任务，然后使用用户级的调度器即Executor框架将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p></li><li><p><strong>Executor框架的结构</strong></p><p>主要由以下三部分组成：</p><p>①任务，包括被执行任务需要实现的接口，Runnable或Callable接口。</p><p>②任务的执行，包括任务执行机制的核心接口Executor（Executor框架的基础，将任务的提交和执行分离开来），以及继承自Executor的ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）。</p><p>③异步计算的结果，包括接口Future和实现Future接口的FutureTask类。当我们把Runnable接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。</p></li><li><p><strong>ThreadPoolExecutor</strong></p><p>ThreadPoolExecutor是Executor框架最核心的类，是线程池的实现类，主要有三种。</p><p>①FixedThreadPool，可重用固定线程数的线程池，corePoolSize和maximumPoolSize都被设置为创建时的指定参数nThreads，当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止，这里将其设置为0L表示多余空闲线程将被立即终止。该线程池使用的工作队列是无界阻塞队列LinkedBlockingQueue（队列容量为Integer的最大值）。适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，适用于负载比较重的服务器。</p><p>②SingleThreadExecutor，使用单个线程的线程池，corePoolSize和maximumPoolSize都被设置为1，其他参数和FiexedThreadPool相同。适用于需要保证顺序执行各个任务，并且在任意时间点不会有多个线程是活动的的应用场景。</p><p>③CachedThreadPool，一个根据需要创建线程的线程池，corePoolSize被设置为0，maximumPoolSize被设置为Integer的最大值，将keepAliveTime设为60L，意味着空闲线程等待时间最长为1分钟。该线程池使用的工作队列是没有容量的SynchronousQueue，但是maximumPoolSize设为Integer最大值，如果主线程提交任务的速度高于线程处理的速度，线程池会不断创建新线程，极端情况下会创建过多线程而耗尽CPU和内存资源。适用于执行很多短期异步任务的小程序，或者负载较轻的服务器。</p></li><li><p><strong>ScheduledThreadPoolExecutor</strong></p><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，主要用来在给定的延迟之后运行任务，或者定期执行任务。其功能与Timer类似，但是功能更加强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造方法中指定多个后台线程数。为了实现周期性的执行任务，使用DelayQueue作为工作队列，获取任务和执行周期任务后的处理都不同，主要有两种。</p><p>①ScheduledThreadPool：包含若干线程的ScheduledThreadPoolExecutor，创建固定线程个数的线程池。适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程数量的应用场景。</p><p>②SingleThreadScheduledExecutor：只包含一个线程的ScheduledThreadPoolExecutor，适用于单个后台线程执行周期任务，同时需要保证顺序执行各个任务的应用场景。</p><ul><li><p><strong>ScheduledThreadPoolExecutor的原理</strong></p><p>将待调度任务放入一个DelayQueue中，调度任务主要有三个参数，long类型的time表示这个任务将要被执行的具体时间，long类型的sequenceNumber表示这个任务被添加到线程池的序号，long类型的period表示任务执行时间间隔。DelayQueue封装了一个PriorityQueue，队列按照time进行排序，如果time相同则比较sequenceNumber，越小的排在前面，即如果两个任务的执行时间相同，先提交的任务先被执行。</p></li></ul></li><li><p><strong>Runnable接口和Callable接口的区别</strong></p><p>两个接口的相同点是Runnable接口和Callable接口的实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行，不同点是Runnable不会返回结果，Callable可以返回结构。除了可以自己创建Callable接口的对象外，还可以使用工厂类Executors将一个Runnable对象包装为一个Callable对象。</p></li><li><p><strong>FutureTask</strong></p><p>FutureTask除了实现了Future接口之外，还实现了Runnable接口。因此FutureTask可以交给Executor执行，也可以由调用线程直接执行即调用FutureTask对象的run方法，根据run方法被执行的时机，FutureTask可以处于三种状态：①未启动，当FutureTask对象被创建，且没有执行run方法之前的状态。②已启动，当run方法处于被执行过程中，FutureTask对象处于已启动状态。③已完成，当run方法执行后正常完成或执行run方法中抛出异常或调用cancel方法取消时，FutureTask对象处于已完成状态。</p><p>当处于未启动或已启动状态时，get方法将阻塞线程，当处于已完成状态时会立即返回结果或抛出异常。当处于未启动状态时，cancel方法会导致此任务永远不会执行，当处于已启动状态时，执行cancel(true)方法，将以中断执行此任务的方式来试图停止该任务，执行cancel(false)方法，将不会对正在执行此任务的线程产生应用，当处于已完成状态时，cancel方法返回false。</p><ul><li><p><strong>FutureTask的实现原理</strong></p><p>FutureTask的实现基于AQS，基于合成复用的设计原则，FutureTask声明了一个内部私有的继承于AQS的子类Sync，对Future的所有公有方法的调用都会委托给这个内部的子类。AQS被作为模板方法模式的基础类提供给FutureTask的内部子类Sync，这个内部的子类只需要实现状态检查和更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared和tryReleaseShared方法来检查和更新同步状态。</p></li><li><p><strong>FutureTask的get方法原理</strong></p><p>①调用AQS的acquireSharedInterruptibly方法，首先回调在子类Sync中实现的tryAcquireShared方法来判断acquire操作是否可以成功。acquire操作成功的条件为：state为执行完成状态或取消状态，且runner不为null。②如果成功get方法立即返回，如果失败则到线程等待队列中去等待其他线程执行release操作。③当其他线程执行release操作唤醒当前线程后，当前线程再次执行tryAcquireShared将返回1，当前线程将理课线程等待队列并唤醒它的后继线程。④返回最终结果或抛出异常。</p></li><li><p><strong>FutureTask的run方法原理</strong></p><p>①执行在构造方法中的指定任务。②以原子方式更新同步状态，如果操作成功就设置代表计算结果的变量result的值为Callable的call方法的返回值，然后调用AQS的releaseShared方法。③AQS的releaseShared方法首先回调子类Sync中实现的tryReleaseShared来执行release操作（设置运行任务的线程runner为null，然后返回true），然后唤醒线程等待队列的第一个线程。④调用FutureTask的done方法。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JMM </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud概述</title>
      <link href="2021/05/23/springcloud-gai-shu/"/>
      <url>2021/05/23/springcloud-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringCloud概述"><a href="#SpringCloud概述" class="headerlink" title="SpringCloud概述"></a>SpringCloud概述</h2><h3 id="1-微服务技术栈"><a href="#1-微服务技术栈" class="headerlink" title="1.微服务技术栈"></a>1.微服务技术栈</h3><table><thead><tr><th>微服务条目</th><th>落地技术</th></tr></thead><tbody><tr><td>服务开发</td><td>SpringBoot,Spring,SpringMV</td></tr><tr><td>服务配置与管理</td><td>NetFlix公司的Archaius、阿里的Diamond</td></tr><tr><td>服务注册与发现</td><td>Eureka、Consul、Zookeeper</td></tr><tr><td>服务调用</td><td>Rest、RPC、gRPC</td></tr><tr><td>服务熔断器</td><td>Hystrix、Envoy等</td></tr><tr><td>负载均衡</td><td>Ribbon、Nginx等</td></tr><tr><td>服务接口调用（客户端调用服务的简化工具）</td><td>Feign等</td></tr><tr><td>消息队列</td><td>Kafka、RabbitMQ、ActiveMQ</td></tr><tr><td>服务配置中心管理</td><td>SpringCloudConfig、Chef等</td></tr><tr><td>服务路由（API网关）</td><td>Zuul</td></tr><tr><td>服务监控</td><td>Zabbix、Nagios、Metrics、Specatator</td></tr><tr><td>全链路追踪</td><td>Zipkin、Brave、Dapper</td></tr><tr><td>服务部署</td><td>Docker、OpenStack、Kubernetes等</td></tr><tr><td>数据流操作开发包</td><td>SpringCloud Stream（封装与Redis，Rabbit，Kafka等发送接收消息）</td></tr><tr><td>时间消息总线</td><td>SpringCloud Bus</td></tr></tbody></table><h3 id="2-SpringCloud入门"><a href="#2-SpringCloud入门" class="headerlink" title="2.SpringCloud入门"></a>2.SpringCloud入门</h3><h4 id="2-1-什么是SpringCloud"><a href="#2-1-什么是SpringCloud" class="headerlink" title="2.1 什么是SpringCloud"></a>2.1 什么是SpringCloud</h4><blockquote><p>官方说法：<br>构建分布式系统不需要复杂和容易出错。Spring Cloud  为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。Spring Cloud 构建于  Spring Boot 之上，使得开发者很容易入手并快速应用于生产中。</p></blockquote><p>简单来说：<code>Spring Cloud</code> 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 <strong>服务发现注册</strong> 、<strong>配置中心</strong> 、<strong>消息总线</strong> 、<strong>负载均衡</strong> 、<strong>断路器</strong> 、<strong>数据监控</strong> 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p><h4 id="2-2-SpringCloud的版本"><a href="#2-2-SpringCloud的版本" class="headerlink" title="2.2 SpringCloud的版本"></a>2.2 SpringCloud的版本</h4><p><code>Spring Cloud</code> 的版本号并不是我们通常见的数字版本号，而是一些很奇怪的单词。这些单词均为英国伦敦地铁站的站名。同时根据字母表的顺序来对应版本时间顺序，比如：最早 的 <code>Release</code> 版本 <code>Angel</code>，第二个 <code>Release</code> 版本 <code>Brixton</code>（英国地名），然后是 <code>Camden</code>、 <code>Dalston</code>、<code>Edgware</code>、<code>Finchley</code>、<code>Greenwich</code>、<code>Hoxton</code>。</p><h4 id="2-3-为什么选择SpringCloud"><a href="#2-3-为什么选择SpringCloud" class="headerlink" title="2.3 为什么选择SpringCloud"></a>2.3 为什么选择SpringCloud</h4><p><strong>选型依据</strong></p><ul><li>整体式解决方案，成熟的框架</li><li>高热度社区</li><li>可维护性强</li></ul><p><strong>大公司的微服务架构</strong></p><ul><li>阿里：dubbo + HFS</li><li>京东：JSF</li><li>新浪：Motan</li><li>当当网：DubboX</li><li>…</li></ul><p><strong>框架对比</strong></p><table><thead><tr><th>功能</th><th align="center">Netflix/SpringCloud</th><th>Motan</th><th>gRPC</th><th>Thrift</th><th>Dubbo/DubboX</th></tr></thead><tbody><tr><td>功能定位</td><td align="center">完整的微服务框架</td><td>RPC框架，但是整合了ZK或Consul，实现了集群环境的基本服务注册/发现</td><td>RPC框架</td><td>RPC框架</td><td>服务框架</td></tr><tr><td>支持Rest</td><td align="center">是，Ribbon支持多种可插拔的序列化选择</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>支持RPC</td><td align="center">否</td><td>是（Hession2）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>支持多语言</td><td align="center">是（Rest形式）</td><td>否</td><td>是</td><td>是</td><td>否</td></tr><tr><td>负载均衡</td><td align="center">是（服务端zuul+客户端Ribbon），zuul服务，动态路由，云端负载均衡Eureka（针对中间层服务器）</td><td>是（客户端）</td><td>否</td><td>否</td><td>是（客户端）</td></tr><tr><td>配置服务</td><td align="center">Netflix Archaius，SpringCloud Config Server集中配置</td><td>是（Zookeeper提供）</td><td>否</td><td>否</td><td>否</td></tr><tr><td>服务调用链监控</td><td align="center">是（zuul），zuul提供边缘服务，API网关</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>高可用/容错</td><td align="center">是（服务端Hystrix+客户端Ribbon）</td><td>是（客户端）</td><td>否</td><td>否</td><td>是（客户端）</td></tr><tr><td>典型应用案例</td><td align="center">Netflix</td><td>Sina</td><td>Google</td><td>Facebook</td><td></td></tr></tbody></table><h4 id="2-4-SpringCloud官方链接"><a href="#2-4-SpringCloud官方链接" class="headerlink" title="2.4 SpringCloud官方链接"></a>2.4 SpringCloud官方链接</h4><p><a href="https://spring.io/projects/spring-cloud/#learn">SpringCloud官方</a></p><p><a href="https://www.springcloud.cc/spring-cloud-netflix.html">SpringCloud Netflix</a></p><p><a href="https://www.springcloud.cc/spring-cloud-dalston.html">SpringCloud中文API文档</a></p><p><a href="http://www.springcloud.cn/">SpringCloud中文社区</a></p><p><a href="https://www.springcloud.cc/">SpringCloud技术栈</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统</title>
      <link href="2021/05/21/fen-bu-shi-xi-tong/"/>
      <url>2021/05/21/fen-bu-shi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h2 id="1-相关理论"><a href="#1-相关理论" class="headerlink" title="1. 相关理论"></a>1. 相关理论</h2><h3 id="A-CAP理论"><a href="#A-CAP理论" class="headerlink" title="A. CAP理论"></a>A. CAP理论</h3><blockquote><ul><li>一致性（Consistency）:所有节点访问同一份最新的数据副本</li><li>可用性（Availability）:非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）</li><li>分区容错性（网络分区）Partition tolerance:分布式系统出现网络分区的时候，仍然能够对外提供服务</li></ul></blockquote><p>​    <strong>什么是网络分区？</strong></p><blockquote><p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p></blockquote><p><img src="https://img-blog.csdn.net/20180729210031417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eGlhbnM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><code>CAP的三选二的原理:</code></p><blockquote><p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p><p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p></blockquote><blockquote><p>AP(放弃C)：放弃强一致性，用最终一致性来保证。</p><p>CP(放弃A)：一旦系统遇见故障，受到影响的服务器需要等待一段时间，在恢复期间无法对外提供服务。</p></blockquote><blockquote><p><strong>为啥无同时保证 CA 呢？</strong></p><p>举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p><p><strong>选择的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p></blockquote><p><strong>分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独 立，通过网络进行沟通和协调。XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件 用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。</strong></p><h3 id="B-2P理论-二段提交"><a href="#B-2P理论-二段提交" class="headerlink" title="B. 2P理论(二段提交)"></a>B. 2P理论(二段提交)</h3><p><strong><code>二阶段提交(Two-phase Commit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统 架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。</code></strong></p><p>二段提交（RDBMS(传统关系型数据库)经常就这种机制，<em><strong>保证强一致性</strong></em>）</p><blockquote><p>提交步骤：</p><p>阶段1：提交事务请求（投票阶段，任何一个结点失败，不能继续进行提交）</p><p><img src="https://img-blog.csdn.net/20180729211305744?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eGlhbnM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>阶段2：执行事务提交（commit、rollback。任何一个结点失败 rollback）</p><p><img src="https://img-blog.csdn.net/20180729211352487?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eGlhbnM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p></blockquote><ul><li><p>缺点：</p><blockquote><p><strong>同步阻塞问题</strong></p><p>​         1、执行过程中，所有参与节点都是事务阻塞型的</p><p>**单点故障 **</p><p>​        2、由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。</p><p>​                解决：<strong>协调者故障，通过选举得到新协调者</strong>（弊端：假如协调者和第一个参与者都挂了；<strong>每个参与者自身的状态只有自己和协调者知道</strong>，因此新协调者无法通过在场的参与者的状态推断出挂了的参与者是什么情况。）                </p><p><strong>数据不一致（脑裂问题）</strong></p><p>​         3、在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异 常或者在发送 commit 请求过程中协调者发生了故障，导致只有一部分参与者接受到了 commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。</p><p><strong>二阶段无法解决的问题（数据状态不确定）</strong></p><p>​         4、协调者再发出 commit 消息之后宕机，<code>而唯一接收到这条消息的参与者同时也宕机了</code>。那 么即使协调者通过选举协议产生了新的协调者，<code>这条事务的状态也是不确定的，没人知道 事务是否被已经提交</code>。</p></blockquote></li></ul><p><strong>解决方案：</strong></p><blockquote><p><strong>1.XA三阶段提交</strong></p><p>XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。</p><p><strong>2.MQ事务</strong></p><p>利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。</p><p><strong>3.TCC事务</strong></p><p>TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于XA两阶段提交，但是实现方式是在代码层面来人为实现。</p></blockquote><h3 id="C-3P理论-三段提交-一般不用"><a href="#C-3P理论-三段提交-一般不用" class="headerlink" title="C. 3P理论(三段提交)(一般不用)"></a>C. 3P理论(三段提交)(一般不用)</h3><p><strong>与两阶段提交不同的是，三阶段提交有两个改动点。</strong> </p><p>​        1、引入超时机制。同时在协调者和参与者中都引入超时机制。 </p><p>​        2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是 一致的。首先<strong>准备阶段的变更成不会直接执行事务</strong>，而是会先去询问此时的参与者是否有条件接这个事务，因此<strong>不会一来就干活直接锁资源</strong>，使得在某些资源不可用的情况下所有参与者都阻塞着。而<strong>预提交阶段的引入起到了一个统一状态的作用</strong>，它像一道栅栏，表明在预提交阶段前所有参与者其实还未都回应，在预处理阶段表明所有参与者都已经回应了。</p><blockquote><p>阶段1：是否可以进行事务提交</p><p><img src="https://img-blog.csdn.net/20180729211432145?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eGlhbnM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>阶段2： 提交事务请求</p><p><img src="https://img-blog.csdn.net/20180729211455148?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eGlhbnM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>阶段3：执行事务提交</p><p><img src="https://img-blog.csdn.net/20180729211520312?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eGlhbnM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p></blockquote><h3 id="D-BASE理论"><a href="#D-BASE理论" class="headerlink" title="D. BASE理论"></a>D. BASE理论</h3><p><strong>BASE 理论，它是在 CAP 理论的基 础之上的延伸。</strong>包括 :</p><blockquote><p>基本可用（Basically Available）:在分布式系统出现，允许损失部分可用性（服务降级、页面降级）v</p><p>柔性状态（Soft State）:允许分布式系统出现中间状态。而且中间状态不影响系统的可用性。</p><p>最终一致性 （Eventual Consistency）:data replications经过一段时间达到一致性。</p></blockquote><h2 id="2-一致性算法"><a href="#2-一致性算法" class="headerlink" title="2. 一致性算法"></a>2. 一致性算法</h2><h3 id="A-paxos一致性算法"><a href="#A-paxos一致性算法" class="headerlink" title="A. paxos一致性算法"></a>A. paxos一致性算法</h3><p>​        paxos算法是莱斯利·兰伯特于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法。Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是paxos，其它的算法都是残次品。</p><p><strong><code>基于拜占庭将军问题解析：</code></strong></p><p>分为以下两种角色：</p><ul><li>proposer：参谋1，参谋2（提交者）</li><li>acceptor： 将军1，将军2，将军3（决策者）</li></ul><blockquote><p><strong>1、先后提议的场景</strong></p><p><img src="https://img-blog.csdn.net/20180729212212421?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eGlhbnM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><ul><li>参谋1发起提议，派通信兵带信给3个将军，内容为（编号1）</li><li>3个将军收到参谋1的提议，由于之前还没有保存任何编号，因此把（编号1）保存下来，避免遗忘；同时让通信兵带信回去，内容为（ok）</li><li>参谋1收到至少2个将军的回复，再次派通信兵带信给3个将军，内容为（编号1，进攻时间1）</li><li>3个将军收到参谋1的时间，把（编号1，进攻时间1）保存下来，避免遗忘；同时让通信兵带信回去，内容为（Accepted）</li><li>参谋1收到至少2个将军的（Accepted）内容，确认进攻时间已经被大家接收；</li><li>参谋2发起提议，派通信兵带信给3个将军，内容为（编号2）</li><li>3个将军收到参谋2的提议，由于（编号2）比（编号1）大，因此把（编号2）保存下来，避免遗忘；又由</li><li>之前已经接受参谋1的提议，因此让通信兵带信回去，内容为（编号1，进攻时间1）</li><li>参谋2收到至少2个将军的回复，由于回复中带来了已接受的参谋1的提议内容，参谋2因此不再提出新的进攻时间，接受参谋1提出的时间</li></ul><p><strong>2、交叉提交场景</strong></p><p><img src="https://img-blog.csdn.net/20180729212438459?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eGlhbnM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><ul><li>参谋1发起提议，派通信兵带信给3个将军，内容为（编号1）；</li><li>3个将军的情况如下:<ul><li>将军1和将军2收到参谋1的提议，将军1和将军2把（编号1）记录下来，如果有其他参谋提出更小的编号，将被拒绝；同时让通信兵带信回去，内容为（ok）</li><li>负责通知将军3的通信兵被抓，因此将军3没收到参谋1的提议</li></ul></li><li>参谋2在同一时间也发起了提议，派通信兵带信给3个将军，内容为（编号2）</li><li>3个将军的情况如下<ul><li>将军2和将军3收到参谋2的提议，将军2和将军3把（编号2）记录下来，如果有其他参谋提出更小的编号，将被拒绝；同时让通信兵带信回去，内容为（ok）</li><li>负责通知将军1的通信兵被抓，因此将军1没收到参谋2的提议</li></ul></li><li>参谋1收到至少2个将军的回复，再次派通信兵带信给有答复的2个将军，内容为（编号1，进攻时间1）</li><li>2个将军的情况如下<ul><li>将军1收到了（编号1，进攻时间1），和自己保存的编号相同，因此把（编号1，进攻时间1）保存下来；同时让通信兵带信回去，内容为（Accepted）</li><li>将军2收到了（编号1，进攻时间1），由于（编号1）小于已经保存的（编号2），因此让通信兵带信回去，内容为（Rejected，编号2）</li></ul></li><li>参谋2收到至少2个将军的回复，再次派通信兵带信给有答复的2个将军，内容为（编号2，进攻时间2）</li><li>将军2和将军3收到了（编号2，进攻时间2），和自己保存的编号相同，因此把（编号2，进攻时间2）保存下来，同时让通信兵带信回去，内容为（Accepted）</li><li>参谋2收到至少2个将军的（Accepted）内容，确认进攻时间已经被多数派接受</li><li>参谋1只收到了1个将军的（Accepted）内容，同时收到一个（Rejected，编号2）;参谋1重新发起提议，派通信兵带信给3个将军，内容为（编号3）</li><li>3个将军的情况如下<ul><li>将军1收到参谋1的提议，由于（编号3）大于之前保存的（编号1），因此把（编号3）保存下来；由于将军1已经接受参谋1前一次的提议，因此让通信兵带信回去，内容为（编号1，进攻时间1）</li><li>将军2收到参谋1的提议，由于（编号3）大于之前保存的（编号2），因此把（编号3）保存下来；由于将军2已经接受参谋2的提议，因此让通信兵带信回去，内容为（编号2，进攻时间2）</li><li>负责通知将军3的通信兵被抓，因此将军3没收到参谋1的提议</li></ul></li><li>参谋1收到了至少2个将军的回复，比较两个回复的编号大小，选择大编号对应的进攻时间作为最新的提议；参谋1再次派通信兵带信给有答复的2个将军，内容为（编号3，进攻时间2）</li><li>将军1和将军2收到了（编号3，进攻时间2），和自己保存的编号相同，因此保存（编号3，进攻时间2），同时让通信兵带信回去，内容为（Accepted）</li><li>参谋1收到了至少2个将军的（accepted）内容，确认进攻时间已经被多数派接受。</li></ul></blockquote><h3 id="B-raft一致性算法"><a href="#B-raft一致性算法" class="headerlink" title="B. raft一致性算法"></a>B. raft一致性算法</h3><h2 id="3-一致性Hash算法"><a href="#3-一致性Hash算法" class="headerlink" title="3. 一致性Hash算法"></a>3. 一致性Hash算法</h2><p><em><strong>参考：</strong></em><a href="https://zhuanlan.zhihu.com/p/98030096">一致性hash算法详解</a></p><h3 id="A-普通Hash算法在分布式应用中的不足"><a href="#A-普通Hash算法在分布式应用中的不足" class="headerlink" title="A. 普通Hash算法在分布式应用中的不足"></a>A. 普通Hash算法在分布式应用中的不足</h3><blockquote><p>比如，在分布式的存储系统中，要将数据存储到具体的节点上，如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。</p></blockquote><h3 id="B-一致性Hash算法"><a href="#B-一致性Hash算法" class="headerlink" title="B. 一致性Hash算法"></a>B. 一致性Hash算法</h3><blockquote><p>一致性哈希提出了在动态变化的Cache环境中，哈希算法应该满足的4个适应条件(from 百度百科)：</p><p>A:均衡性(Balance)</p><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p><p>B:单调性(Monotonicity)</p><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。（这段翻译信息有负面价值的，当缓冲区大小变化时一致性哈希(Consistent hashing)尽量保护已分配的内容不会被重新映射到新缓冲区。）</p><p>C:分散性(Spread)</p><p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p><p>D:负载(Load)</p><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p></blockquote><h5 id="B-1-环形hash空间"><a href="#B-1-环形hash空间" class="headerlink" title="B.1 环形hash空间"></a>B.1 环形hash空间</h5><p>​        <em>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。</em>整个hash环我们可以用TreeMap来实现，因为treeMap是排序的，我们刚好可以利用上。</p><p><img src="https://pic2.zhimg.com/80/v2-0a21bff27b5f037748292aa338965d65_720w.jpg" alt="img"></p><h5 id="B-2-映射服务器节点"><a href="#B-2-映射服务器节点" class="headerlink" title="B.2 映射服务器节点"></a>B.2 映射服务器节点</h5><p>​        <em>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假设我们将四台服务器使用ip地址哈希后在环空间的位置如下：</em></p><p><img src="https://pic4.zhimg.com/80/v2-252cc4ed5bbb07e5e1e3b27c5eda0d23_720w.jpg" alt="img"></p><h5 id="B-3-映射数据"><a href="#B-3-映射数据" class="headerlink" title="B.3 映射数据"></a>B.3 映射数据</h5><p>​        <em>现在我们将objectA、objectB、objectC、objectD四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</em></p><p><img src="https://pic3.zhimg.com/80/v2-0fb33fe30c7a05eee2abe3784a42f98a_720w.jpg" alt="img"></p><h5 id="B-4-服务器的删除与添加"><a href="#B-4-服务器的删除与添加" class="headerlink" title="B.4 服务器的删除与添加"></a>B.4 服务器的删除与添加</h5><blockquote><ul><li>如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化</li><li>如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</li></ul></blockquote><p><img src="https://pic4.zhimg.com/80/v2-bf7daae4aa145478dd55fc339ee57ec7_720w.jpg" alt="img"></p><h5 id="B-5-虚拟节点"><a href="#B-5-虚拟节点" class="headerlink" title="B.5 虚拟节点"></a>B.5 虚拟节点</h5><p>​        <em>到目前为止一致性hash也可以算做完成了，但是有一个问题还需要解决，那就是<strong>平衡性</strong>。当服务器节点比较少的时候，会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。</em></p><p><img src="https://pic4.zhimg.com/80/v2-0ce62cf40bcc5f980cafe285dafe0633_720w.jpg" alt="img"></p><p>​        <em>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。</em></p><p><img src="https://pic1.zhimg.com/80/v2-5d9cdea01cb4b44162aa41980345e8ac_720w.jpg" alt="img"></p><h2 id="4-分布式ID"><a href="#4-分布式ID" class="headerlink" title="4. 分布式ID"></a>4. 分布式ID</h2><blockquote><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。下面来分析各个生成分布式ID的机制。</p></blockquote><h2 id="5-Dubbo"><a href="#5-Dubbo" class="headerlink" title="5. Dubbo"></a>5. Dubbo</h2><p>Dubbo的学习一定要看官网，这里粘一下关于负载均衡的源代码解析，整个源代码更迭过程很有启发:<a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/</a></p><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p><p>在Dubbo的官网文档有这样一张图</p><p><img src="https://dubbo.apache.org/imgs/user/dubbo-architecture-roadmap.jpg" alt="image"></p><h4 id="1-单一应用架构-All-in-One"><a href="#1-单一应用架构-All-in-One" class="headerlink" title="1. 单一应用架构(All in One)"></a>1. 单一应用架构(All in One)</h4><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshw2ITicetDcFsg41kISOhuyojGB1Z8ics61xtqnicJTXDk7Qw41dkeXK2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p><p><strong>缺点：</strong></p><p>1、性能扩展比较难</p><p>2、协同开发问题</p><p>3、不利于升级维护</p><h4 id="2-垂直应用架构-Vertical-Application"><a href="#2-垂直应用架构-Vertical-Application" class="headerlink" title="2. 垂直应用架构(Vertical Application)"></a>2. 垂直应用架构(Vertical Application)</h4><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshG4FicWRMjbfStG0Ojr1H9cL1jQ1SbZ0s7rsbsc7w8f3usmdSJog7pHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p><p>缺点：公用模块无法重复利用，开发性的浪费</p><h4 id="3-分布式服务架构-Distributed-Service"><a href="#3-分布式服务架构-Distributed-Service" class="headerlink" title="3. 分布式服务架构(Distributed Service)"></a>3. 分布式服务架构(Distributed Service)</h4><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshwIkic8EicmCwYGRibdWohmDazEDhonhTeJfVx0dfBNlW4dGGxvOMOk0Gg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h4 id="4-弹性计算架构-Elastic-Computing"><a href="#4-弹性计算架构-Elastic-Computing" class="headerlink" title="4. 弹性计算架构(Elastic Computing)"></a>4. 弹性计算架构(Elastic Computing)</h4><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>(SOA)[ Service Oriented Architecture]是关键。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshxoCosFhoMzIcbBzjCt6ia9Gr7atHlwNHhL0po4YhyE8WkHXnnpN8Ddg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="6-RPC和HTTP"><a href="#6-RPC和HTTP" class="headerlink" title="6. RPC和HTTP"></a>6. RPC和HTTP</h2><p>无论是微服务还是分布式服务（都是SOA，都是面向服务编程），都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？</p><p>常见的远程调用方式有以下几种：</p><ul><li><p>RPC：是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。，类似的还有RMI（Remote Methods Invoke  远程方法调用，是JAVA中的概念，是JAVA十三大技术之一）。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型</p></li><li><ul><li>RPC的框架：webservie(cxf)、dubbo(阿里巴巴开源的基于 Java 的高性能 RPC)</li><li>RMI的框架：hessian</li></ul></li></ul><ul><li><p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。<br>现在热门的Rest风格，就可以通过http协议来实现。</p></li><li><ul><li>http的实现技术：HttpClient</li></ul></li></ul><p><strong>RPC基本原理</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshVx3xhf4RyUVtia7Tvo4BBs70SFKRonhrPrNsiap2rEAQCn4IWUoS3HZA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>步骤解析：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JJjARRqcZibY4ZPv60renshDCibUnIYkolqibQRy7Qlpm9vNibK9IDaFibJoLpIM5pWLe7Yqly7PheYsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>RPC两个核心模块：通讯，序列化。</p><p><strong>要实现一个RPC不算难，难的是实现一个高性能高可靠的RPC框架。</strong></p><p>比如，既然是分布式了，那么一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？</p><p>这时候就需要一个服务注册中心，比如在Dubbo里头，就可以使用Zookeeper作为注册中心，在调用时，从Zookeeper获取服务的实例列表，再从中选择一个进行调用。</p><p>那么选哪个调用好呢？这时候就需要负载均衡了，于是你又得考虑如何实现复杂均衡，比如Dubbo就提供了好几种负载均衡策略。</p><p>这还没完，总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题，blablabla……</p><p>你以为就这样结束了，没呢，还有这些：</p><ul><li>客户端总不能每次调用完都干等着服务端返回数据吧，于是就要支持异步调用；</li><li>服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；</li><li>服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；</li><li>服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？</li><li>……</li></ul><h3 id="RPC和HTTP认知误区勘误"><a href="#RPC和HTTP认知误区勘误" class="headerlink" title="RPC和HTTP认知误区勘误"></a>RPC和HTTP认知误区勘误</h3><p>rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。</p><p>传输协议包含: 如著名的gRPC 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。</p><p>序列化协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf hessian等。</p><p><strong>为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？</strong></p><p>要解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。</p><p>首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于连接的建立与断开。http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二一要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。</p><p>通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">HTTP/1.0 200 OK Content-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Hello World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使编码协议也就是body是使用二进制编码协议，报文元数据也就是header头的键值对却用了文本编码，非常占字节数。如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。</p><p>那么假如我们使用自定义tcp协议的报文如下</p><p><img src="https://pic4.zhimg.com/50/v2-89c905b0806577471aa7789a25ac0d44_hd.jpg?source=1940ef5c" alt="img"></p><p>报头占用的字节数也就只有16个byte，极大地精简了传输内容。</p><p>这也就是为什么后端进程间通常会采用自定义tcp协议的rpc来进行通信的原因。</p><p>但是现在越来越少使用RPC了，是因为RPC所谓的效率优势是针对http1.1协议来讲的，http2.0协议已经优化编码效率问题，像grpc这种rpc库使用的就是http2.0协议。</p><p>所以说成熟的rpc库相对http容器，更多的是封装了“服务发现”，”负载均衡”，“熔断降级”一类面向服务的高级特性。可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。因此良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> RPC </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之视图解析器</title>
      <link href="2021/05/21/springboot-zhi-shi-tu-jie-xi-qi/"/>
      <url>2021/05/21/springboot-zhi-shi-tu-jie-xi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot之视图解析器"><a href="#springboot之视图解析器" class="headerlink" title="springboot之视图解析器"></a>springboot之视图解析器</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>在springmvc中在web.xml配置完dispatcherServlet之后还有一个非常重要的步骤就是在application.xml文件中添加视图解析器ViewResolver的配置，如下：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--添加视图解析器--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>InternalResourceViewResolver<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--前缀--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/WEB-INF/jsp/<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!--后缀--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在springboot中没有了配置，那么springboot是怎么帮我们添加视图解析器的呢？我们通过源码来探析。</p><h3 id="2-源码探析"><a href="#2-源码探析" class="headerlink" title="2. 源码探析"></a>2. 源码探析</h3><p>通过官方文档我们发现springboot自带了两个视图解析器<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code></p><p>并且在我们导入thymeleaf模板引擎之后，thymeleaf也自带了视图解析器，默认路径是templates包下</p><p>查看ContentNegotiatingViewResolver和BeanNameViewResolver，发现这两个类都实现了一个公共接口ViewResolver。也都重写了接口方法resolveViewName</p><p>下面是ContentNegotiatingViewResolver重写的resolveViewName方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">View</span> <span class="token function">resolveViewName</span><span class="token punctuation">(</span><span class="token class-name">String</span> viewName<span class="token punctuation">,</span> <span class="token class-name">Locale</span> locale<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RequestAttributes</span> attrs <span class="token operator">=</span> <span class="token class-name">RequestContextHolder</span><span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>attrs <span class="token keyword">instanceof</span> <span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">,</span> <span class="token string">"No current ServletRequestAttributes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MediaType</span><span class="token punctuation">></span></span> requestedMediaTypes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMediaTypes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span>attrs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>requestedMediaTypes <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//重点就在这两行代码，它会通过getCandidateViews获取所有候选的视图解析器，</span>        <span class="token comment">//并通过getBestView选择最好的视图解析器</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">View</span><span class="token punctuation">></span></span> candidateViews <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCandidateViews</span><span class="token punctuation">(</span>viewName<span class="token punctuation">,</span> locale<span class="token punctuation">,</span> requestedMediaTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">View</span> bestView <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBestView</span><span class="token punctuation">(</span>candidateViews<span class="token punctuation">,</span> requestedMediaTypes<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bestView <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> bestView<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是BeanNameViewResolver重写的resolveViewName方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">View</span> <span class="token function">resolveViewName</span><span class="token punctuation">(</span><span class="token class-name">String</span> viewName<span class="token punctuation">,</span> <span class="token class-name">Locale</span> locale<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">obtainApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>context<span class="token punctuation">.</span><span class="token function">containsBean</span><span class="token punctuation">(</span>viewName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>context<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>viewName<span class="token punctuation">,</span> <span class="token class-name">View</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Found bean named '"</span> <span class="token operator">+</span> viewName <span class="token operator">+</span> <span class="token string">"' but it does not implement View"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">View</span><span class="token punctuation">)</span>context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>viewName<span class="token punctuation">,</span> <span class="token class-name">View</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-自定义视图解析器"><a href="#3-自定义视图解析器" class="headerlink" title="3. 自定义视图解析器"></a>3. 自定义视图解析器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//拓展springmvc配置</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">ViewResolver</span> <span class="token function">myViewResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyViewResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//自定义了一个自己的视图解析器MyViewResolver</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyViewResolver</span> <span class="token keyword">implements</span> <span class="token class-name">ViewResolver</span><span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">View</span> <span class="token function">resolveViewName</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">Locale</span> locale<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>双击shift找到DispatcherServlet类，ctrl+F找到doDispatch方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DispatcherServlet</span> <span class="token keyword">extends</span> <span class="token class-name">FrameworkServlet</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doDispatch</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在doDispatch方法上打上断点，并进行Debug，会有以下图：</p><p><img src="/.io//1.png" alt="自定义视图解析器Debug图"></p><p>可以看到，我们的自定义视图解析器被springboot自动扫描上了</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 视图解析器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之cron表达式</title>
      <link href="2021/05/21/springboot-zhi-cron-biao-da-shi/"/>
      <url>2021/05/21/springboot-zhi-cron-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot之cron表达式"><a href="#springboot之cron表达式" class="headerlink" title="springboot之cron表达式"></a>springboot之cron表达式</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>在学习springboot的定时任务时，在方法上的<code>@Scheduled(cron = &quot;0 * * * * 0-7&quot;)</code>注解可以用cron表达式来表示定时的时间，这个博客来详细讲下cron表达式</p><h3 id="2-Cron详解"><a href="#2-Cron详解" class="headerlink" title="2.Cron详解"></a>2.Cron详解</h3><h4 id="字段释义"><a href="#字段释义" class="headerlink" title="字段释义"></a>字段释义</h4><pre class="line-numbers language-none"><code class="language-none">0 0&#x2F;5 * * * ？秒    分    时    天(月)    月    天(周)    年份(一般省略)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="符号释义"><a href="#符号释义" class="headerlink" title="符号释义"></a>符号释义</h4><p><code>*</code>：表示所有可能的值</p><p><code>/</code>：表示数值的增量，简单来说，比如分写上<code>0/5</code>表示从0分开始，每隔5分钟</p><p><code>?</code>：仅用在天(月)和天(周)，表示不指定值，当其中一个有值时，另外一个需要设为`?</p><h4 id="字段允许字符"><a href="#字段允许字符" class="headerlink" title="字段允许字符"></a>字段允许字符</h4><h5 id="秒：0-59"><a href="#秒：0-59" class="headerlink" title="秒：0-59 , - * /"></a>秒：<code>0-59</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><ul><li>26：表示第26秒</li><li>5,16,27：表示第5秒、第16秒和第27秒</li><li>1-5：表示从1秒到5秒，就是1 2  3  4 5 秒</li><li>*：表示每一秒</li><li>2/15：表示从第2秒开始，每隔15秒，就是2 17 32 47 秒</li></ul><h5 id="分：0-59"><a href="#分：0-59" class="headerlink" title="分：0-59 , - * /"></a>分：<code>0-59</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><p>根据上述的秒，同理可得</p><ul><li>26：表示第26分钟</li><li>5,16,27：表示第5分钟、第16分钟和第27分钟</li><li>1-5：表示从1秒到5分，就是第1 2  3  4 5 分钟</li><li>*：表示每一分钟</li><li>2/15：表示从第2分钟开始，每隔15分钟，就是2 17 32 47 分钟</li></ul><h5 id="时：0-23"><a href="#时：0-23" class="headerlink" title="时：0-23 , - * /"></a>时：<code>0-23</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><ul><li>10：表示早上10点</li><li>22：表示晚上10点</li><li>2,8,18,23：表示凌晨2点，早上8点，傍晚6点和晚上11点</li><li>9-17：表示朝九晚五，就是9 10 11 12 13 14 15 16 17 点</li><li>*：表示每小时</li><li>10/2：表示从早上10点开始，每隔2小时</li></ul><h5 id="天（月）：1-31-L-W-C"><a href="#天（月）：1-31-L-W-C" class="headerlink" title="天（月）：1-31 , - * / ? L W C"></a>天（月）：<code>1-31</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code> <code>?</code> <code>L</code> <code>W</code> <code>C</code></h5><ul><li>31：表示31号（注意有的月份是没有31号的）</li><li>5,10,15：表示5号、10号和15号</li><li>8-17：表示8号到17号</li><li>*：表示所有可能的值（当指定为星号时，天（周）需指定为?）</li><li>5/9：表示从5号开始，每隔9天</li><li>？：当天（周）指定任意值的时候，天（月）需要设置为?</li><li>L：表示一个月中的最后一天</li><li>6L：表示倒数第6天</li><li>15W：W指工作日，如果15号不是周六日，则表示15号当天；如果15号是周六，则表示14号；如果15号是周日，则表示16号；如果31W是周日，则31W表示29号（周五），不会跨月</li><li>LW：指最后一个工作日</li><li>15C：表示第15天（不是很明白这个，使用15和15C貌似效果相同？）</li></ul><h5 id="月：1-12"><a href="#月：1-12" class="headerlink" title="月：1-12 , - * /"></a>月：<code>1-12</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><ul><li>10：表示10月份</li><li>5,10,11：表示5月份、10月份和11月份</li><li>4-8：表示4月份到8月份</li><li>*：表示所有可能的值</li><li>5/2：表示从5月份开始，每隔2个月，（就是5 7 9 11 次年5 次年7 次年9……）</li><li>1-12：也可以用JAN-DEC表示</li></ul><h5 id="天（周）：MON-SAT-L-C"><a href="#天（周）：MON-SAT-L-C" class="headerlink" title="天（周）：MON-SAT  , - * / ? L C #"></a>天（周）：<code>MON-SAT</code>  <code>,</code> <code>-</code> <code>*</code> <code>/</code> <code>?</code> <code>L</code> <code>C</code> <code>#</code></h5><ul><li>MON：表示周一</li><li>MON,TUE,FRI：表示周一，周二和周五</li><li>MON-FRI：表示从周一到周五</li><li>MON-WED,SAT：表示从周一到周三，和周六（就是周一、周二、周三和周六）</li><li>mon,tue,wed,thu,fri,sat,sun：表示周一到周日（大小写均可，取星期英文前三个字母，注意星期四是thu，而不是thur）</li><li>7L：表示最后一个周六（效果等同于SATL）（L表示last最后的意思，7表示周六，6表示周五，类推，1表示周日）</li><li>6C：表示周五以及之后包含周五的日期（感觉效果FRI一样，具体还没深究）</li><li>7#2：表示第二个周六（#前面的数字表示星期，1表示周日，2表示周一，以此类推；#后面的数字表示第几个）</li></ul><h5 id="年：留空-2020-2099"><a href="#年：留空-2020-2099" class="headerlink" title="年：留空  2020-2099 , - * /"></a>年：<code>留空</code>  <code>2020-2099</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><ul><li>2050：表示2050年</li><li>2020,2030,2040：表示2020年、2030年和2040年</li><li>2020-2030：表示2020年到2030年</li><li>*：表示所有可能的值</li><li>2020/10：表示从2020年开始，每隔10年，（就是2020,2030,2040……）</li></ul><h3 id="3-例子"><a href="#3-例子" class="headerlink" title="3.例子"></a>3.例子</h3><ul><li><p>每隔5分钟执行一次（从0分开始）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span><span class="token operator">/</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">*</span> ？<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>从0时开始，每小时执行一次</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span><span class="token operator">/</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>每天的7点30分</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">30</span> <span class="token number">7</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>工作日的早上6点30分（即是周一到周五，每天早上的6点30分）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">30</span> <span class="token number">6</span> <span class="token operator">?</span> <span class="token operator">*</span> MON<span class="token operator">-</span>FRI<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>每个月的最后一天早上的10点整</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span> <span class="token number">10</span> <span class="token class-name">L</span> <span class="token operator">*</span>　<span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>每个月的最后一个工作日的晚上6点30分（18:30）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">30</span> <span class="token number">18</span> LW <span class="token operator">*</span> <span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>朝九晚五，每小时</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span> <span class="token number">9</span><span class="token operator">-</span><span class="token number">17</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>2020年的8月份每个星期六和星期日早上10点28分28秒</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">28</span> <span class="token number">28</span> <span class="token number">10</span> <span class="token operator">?</span> <span class="token number">8</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token number">2020</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span>中，<span class="token number">1</span>表示周日，<span class="token number">7</span>表示周六<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>每个月的倒数第二天的早上8点整</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span> <span class="token number">8</span> <span class="token class-name">L</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token operator">?</span><span class="token class-name">L</span>表示最后一天（倒数第一天），<span class="token class-name">L</span><span class="token operator">-</span><span class="token number">1</span>则表示倒数第二天，以此类推<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下面是网上一些例子，我直接拿过来了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token string">"0 0 12 * * ?"</span> 每天中午<span class="token number">12</span>点触发 <span class="token string">"0 15 10 ? * *"</span> 每天上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 * * ?"</span> 每天上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 * * ? *"</span> 每天上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 * * ? 2005"</span> <span class="token number">2005</span>年的每天上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 * 14 * * ?"</span> 在每天下午<span class="token number">2</span>点到下午<span class="token number">2</span><span class="token operator">:</span><span class="token number">59</span>期间的每<span class="token number">1</span>分钟触发 <span class="token string">"0 0/5 14 * * ?"</span> 在每天下午<span class="token number">2</span>点到下午<span class="token number">2</span><span class="token operator">:</span><span class="token number">55</span>期间的每<span class="token number">5</span>分钟触发 <span class="token string">"0 0/5 14,18 * * ?"</span> 在每天下午<span class="token number">2</span>点到<span class="token number">2</span><span class="token operator">:</span><span class="token number">55</span>期间和下午<span class="token number">6</span>点到<span class="token number">6</span><span class="token operator">:</span><span class="token number">55</span>期间的每<span class="token number">5</span>分钟触发 <span class="token string">"0 0-5 14 * * ?"</span> 在每天下午<span class="token number">2</span>点到下午<span class="token number">2</span><span class="token operator">:</span><span class="token number">05</span>期间的每<span class="token number">1</span>分钟触发 <span class="token string">"0 10,44 14 ? 3 WED"</span> 每年三月的星期三的下午<span class="token number">2</span><span class="token operator">:</span><span class="token number">10</span>和<span class="token number">2</span><span class="token operator">:</span><span class="token number">44</span>触发 <span class="token string">"0 15 10 ? * MON-FRI"</span> 周一至周五的上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 15 * ?"</span> 每月<span class="token number">15</span>日上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 L * ?"</span> 每月最后一日的上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 ? * 6L"</span> 每月的最后一个星期五上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 ? * 6L 2002-2005"</span> <span class="token number">2002</span>年至<span class="token number">2005</span>年的每月的最后一个星期五上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 ? * 6#3"</span> 每月的第三个星期五上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-要点"><a href="#4-要点" class="headerlink" title="4.要点"></a>4.要点</h3><ul><li>一般是有6个位置，分别表示 <strong>分 秒 时 天(月) 月 天(周)</strong>   第7个位置是年，一般省略</li><li>6个位置中的 <strong>天(月)</strong> 表示一个月中的第几天，即是几月几号中的几号；<strong>天(周)</strong> 表示一周中的第几天，周日为第一天，周六为第七天</li><li>**天(月)<strong>和</strong>天(周)**不能同时指定，其中必定有一个是 <strong>?</strong></li><li><strong>?</strong> 只能用在 <strong>天(月)<strong>和</strong>天(周)</strong></li><li>2-10：符号  <strong>-</strong>  表示范围区间</li><li>2/10：符号  <strong>/</strong>  表示频率，从2开始，每隔10，即2，12，22……类推</li><li>2,10：符号  <strong>,</strong>  表示和，<code>2,10</code>表示2和10</li><li>L：last的缩写，表示最后，只能用在<strong>天(月)<strong>和</strong>天(周)<strong>，一般和数字搭配使用，如L在天(月)中表示一个月中的最后一天，</strong>L-1</strong>则表示<strong>每个月的倒数第二天</strong>；3L在天(周)中则表示最后一个星期二</li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> cron表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之首页配置</title>
      <link href="2021/05/21/springboot-zhi-shou-ye/"/>
      <url>2021/05/21/springboot-zhi-shou-ye/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot之首页配置"><a href="#springboot之首页配置" class="headerlink" title="springboot之首页配置"></a>springboot之首页配置</h2><p>在<code>WebMvcAutoConfiguration</code>中有如下方法有关首页配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">WelcomePageHandlerMapping</span> <span class="token function">welcomePageHandlerMapping</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">,</span> <span class="token class-name">FormattingConversionService</span> mvcConversionService<span class="token punctuation">,</span> <span class="token class-name">ResourceUrlProvider</span> mvcResourceUrlProvider<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//重点在于this.getWelcomePage()</span>    <span class="token class-name">WelcomePageHandlerMapping</span> welcomePageHandlerMapping <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WelcomePageHandlerMapping</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TemplateAvailabilityProviders</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">,</span> applicationContext<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getWelcomePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getStaticPathPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    welcomePageHandlerMapping<span class="token punctuation">.</span><span class="token function">setInterceptors</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getInterceptors</span><span class="token punctuation">(</span>mvcConversionService<span class="token punctuation">,</span> mvcResourceUrlProvider<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    welcomePageHandlerMapping<span class="token punctuation">.</span><span class="token function">setCorsConfigurations</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCorsConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> welcomePageHandlerMapping<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>this.getWelcomePage()</code>方法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Resource</span> <span class="token function">getWelcomePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getStaticLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> var2<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> location <span class="token operator">=</span> var1<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//获取首页</span>        <span class="token class-name">Resource</span> indexHtml <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIndexHtml</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>indexHtml <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> indexHtml<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">ServletContext</span> servletContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>servletContext <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIndexHtml</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Resource</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServletContextResource</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//根据首页位置获取首页</span><span class="token keyword">private</span> <span class="token class-name">Resource</span> <span class="token function">getIndexHtml</span><span class="token punctuation">(</span><span class="token class-name">String</span> location<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIndexHtml</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">Resource</span> <span class="token function">getIndexHtml</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> location<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//首页url为/index.html</span>        <span class="token class-name">Resource</span> resource <span class="token operator">=</span> location<span class="token punctuation">.</span><span class="token function">createRelative</span><span class="token punctuation">(</span><span class="token string">"index.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resource<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> resource<span class="token punctuation">.</span><span class="token function">getURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> resource<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var3<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 首页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spingboot之静态资源导出原理</title>
      <link href="2021/05/13/springboot-zhi-jing-tai-zi-yuan-dao-ru/"/>
      <url>2021/05/13/springboot-zhi-jing-tai-zi-yuan-dao-ru/</url>
      
        <content type="html"><![CDATA[<h2 id="spingboot静态资源导出原理探究"><a href="#spingboot静态资源导出原理探究" class="headerlink" title="spingboot静态资源导出原理探究"></a>spingboot静态资源导出原理探究</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>springboot相较于springmvc没有了webapp这个目录文件夹，那么springboot中静态资源应该存放在哪呢？</p><p>接下来我们通过探析源码的方式来解决这个问题</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//添加资源处理的方法</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addResourceHandlers</span><span class="token punctuation">(</span><span class="token class-name">ResourceHandlerRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">addResourceHandlers</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">isAddMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//如果自定义了静态资源处理，即在.properties或者.yaml文件中</span>        <span class="token comment">//即配置这个属性spring.mvc.static-path-pattern=/**</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Default resource handling disabled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ServletContext</span> servletContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//第一种是通过webjars下寻找</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token string">"/webjars/**"</span><span class="token punctuation">,</span> <span class="token string">"classpath:/META-INF/resources/webjars/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//第二种是通过getStaticLocations()获取this.staticLocations，</span>        <span class="token comment">//而this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span>        <span class="token comment">//CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;"classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"&#125;;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getStaticPathPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>registration<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            registration<span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getStaticLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>servletContext <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                registration<span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">ServletContextResource</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种方法：webjars，在pom文件中加入以下依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.webjars<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jquery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在lib中就会有以下结构的包</p><p><img src="/.io//MyBlog\source_posts\springboot之静态资源导入\1.png" alt="webjars结构图及对应关系"></p><p>通过访问localhost:8080/webjars/jquery/3.6.0/jquery.js即可访问静态资源，但是一般不这么用</p><p>第二种方法：放在”classpath:/resources/“, “classpath:/static/“, “classpath:/public/“这三个路径下</p><p>目录结构如下</p><p><img src="/.io//MyBlog\source_posts\springboot之静态资源导入\2.png" alt="静态资源存储路径"></p><p>访问路径为:localhost:8080/1.js</p><p>其中访问优先度为resources&gt;static&gt;public</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="2021/05/13/wei-fu-wu/"/>
      <url>2021/05/13/wei-fu-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><blockquote><p>简而言之，微服务架构风格是一种将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的进程中运行，并以轻量级机制（通常是 HTTP  资源  API）进行通信。</p><p>这些服务围绕业务功能构建，可通过全自动部署机制来独立部署。这些服务共用一个最小型的集中式管理，它们可以使用不同的编程语言编写，并使用不同的数据存储技术。</p></blockquote><p>单体(monolithic)（all in one）风格:</p><blockquote><p>单体应用程序被构建为单一单元。企业应用程序通常由三个部分构成：客户端用户界面（由用户机器上的浏览器中运行的 HTML 页面和 JS组成）、数据库（由许多表组成，通常是在关系型数据库中管理）系统、服务器端应用程序。服务器端应用程序处理 HTTP  请求，执行一些逻辑处理，从数据库检索和更新数据，选择数据并填充到要发送到浏览器的 HTML  视图中。这个服务器端应用程序是一个整体——那么发生任何更改都会影响到应用程序的构建和部署</p><p>优点：易于开发和测试，方便部署，当需要扩展的时候只需要把war包复制多份，然后放在多个服务器上，再做个负载均衡即可</p><p>缺点：在将更多应用程序部署到云的时候。变更周期被捆绑在一起——即使只是对应用程序的一小部分进行了更改，也需要重建和部署整个单体应用。随着时间的推移，通常很难保持良好的模块化结构。对系统进行扩展时，不得不扩展整个应用系统。</p></blockquote><p>微服务原文可见：<a href="https://www.martinfowler.com/articles/microservices.html">https://www.martinfowler.com/articles/microservices.html</a></p><p>微服务风格并不是新颖的或创新的，其根源至少可以追溯到 Unix 的设计原则</p><p><img src="https://doocs.gitee.io/advanced-java/docs/micro-services/images/sketch.png" alt="微服务设计原理"></p><h2 id="从单体式架构到微服务架构"><a href="#从单体式架构到微服务架构" class="headerlink" title="从单体式架构到微服务架构"></a>从单体式架构到微服务架构</h2><h3 id="迁移到微服务综述"><a href="#迁移到微服务综述" class="headerlink" title="迁移到微服务综述"></a>迁移到微服务综述</h3><p>迁移单体式应用到微服务架构意味着一系列现代化过程，有点像这几代开发者一直在做的事情，实时上，当迁移时，我们可以重用一些想法。</p><p>一个策略是：不要大规模（big bang）重写代码（只有当你承担重建一套全新基于微服务的应用时候可以采用重写这种方法）。重写代码听起来很不错，但实际上充满了风险最终可能会失败，就如 Martin Fowler 所说：</p><blockquote><p>“the only thing a Big Bang rewrite guarantees is a Big Bang!”</p></blockquote><p>相反，应该采取逐步迁移单体式应用的策略，通过逐步生成微服务新应用，与旧的单体式应用集成，随着时间推移，单体式应用在整个架构中比例逐渐下降直到消失或者成为微服务架构一部分。这个策略有点像在高速路上限速到 70 迈对车做维护，尽管有挑战，但是比起重写的风险小很多。</p><p>Martin Fowler  将这种现代化策略成为绞杀（Strangler）应用，名字来源于雨林中的绞杀藤（strangler vine），也叫绞杀榕 (strangler  fig)。绞杀藤为了爬到森林顶端都要缠绕着大树生长，一段时间后，树死了，留下树形藤。这种应用也使用同一种模式，围绕着传统应用开发了新型微服务应用，传统应用会渐渐退出舞台。</p><p>我们来看看其他可行策略。</p><h3 id="策略-1——停止挖掘"><a href="#策略-1——停止挖掘" class="headerlink" title="策略 1——停止挖掘"></a>策略 1——停止挖掘</h3><p>Law of Holes 是说当自己进洞就应该停止挖掘。对于单体式应用不可管理时这是最佳建议。换句话说，应该停止让单体式应用继续变大，也就是说当开发新功能时不应该为旧单体应用添加新代码，最佳方法应该是将新功能开发成独立微服务。如下图所示：</p><p><img src="https://doocs.gitee.io/advanced-java/docs/micro-services/images/Law-of-Holes.png" alt="停止挖掘流程"></p><p>除了新服务和传统应用，还有两个模块，其一是请求路由器，负责处理入口（http）请求，有点像之前提到的 API 网关。路由器将新功能请求发送给新开发的服务，而将传统请求还发给单体式应用。</p><p>另外一个是胶水代码（glue code），将微服务和单体应用集成起来，微服务很少能独立存在，经常会访问单体应用的数据。胶水代码，可能在单体应用或者为服务或者二者兼而有之，负责数据整合。微服务通过胶水代码从单体应用中读写数据。</p><p>微服务有三种方式访问单体应用数据：</p><ul><li>换气单体应用提供的远程 API</li><li>直接访问单体应用数据库</li><li>自己维护一份从单体应用中同步的数据</li></ul><p>胶水代码也被称为容灾层（anti-corruption layer），这是因为胶水代码保护微服务全新域模型免受传统单体应用域模型污染。胶水代码在这两种模型间提供翻译功能。术语  anti-corruption layer 第一次出现在 Eric Evans 撰写的必读书 _Domain Driven  Design_，随后就被提炼为一篇白皮书。开发容灾层可能有点不是很重要，但却是避免单体式泥潭的必要部分。</p><p>将新功能以轻量级微服务方式实现由很多优点，例如可以阻止单体应用变的更加无法管理。微服务本身可以开发、部署和独立扩展。采用微服务架构会给开发者带来不同的切身感受。</p><p>然而，这方法并不解决任何单体式本身问题，为了解决单体式本身问题必须深入单体应用  做出改变。我们来看看这么做的策略。</p><h3 id="策略-2——将前端和后端分离"><a href="#策略-2——将前端和后端分离" class="headerlink" title="策略 2——将前端和后端分离"></a>策略 2——将前端和后端分离</h3><p>减小单体式应用复杂度的策略是讲表现层和业务逻辑、数据访问层分开。典型的企业应用至少有三个不同元素构成：</p><ol><li>表现层——处理 HTTP 请求，要么响应一个 RESTAPI 请求，要么是提供一个基于 HTML 的图形接口。对于一个复杂用户接口应用，表现层经常是代码重要的部分。</li><li>业务逻辑层——完成业务逻辑的应用核心。</li><li>数据访问层——访问基础元素，例如数据库和消息代理。</li></ol><p>在表现层与业务数据访问层之间有清晰的隔离。业务层有由若干方面组成的粗粒度（coarse-grained）的 API，内部包含了业务逻辑元素。API  是可以将单体业务分割成两个更小应用的天然边界，其中一个应用是表现层，另外一个是业务和数据访问逻辑。分割后，表现逻辑应用远程调用业务逻辑应用，下图表示迁移前后架构不同：</p><p><img src="https://doocs.gitee.io/advanced-java/docs/micro-services/images/Before-and-after-migration.png" alt="迁移前后的架构"></p><p>单体应用这么分割有两个好处，其一使得应用两部分开发、部署和扩展各自独立，特别地，允许表现层开发者在用户界面上快速选择，进行 A/B 测试；其二，使得一些远程 API 可以被微服务调用。</p><p>然而，这种策略只是部分的解决方案。很可能应用的两部分之一或者全部都是不可管理的，因此需要使用第三种策略来消除剩余的单体架构。</p><h3 id="策略-3——抽出服务"><a href="#策略-3——抽出服务" class="headerlink" title="策略 3——抽出服务"></a>策略 3——抽出服务</h3><p>第三种迁移策略就是从单体应用中抽取出某些模块成为独立微服务。每当抽取一个模块变成微服务，单体应用就变简单一些；一旦转换足够多的模块，单体应用本身已经不成为问题了，要么消失了，要么简单到成为一个服务。</p><h4 id="排序那个模块应该被转成微服务"><a href="#排序那个模块应该被转成微服务" class="headerlink" title="排序那个模块应该被转成微服务"></a>排序那个模块应该被转成微服务</h4><p>一个巨大的复杂单体应用由成十上百个模块构成，每个都是被抽取对象。决定第一个被抽取模块一般都是挑战，一般最好是从最容易抽取的模块开始，这会让开发者积累足够经验，这些经验可以为后续模块化工作带来巨大好处。</p><p>转换模块成为微服务一般很耗费时间，一般可以根据获益程度来排序，一般从经常变化模块开始会获益最大。一旦转换一个模块为微服务，就可以将其开发部署成独立模块，从而加速开发进程。</p><p>将资源消耗大户先抽取出来也是排序标准之一。例如，将内存数据库抽取出来成为一个微服务会非常有用，可以将其部署在大内存主机上。同样的，将对计算资源很敏感的算法应用抽取出来也是非常有益的，这种服务可以被部署在有很多 CPU 的主机上。通过将资源消耗模块转换成微服务，可以使得应用易于扩展。</p><p>查找现有粗粒度边界来决定哪个模块应该被抽取，也是很有益的，这使得移植工作更容易和简单。例如，只与其他应用异步同步消息的模块就是一个明显边界，可以很简单容易地将其转换为微服务。</p><h4 id="如何抽取模块"><a href="#如何抽取模块" class="headerlink" title="如何抽取模块"></a>如何抽取模块</h4><p>抽取模块第一步就是定义好模块和单体应用之间粗粒度接口，由于单体应用需要微服务的数据，反之亦然，因此更像是一个双向 API。因为必须在负责依赖关系和细粒度接口模式之间做好平衡，因此开发这种 API  很有挑战性，尤其对使用域模型模式的业务逻辑层来说更具有挑战，因此经常需要改变代码来解决依赖性问题，如图所示：</p><p>一旦完成粗粒度接口，也就将此模块转换成独立微服务。为了实现，必须写代码使得单体应用和微服务之间通过使用进程间通信（IPC）机制的 API 来交换信息。如图所示迁移前后对比：</p><p><img src="https://doocs.gitee.io/advanced-java/docs/micro-services/images/30103116_ZCcM.png" alt="迁移前后对比"></p><p>此例中，正在使用 Y 模块的 Z 模块是备选抽取模块，其元素正在被 X 模块使用，迁移第一步就是定义一套粗粒度 APIs，第一个接口应该是被 X 模块使用的内部接口，用于激活 Z 模块；第二个接口是被 Z 模块使用的外部接口，用于激活 Y 模块。</p><p>迁移第二步就是将模块转换成独立服务。内部和外部接口都使用基于 IPC 机制的代码，一般都会将 Z 模块整合成一个微服务基础框架，来出来割接过程中的问题，例如服务发现。</p><p>抽取完模块，也就可以开发、部署和扩展另外一个服务，此服务独立于单体应用和其它服务。可以从头写代码实现服务；这种情况下，将服务和单体应用整合的 API  代码成为容灾层，在两种域模型之间进行翻译工作。每抽取一个服务，就朝着微服务方向前进一步。随着时间推移，单体应用将会越来越简单，用户就可以增加更多独立的微服务。 将现有应用迁移成微服务架构的现代化应用，不应该通过从头重写代码方式实现，相反，应该通过逐步迁移的方式。有三种策略可以考虑：将新功能以微服务方式实现；将表现层与业务数据访问层分离；将现存模块抽取变成微服务。随着时间推移，微服务数量会增加，开发团队的弹性和效率将会大大增加。</p><h2 id="微服务四大问题"><a href="#微服务四大问题" class="headerlink" title="微服务四大问题"></a>微服务四大问题</h2><blockquote><p>微服务架构问题</p><p>​    分布式架构会遇到的核心问题</p><pre><code>1. 这么多服务，客户端如何去访问（服务路由）2. 这么多服务，服务之间如何通信（异步调用）3. 这么多服务，如何治理（高可用）4. 服务挂了怎么办</code></pre></blockquote><h3 id="常见的两套解决方案"><a href="#常见的两套解决方案" class="headerlink" title="常见的两套解决方案"></a>常见的两套解决方案</h3><p><code>Spring Cloud</code>是一套生态，就是用来解决以上四个问题</p><ol><li><p><code>Spring Cloud Netflix</code> 第一套解决方案</p><p>针对第一个问题：API网关=》zuul组件</p><p>针对第二个问题：Feign=》HttpClient=》HTTP通信方式，同步并阻塞</p><p>针对第三个问题：服务注册与发现=》Eureka</p><p>针对第四个问题：熔断机制=》Hystrix</p></li><li><p><code>Apache Dubbo+Zookeeper</code> 第二套解决方案</p><p>针对第一个问题：API网关=》没有</p><p>针对第二个问题：Dubbo=》Java实现的高效RPC框架</p><p>针对第三个问题：服务注册与发现=》Zookeeper</p><p>针对第四个问题：熔断机制=》没有=&gt;借助Hystrix</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之@Import</title>
      <link href="2021/05/13/zhu-jie-import/"/>
      <url>2021/05/13/zhu-jie-import/</url>
      
        <content type="html"><![CDATA[<h2 id="Import注解的作用"><a href="#Import注解的作用" class="headerlink" title="@Import注解的作用"></a>@Import注解的作用</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>在平时看源码或者很多配置类上面都会出现@Import注解,功能就是和Spring XML 里面 的 一样. @Import注解是用来导入配置类或者一些需要前置加载的类.</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h3><h4 id="2-1-导入配置的三种类型"><a href="#2-1-导入配置的三种类型" class="headerlink" title="2.1 导入配置的三种类型"></a>2.1 导入配置的三种类型</h4><p>@Import支持 三种方式<br> 1.带有@Configuration的配置类(4.2 版本之前只可以导入配置类，4.2版本之后 也可以导入 普通类)<br> 2.ImportSelector 的实现<br> 3.ImportBeanDefinitionRegistrar 的实现</p><h4 id="2-2-源码解析"><a href="#2-2-源码解析" class="headerlink" title="2.2 源码解析"></a>2.2 源码解析</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 表示要导入的一个或多个component类，尤其是带有@Configuration的类 * Indicates one or more component classes to import; typically * @Configuration classes. * * 功能类似XML 里面的 &lt;import/> * 可以导入 @Configuration配置类，ImportSelector、ImportBeanDefinitionRegistrar 的实现 * 4.2 版本之后可以导入普通component类(类似AnnotationConfigApplicationContext#register) * &lt;p>Provides functionality equivalent to the &#123;@code &lt;import/>&#125; element in Spring XML. * Allows for importing &#123;@code @Configuration&#125; classes, &#123;@link ImportSelector&#125; and * &#123;@link ImportBeanDefinitionRegistrar&#125; implementations, as well as regular component * classes (as of 4.2; analogous to &#123;@link AnnotationConfigApplicationContext#register&#125;). * * &lt;p>&#123;@code @Bean&#125; definitions declared in imported &#123;@code @Configuration&#125; classes should be * accessed by using &#123;@link org.springframework.beans.factory.annotation.Autowired @Autowired&#125; * injection. Either the bean itself can be autowired, or the configuration class instance * declaring the bean can be autowired. The latter approach allows for explicit, IDE-friendly * navigation between &#123;@code @Configuration&#125; class methods. * 可以在类级别声明或作为元注释声明 * &lt;p>May be declared at the class level or as a meta-annotation. * 如需要引入XML或其他类型的文件，使用@ImportResource注解 * &lt;p>If XML or other non-&#123;@code @Configuration&#125; bean definition resources need to be * imported, use the &#123;@link ImportResource @ImportResource&#125; annotation instead. */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Import</span> <span class="token punctuation">&#123;</span><span class="token comment">/** * &#123;@link Configuration @Configuration&#125;, &#123;@link ImportSelector&#125;, * &#123;@link ImportBeanDefinitionRegistrar&#125;, or regular component classes to import. */</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-测试例子"><a href="#3-测试例子" class="headerlink" title="3.测试例子"></a>3.测试例子</h3><h4 id="3-1-导入普通类"><a href="#3-1-导入普通类" class="headerlink" title="3.1 导入普通类"></a>3.1 导入普通类</h4><p>1.新建一个普通类TestA</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类名:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.新建一个ImportConfig类，在类上加@Configuration，加上@Configuration是为了能让Spring 扫描到这个类，并且直接通过@Import引入TestA类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">TestA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImportConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3.测试结果</p><p>TestA 是一个普通的类，现在可以被@Autowired注释然后调用，就直接说明已经被Spring 注入并管理了，普通的类都是需要先实例化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringJUnit4ClassRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">AnnotationTestApplicationTests</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">TestA</span> testA<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        testA<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印：</p><pre class="line-numbers language-jav" data-language="jav"><code class="language-jav">类名:com.itxxj.annotationtest.TestA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-2-导入带有-Configuration的配置类"><a href="#3-2-导入带有-Configuration的配置类" class="headerlink" title="3.2 导入带有@Configuration的配置类"></a>3.2 导入带有@Configuration的配置类</h4><p>1.新建一个普通类TestB</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestB</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类名:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.在ImportConfig中直接引入TestB</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">TestA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">TestB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImportConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3.测试结果</p><p>TestB.class 的类上面已经有了@Configuration注解,本身就会被spring扫到并实例，@import引入带有@Configuration的配置文件，是需要先实例这个配置文件再进行相关操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token class-name">TestB</span> testB<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    testB<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">类名<span class="token operator">:</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>itxxj<span class="token punctuation">.</span>annotationtest<span class="token punctuation">.</span></span>TestB</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-3-通过ImportSelector方式导入类"><a href="#3-3-通过ImportSelector方式导入类" class="headerlink" title="3.3 通过ImportSelector方式导入类"></a>3.3 通过ImportSelector方式导入类</h4><p>1.新建TestC.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestC</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类名:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.新建SelfImportSelector.class 实现ImportSelector 接口,注入TestC.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelfImportSelector</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"com.itxxj.annotationtest.TestC"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.ImportConfig上面引入SelfImportSelector.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">TestA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">TestB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">SelfImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImportConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4.测试结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token class-name">TestC</span> testC<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    testC<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">类名<span class="token operator">:</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>itxxj<span class="token punctuation">.</span>annotationtest<span class="token punctuation">.</span></span>TestC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-4-通过-ImportBeanDefinitionRegistrar-方式导入的类"><a href="#3-4-通过-ImportBeanDefinitionRegistrar-方式导入的类" class="headerlink" title="3.4 通过 ImportBeanDefinitionRegistrar 方式导入的类"></a>3.4 通过 ImportBeanDefinitionRegistrar 方式导入的类</h4><p>1.新建TestD.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestD</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类名:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.新建SelfImportBeanDefinitionRegistrar.class,实现接口ImportBeanDefinitionRegistrar,注入TestD.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelfImportBeanDefinitionRegistrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RootBeanDefinition</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">TestD</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"testD"</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.ImportConfig类上加上导入SelfImportBeanDefinitionRegistrar.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">TestA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">TestB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">SelfImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">SelfImportBeanDefinitionRegistrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImportConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4.测试结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token class-name">TestD</span> testD<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    testD<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">类名<span class="token operator">:</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>itxxj<span class="token punctuation">.</span>annotationtest<span class="token punctuation">.</span></span>TestD</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-详细过程解析"><a href="#4-详细过程解析" class="headerlink" title="4.详细过程解析"></a>4.详细过程解析</h3><blockquote><pre class="line-numbers language-none"><code class="language-none">ConfigurationClassParser所在包:org.springframework.context.annotation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>这里主要看 ConfigurationClassParser.java 里面的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Process any @Import annotations</span><span class="token function">processImports</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> sourceClass<span class="token punctuation">,</span> <span class="token function">getImports</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">)</span><span class="token punctuation">,</span> filter<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//具体在311行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-1-getImport方法"><a href="#4-1-getImport方法" class="headerlink" title="4.1 getImport方法"></a>4.1 getImport方法</h4><p>在分析这个方法之前，我们先看一下 getImports 方法，这个方法就是获取所有的@import 里面的类<br>这里是获取 @import 里面的类，大致流程如下：</p><ol><li>定义一个 visited 的集合，用作 是否已经 判断过的标志</li><li>这里就是获取sourceClass 上面的 所有的 annotation，并挨个判断， 如果不是 @import ,那就 进一步递归 调用 对应的 annotation,直到全部结束</li><li>加载sourceClass 里面 的@Import annotation 里面对应的类名 ,最后返回</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Returns &#123;@code @Import&#125; class, considering all meta-annotations. */</span><span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> <span class="token function">getImports</span><span class="token punctuation">(</span><span class="token class-name">SourceClass</span> sourceClass<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> imports <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">collectImports</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">,</span> imports<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> imports<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//这里就是获取sourceClass 上面的所有的 annotation， 如果不是 @import ,那就进一步递归调用对应的 annotation,直到全部结束</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">collectImports</span><span class="token punctuation">(</span><span class="token class-name">SourceClass</span> sourceClass<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> imports<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> visited<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SourceClass</span> annotation <span class="token operator">:</span> sourceClass<span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> annName <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>annName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Import</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">collectImports</span><span class="token punctuation">(</span>annotation<span class="token punctuation">,</span> imports<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>imports<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">Import</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-processImports方法"><a href="#4-2-processImports方法" class="headerlink" title="4.2 processImports方法"></a>4.2 processImports方法</h4><p>processImports 这个方法 的代码逻辑也很清晰，流程图如下：</p><p><img src="/.io//MyBlog\source_posts\注解-@Import\1.png" alt="processImports逻辑流程"></p><p>大致的流程如下:</p><p>1.判断 importCandidates 是否为空，为空 退出</p><p>2.判断isChainedImportOnStack ，如果为true ,加入 problemReporter 里面的error ，并退出</p><p>3.把当前的 configClass 加入到 ImportStack里面，ImportStack 是继承了 ArrayDeque // TODO 和实现了 ImportRegistry// TODO</p><p>4.对 getImports 里面获取到的 需要import 的类 进行遍历 处理</p><blockquote><p>4.1 如果是 ImportSelector 类型，首先实例一个 ImportSelector 对象，然后 对其进行 Aware 扩展(如果 实现了 Aware 接口)</p><p>4.1.2 进一步判断 是否 是 DeferredImportSelector 类型，如果是 ，加入到 deferredImportSelectors 里面，最后处理 ，这里可以看一下 方法parse(Set configCandidates)， 里面最后一行才调用,这也就是 有的时候，如果想最后注入，就可以定义为deferredImportSelectors 类型</p><p>4.1.2 如果 不是 DeferredImportSelector 类型 ，那就 调用 selectImports 方法，获取到所有的需要 注入的类，这时 再次调用 processImports 方法，这里调用processImports 方法，其实 是把 这些需要注入的类当成普通的 @Configuration 处理</p></blockquote><p>5.如果是 ImportBeanDefinitionRegistrar 类型，这里也是 先实例一个对象，然后加入到 importBeanDefinitionRegistrars 里面，后续 会在 ConfigurationClassBeanDefinitionReader 这个类里面 的 loadBeanDefinitionsFromRegistrars 方法处理的<br>6.如果上面两种类型都不是，那就是当初普通的 带有@Configuration 的类进行处理了</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> 注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之@SpringBootApplication</title>
      <link href="2021/05/13/zhu-jie-springbootapplication/"/>
      <url>2021/05/13/zhu-jie-springbootapplication/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p><code>springboot</code>与<code>spring</code>的区别有两个地方：</p><p>（1）在<code>Springboot01HelloworldApplication</code>主启动类上添加了注解<code>@SpringBootApplication</code></p><p>（2）main方法调用了<code>SpringApplication.run(Springboot01HelloworldApplication.class, args);</code></p><p>这里主要先解析第一点。</p><h3 id="2-进入主题"><a href="#2-进入主题" class="headerlink" title="2.进入主题"></a>2.进入主题</h3><p>主启动类源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot01HelloworldApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Springboot01HelloworldApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@SpringBootApplication</code>是<code>Sprnig Boot</code>项目的核心注解，目的是开启自动配置。</p><p>进入到<code>@SpringBootApplication</code>的源码，可以看到里面组合了三个我们感兴趣的注解：<code>@ComponentScan</code>,<code>@EnableAutoConfiguration</code>,<code>@SpringBootConfiguration</code>.我们一一分析这三个注解．</p><h4 id="2-1-ComponentScan"><a href="#2-1-ComponentScan" class="headerlink" title="2.1@ComponentScan"></a>2.1@ComponentScan</h4><p>使用过spring框架的小伙伴都知道，spring里有四大注解：<code>@Service</code>,<code>@Repository</code>,<code>@Component</code>,<code>@Controller</code>用来定义一个bean.<code>@ComponentScan</code>注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean．可以通过设置<code>@ComponentScan</code>　basePackages，includeFilters，excludeFilters属性来动态确定自动扫描范围．如果不设置的话，spring默认的扫描范围是<code>@ComponentScan</code>注解所在配置类包及子包的类，</p><blockquote><p>注：使用<code>@SpringBootApplication</code>注解，就说明你使用了<code>@ComponentScan</code>的默认配置，这就建议你把使用<code>@SpringBootApplication</code>注解的类放置在root package，其他类都置在root package的子包里面，这样bean就不会被漏扫描</p></blockquote><p><code>@ComponentScan</code>的参数的作用</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">basePackageClasses：对basepackages<span class="token punctuation">(</span><span class="token punctuation">)</span>指定扫描注释组件包类型安全的替代。 excludeFilters：指定不适合组件扫描的类型。 includeFilters：指定哪些类型有资格用于组件扫描。 lazyInit：指定是否应注册扫描的beans为lazy初始化。 nameGenerator：用于在Spring容器中的检测到的组件命名。 resourcePattern：控制可用于组件检测的类文件。 scopedProxy：指出代理是否应该对检测元件产生，在使用过程中会在代理风格时尚的范围是必要的。 scopeResolver：用于解决检测到的组件的范围。 useDefaultFilters：指示是否自动检测类的注释 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-SpringBootConfiguration"><a href="#2-2-SpringBootConfiguration" class="headerlink" title="2.2@SpringBootConfiguration"></a>2.2@SpringBootConfiguration</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>        annotation <span class="token operator">=</span> <span class="token class-name">Configuration</span><span class="token punctuation">.</span><span class="token keyword">class</span>    <span class="token punctuation">)</span>    <span class="token keyword">boolean</span> <span class="token function">proxyBeanMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个注解的作用与<code>@Configuration</code>作用相同，都是用来声明当前类是一个配置类．可以通过<code>＠Bean</code>注解生成IOC容器管理的bean.</p><p>例子：在<code>Springboot01HelloworldApplication</code>中定义bean，并在<code>＠HelloController</code>中注入使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot01HelloworldApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Springboot01HelloworldApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">BeanTest</span> <span class="token function">beanTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BeanTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>HelloController</code>中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">BeanTest</span> beanTest<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/test"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">beanTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> beanTest<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-EnableAutoConfiguration"><a href="#2-3-EnableAutoConfiguration" class="headerlink" title="2.3@EnableAutoConfiguration"></a>2.3@EnableAutoConfiguration</h4><p><code>@EnableAutoConfiguration</code>是springboot实现自动化配置的核心注解，通过这个注解把spring应用所需的bean注入容器中．<code>@EnableAutoConfiguration</code>源码通过<code>@Import</code>注入了一个<code>ImportSelector</code>的实现类<code>AutoConfigurationImportSelector</code>,这个<code>ImportSelector</code>最终实现根据我们的配置，动态加载所需bean.</p><p>我们首先看<code>AutoConfigurationImportSelector</code>的<code>selectImports</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> NO_IMPORTS<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//重点在getAutoConfigurationEntry方法</span>    <span class="token class-name">AutoConfigurationEntry</span> autoConfigurationEntry <span class="token operator">=</span> <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//返回需要注入的bean的类路径</span>    <span class="token keyword">return</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getAutoConfigurationEntry</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//输入参数:annotationMetadata 是＠import所用在的注解．这里指定是@EnableAutoConfiguration</span><span class="token keyword">protected</span> <span class="token class-name">AutoConfigurationEntry</span> <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> EMPTY_ENTRY<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//获取注解里设置的属性，在＠SpringBootApplication设置的exclude,excludeName属性值，其实就是设置＠EnableAutoConfiguration的这两个属性值</span><span class="token class-name">AnnotationAttributes</span> attributes <span class="token operator">=</span> <span class="token function">getAttributes</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//这里getCandidateConfigurations调用了一个核心方法SpringFactoriesLoader.loadFactoryNames</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> configurations <span class="token operator">=</span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//去掉重复项</span>configurations <span class="token operator">=</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取自己配置的不需要生成bean的class</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> exclusions <span class="token operator">=</span> <span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//校验被exclude的类是否都是springboot自动化配置里的类</span><span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//删除被exclude掉的类</span>configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//过滤刷选，满足OnClassCondition的类</span>configurations <span class="token operator">=</span> <span class="token function">getConfigurationClassFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationEntry</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getCandidateConfigurations</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">AnnotationAttributes</span> attributes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//getSpringFactoriesLoaderFactoryClass()返回的是EnableAutoConfiguration.class</span>    <span class="token comment">//getBeanClassLoader()返回的是this.beanClassLoader</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> configurations <span class="token operator">=</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> <span class="token string">"No auto configuration classes found in META-INF/spring.factories. If you "</span><span class="token operator">+</span> <span class="token string">"are using a custom packaging, make sure that file is correct."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> configurations<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>SpringFactoriesLoader.loadFactoryNames</code>方法</p><p><strong>自动配置幕后英雄：<code>SpringFactoriesLoader</code>详解</strong><br><code>SpringFactoriesLoader</code>属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件<code>META-INF/spring.factories</code>加载配置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> factoryType<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ClassLoader</span> classLoaderToUse <span class="token operator">=</span> classLoader<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>classLoaderToUse <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>classLoaderToUse <span class="token operator">=</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">String</span> factoryTypeName <span class="token operator">=</span> factoryType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">loadSpringFactories</span><span class="token punctuation">(</span>classLoaderToUse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>factoryTypeName<span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">loadSpringFactories</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";</span>            <span class="token comment">//从spring-boot-autoconfigure　jar包里面META-INF/spring.factories加载配置类的名称，打开这个文件发现里面包含了springboot框架提供的所有配置类</span><span class="token class-name">Enumeration</span><span class="token generics"><span class="token punctuation">&lt;</span>URL<span class="token punctuation">></span></span> urls <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">URL</span> url <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">UrlResource</span> resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token class-name">PropertiesLoaderUtils</span><span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> properties<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> factoryTypeName <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> factoryImplementationNames <span class="token operator">=</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> factoryImplementationName <span class="token operator">:</span> factoryImplementationNames<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>factoryTypeName<span class="token punctuation">,</span> key <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>factoryImplementationName<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将所有列表替换为包含唯一元素的不可修改列表</span>result<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token punctuation">(</span>factoryType<span class="token punctuation">,</span> implementations<span class="token punctuation">)</span> <span class="token operator">-></span> implementations<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">collectingAndThen</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token operator">::</span><span class="token function">unmodifiableList</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unable to load factories from location ["</span> <span class="token operator">+</span>FACTORIES_RESOURCE_LOCATION <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> 注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下mysql的rpm安装流程</title>
      <link href="2021/04/30/linux-xia-mysql-de-rpm-an-zhuang-liu-cheng/"/>
      <url>2021/04/30/linux-xia-mysql-de-rpm-an-zhuang-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步、前往mysql官网下载所需的版本"><a href="#第一步、前往mysql官网下载所需的版本" class="headerlink" title="第一步、前往mysql官网下载所需的版本"></a>第一步、前往mysql官网下载所需的版本</h2><blockquote><p>Mysql5.7的rpm包下载地址为<a href="https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar">https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</a></p><p>下载完成后就上传的CentOS系统上。</p></blockquote><h2 id="第二步、解压安装"><a href="#第二步、解压安装" class="headerlink" title="第二步、解压安装"></a>第二步、解压安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># mkdir mysql #创建mysql目录</span><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># tar xf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar -C mysql/ #解压至mysql目录下</span><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># yum -y install make gcc-c++ cmake bison ncurses-devel libaio libaio-devel net-tools #安装依赖包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于CentOS7（但是在CentOS8中好像没有，不过还是走一下流程)开始自带的数据库是mariadb，所以需要卸载系统中的mariadb组件，才能安装mysql的组件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># rpm -qa | grep mariadb #查看是否有mariadb</span><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># yum -y remove mariadb-libs #卸载</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在开始安装mysql，由于依赖关系，所以顺序是固定的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm </span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm</span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-libs-compat-5.7.26-1.el7.x86_64.rpm </span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm </span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm </span>在安装mysql-community-server-5.7.26-1.el7.x86_64.rpm的时候出现如下错误：error: Failed dependencies:perl<span class="token punctuation">(</span>Getopt::Long<span class="token punctuation">)</span> is needed by mysql-community-server-5.7.26-1.el7.x86_64安装perl<span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># yum -y install perl</span>又出现问题：<span class="token punctuation">[</span>/usr/lib/tmpfiles.d/mysql.conf:16<span class="token punctuation">]</span> Line references path below legacy directory /var/run/, updating /var/run/mysqld → /run/mysqld<span class="token punctuation">;</span> please update the tmpfiles.d/ drop-in <span class="token function">file</span> accordingly.解决方案：<span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># vim /usr/lib/tmpfiles.d/mysql.conf #在16行将/var/run/mysqld改为/run/mysqld</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动数据库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#启动MySQL</span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># systemctl start mysqld</span><span class="token comment">#设置为开机自启</span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># systemctl enable mysqld</span><span class="token comment">#查看MySQL运行状态，运行状态如下</span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># systemctl status mysqld</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时MySQL已经正常运行，不过要想进入MySQL还得找出此时root用户的密码，通过以下命令可以在日志文件中找出密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># grep "password" /var/log/mysqld.log</span><span class="token number">2021</span>-04-28T08:44:07.870764Z <span class="token number">1</span> <span class="token punctuation">[</span>Note<span class="token punctuation">]</span> A temporary password is generated <span class="token keyword">for</span> root@localhost: J_<span class="token punctuation">;</span>TswJ<span class="token operator">&amp;</span>P3Xx <span class="token comment">#J_;TswJ&amp;P3Xx就是密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如下命令登录数据库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># mysql -uroot -p</span>Enter password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库，如下命令修改密码：</p><pre class="line-numbers language-mys" data-language="mys"><code class="language-mys">mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中‘new password’替换成你要设置的密码，注意:密码设置必须要<strong>大小写字母数字和特殊符号（,/‘;:等）</strong>,不然不能配置成功。</p><pre class="line-numbers language-my" data-language="my"><code class="language-my">mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Root28.&#x2F;&#39;;Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果出现如下错误：</p><pre class="line-numbers language-mysq" data-language="mysq"><code class="language-mysq">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是因为密码的复杂度不符合默认规定(还是需要先修改密码成功后)，如下命令查看mysql默认密码复杂度：</p><pre class="line-numbers language-mysq" data-language="mysq"><code class="language-mysq">mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;+--------------------------------------+--------+| Variable_name                        | Value  |+--------------------------------------+--------+| validate_password_check_user_name    | OFF    || validate_password_dictionary_file    |        || validate_password_length             | 8      || validate_password_mixed_case_count   | 1      || validate_password_number_count       | 1      || validate_password_policy             | MEDIUM || validate_password_special_char_count | 1      |+--------------------------------------+--------+7 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如需修改密码复杂度参考如下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">></span> <span class="token builtin class-name">set</span> global <span class="token assign-left variable">validate_password_policy</span><span class="token operator">=</span>LOW<span class="token punctuation">;</span> <span class="token comment">#修改验证策略</span>Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> SHOW VARIABLES LIKE <span class="token string">'validate_password%'</span><span class="token punctuation">;</span>+--------------------------------------+-------+<span class="token operator">|</span> Variable_name                        <span class="token operator">|</span> Value <span class="token operator">|</span>+--------------------------------------+-------+<span class="token operator">|</span> validate_password_check_user_name    <span class="token operator">|</span> OFF   <span class="token operator">|</span><span class="token operator">|</span> validate_password_dictionary_file    <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">|</span> validate_password_length             <span class="token operator">|</span> <span class="token number">8</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_mixed_case_count   <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_number_count       <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_policy             <span class="token operator">|</span> LOW   <span class="token operator">|</span> <span class="token comment">#修改为LOW后就只验证密码的长度了</span><span class="token operator">|</span> validate_password_special_char_count <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span>+--------------------------------------+-------+<span class="token number">7</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token builtin class-name">set</span> global <span class="token assign-left variable">validate_password_length</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">#修改密码验证的长度</span>Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> SHOW VARIABLES LIKE <span class="token string">'validate_password%'</span><span class="token punctuation">;</span>+--------------------------------------+-------+<span class="token operator">|</span> Variable_name                        <span class="token operator">|</span> Value <span class="token operator">|</span>+--------------------------------------+-------+<span class="token operator">|</span> validate_password_check_user_name    <span class="token operator">|</span> OFF   <span class="token operator">|</span><span class="token operator">|</span> validate_password_dictionary_file    <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">|</span> validate_password_length             <span class="token operator">|</span> <span class="token number">4</span>     <span class="token operator">|</span> <span class="token comment">#密码长度验证修改成功</span><span class="token operator">|</span> validate_password_mixed_case_count   <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_number_count       <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_policy             <span class="token operator">|</span> LOW   <span class="token operator">|</span><span class="token operator">|</span> validate_password_special_char_count <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span>+--------------------------------------+-------+<span class="token number">7</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时再修改你想要的简单密码</p><pre class="line-numbers language-mys" data-language="mys"><code class="language-mys">mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第三步、开启mysql远程访问"><a href="#第三步、开启mysql远程访问" class="headerlink" title="第三步、开启mysql远程访问"></a>第三步、开启mysql远程访问</h2><p>执行以下命令开启远程访问限制</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select user,host from user;+---------------+---------------+| user          | host          |+---------------+---------------+| root          | 39.106.63.239 || mysql.session | localhost     || mysql.sys     | localhost     || root          | localhost     |+---------------+---------------+4 rows in set (0.00 sec)mysql&gt; update user set host&#x3D;&#39;%&#39; where user&#x3D;&#39;root&#39;;ERROR 1062 (23000): Duplicate entry &#39;%-root&#39; for key &#39;PRIMARY&#39; #虽然报错了，但是查看mysql表发现修改成功了mysql&gt; select user,host from user;+---------------+---------------+| user          | host          |+---------------+---------------+| root          | %             || root          | 39.106.63.239 || mysql.session | localhost     || mysql.sys     | localhost     |+---------------+---------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再输入下面两行命令</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; flush privileges;mysql&gt; quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第四步、开启防火墙端口"><a href="#第四步、开启防火墙端口" class="headerlink" title="第四步、开启防火墙端口"></a>第四步、开启防火墙端口</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --list-ports #查看已经开启的端口</span><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --permanent --add-port=3306/tcp #开放3306端口</span><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --reload #添加端口后，需要重新加载</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="第五步、更改mysql的语言"><a href="#第五步、更改mysql的语言" class="headerlink" title="第五步、更改mysql的语言"></a>第五步、更改mysql的语言</h2><p>首先重新登录mysql，然后输入status：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; status--------------mysql  Ver 14.14 Distrib 5.7.26, for Linux (x86_64) using  EditLine wrapperConnection id:2Current database:Current user:root@localhostSSL:Not in useCurrent pager:stdoutUsing outfile:&#39;&#39;Using delimiter:;Server version:5.7.26 MySQL Community Server (GPL)Protocol version:10Connection:Localhost via UNIX socketServer characterset:latin1  #不是utf-8Db     characterset:latin1  #不是utf-8Client characterset:utf8Conn.  characterset:utf8UNIX socket:&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sockUptime:46 secThreads: 1  Questions: 5  Slow queries: 0  Opens: 105  Flush tables: 1  Open tables: 98  Queries per second avg: 0.108--------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，Server和Db不是utf-8，修改为utf8即可。</p><p>因此我们先退出mysql，然后再到/etc目录下的my.cnf文件下修改一下文件内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># vim /etc/my.cnf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">[client] #新增代码default-character-set&#x3D;utf8 #新增代码# For advice on how to change settings please see# http:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;server-configuration-defaults.html[mysqld]## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size &#x3D; 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size &#x3D; 128M# sort_buffer_size &#x3D; 2M# read_rnd_buffer_size &#x3D; 2Mdatadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysqlsocket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sockcharacter-set-server&#x3D;utf8 #新增代码collation-server&#x3D;utf8_general_ci #新增代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存更改后的my.cnf文件后，重启下mysql，然后输入status再次查看，你就会发现变化啦</p><pre class="line-numbers language-mys" data-language="mys"><code class="language-mys">[root@xiaoxiangjie ~]# service mysqld restartRedirecting to &#x2F;bin&#x2F;systemctl restart mysqld.service[root@xiaoxiangjie ~]# mysql -uroot -pEnter password: mysql&gt; status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>至此安装完毕</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客（2）</title>
      <link href="2021/04/24/hexo-da-jian-bo-ke-2/"/>
      <url>2021/04/24/hexo-da-jian-bo-ke-2/</url>
      
        <content type="html"><![CDATA[<h2 id="用github作为远程服务器搭建博客"><a href="#用github作为远程服务器搭建博客" class="headerlink" title="用github作为远程服务器搭建博客"></a>用github作为远程服务器搭建博客</h2><p>创建一个与GitHub账号名一样名字的仓库，我的是ciyaduxingxia</p><p>开启gitpage功能，那么就能通过ciyaduxingxia.github.io访问了</p><p>记住本地要安装git部署插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm <span class="token function">install</span> --save hexo-deployer-git <span class="token comment">#在blog目录下安装git部署插件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="在本地配置远程服务器地址"><a href="#在本地配置远程服务器地址" class="headerlink" title="在本地配置远程服务器地址"></a>在本地配置远程服务器地址</h2><p>打开博客根目录下的_config.yml文件</p><p>远端服务器配置如下修改如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:type: <span class="token function">git</span>repo: git@github.com:ciyaduxingxia/ciyaduxingxia.github.io.gitbranch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：repository不要写成git clone的https的地址</p><p>错误写法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repository: https://github.com/ciyaduxingxia/ciyaduxingxia.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="下载主题并配置"><a href="#下载主题并配置" class="headerlink" title="下载主题并配置"></a>下载主题并配置</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git themes <span class="token comment">#下载hexo-theme-matery主题到本地的themes文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改hexo根目录下的 _config.yml 文件 ： theme: hexo-theme-matery</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo c<span class="token comment">#清理一下</span>hexo g<span class="token comment">#生成</span>hexo d<span class="token comment">#部署到远程Github仓库</span>https://ciyaduxingxia.github.io/  <span class="token comment">#查看博客</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客（1）</title>
      <link href="2021/04/24/hexo-da-jian-bo-ke-1/"/>
      <url>2021/04/24/hexo-da-jian-bo-ke-1/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>下载安装nodejs</p><p>通过npm配置淘宝源 cnpm</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g cnpm --registry<span class="token operator">=</span>https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看cnpm版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>通过cnpm下载安装hexo</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>hexo安装所在地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>Nodejs<span class="token punctuation">\</span>node_global<span class="token punctuation">\</span>node_modules<span class="token punctuation">\</span>hexo-cli<span class="token punctuation">\</span>bin<span class="token punctuation">\</span>hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>创建一个自己博客所在的文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>Myblog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过hexo初始化一个博客</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过hexo server 命令启动服务，默认是在</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://localhost:4000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
