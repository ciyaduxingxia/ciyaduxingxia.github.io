<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTPS之ECDHE算法详解</title>
      <link href="2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/"/>
      <url>2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTPS之ECDHE算法详解"><a href="#HTTPS之ECDHE算法详解" class="headerlink" title="HTTPS之ECDHE算法详解"></a>HTTPS之ECDHE算法详解</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>HTTPS 常用的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法。</p><p>其中，RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。</p><p>上一篇以RSA算法为基础讲解了TLS的握手流程，今天将介绍ECDHE算法。</p><h3 id="2-离散对数"><a href="#2-离散对数" class="headerlink" title="2.离散对数"></a>2.离散对数</h3><p>ECDHE 密钥协商算法是 DH 算法演进过来的，所以我们先从 DH 算法说起。</p><p>DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是<strong>离散对数</strong>。</p><p>对数运算的取值是可以连续的，而离散对数的取值是不能连续的，因此也以「离散」得名，离散对数是在对数运算的基础上加了「模运算」，离散对数的概念如下图：</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/1" class title="图片"><p>底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。也就说正向运算很容易，逆向运算很难。</p><p><strong>特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。</strong></p><h3 id="3-DH算法"><a href="#3-DH算法" class="headerlink" title="3.DH算法"></a>3.DH算法</h3><p>认识了离散对数，我们来看看 DH 算法是如何密钥交换的。</p><p>现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 P 和 G 来代称。</p><p>然后小红和小明各自生成一个随机整数作为<strong>私钥</strong>，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。</p><p>现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出<strong>公钥</strong>：</p><ul><li>小红的公钥记作 A，A = G ^ a ( mod P )；</li><li>小明的公钥记作 B，B = G ^ b ( mod P )；</li></ul><p>A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。</p><p>双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。</p><p>然后小红执行运算：B ^ a ( mod P )，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算：A ^ b ( mod P )，得到的结果也是 K。</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/2" class title="图片"><p>这个 K 就是小红和小明之间用的<strong>对称加密密钥</strong>，可以作为会话密钥使用。</p><p>可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。</p><p>前面也多次强调， 根据离散对数的原理，如果 P 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 a、b 的，破解不出私钥，也就无法计算出会话密钥，因此 DH 密钥交换是安全的。</p><h3 id="4-DHE算法"><a href="#4-DHE算法" class="headerlink" title="4.DHE算法"></a>4.DHE算法</h3><p>根据私钥生成的方式，DH 算法分为两种实现：</p><ul><li>static DH 算法，这个是已经被废弃了；</li><li>DHE 算法，现在常用的；</li></ul><p>static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。</p><p>于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 <strong>static DH 算法不具备前向安全性</strong>。</p><p>既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。</p><p>所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为<strong>每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」</strong>。</p><h3 id="5-ECDHE算法"><a href="#5-ECDHE算法" class="headerlink" title="5.ECDHE算法"></a>5.ECDHE算法</h3><p>DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。</p><p>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p><p>小红和小明使用 ECDHE 密钥交换算法的过程：</p><ul><li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；</li><li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li><li>双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li></ul><p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p><h3 id="6-ECDHE握手过程"><a href="#6-ECDHE握手过程" class="headerlink" title="6.ECDHE握手过程"></a>6.ECDHE握手过程</h3><p>知道了 ECDHE 算法基本原理后，我们就结合实际的情况来看看。 </p><p>我用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/3" class title="图片"><p>细心的小伙伴应该发现了，<strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据</strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。</p><p>所以，<strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间</strong>，这个有点「抢跑」的意思，它被称为是「<em>TLS False Start</em>」，跟「<em>TCP Fast Open</em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。</p><p>接下来，分析每一个 ECDHE 握手过程。</p><h4 id="a-TLS第一次握手"><a href="#a-TLS第一次握手" class="headerlink" title="a TLS第一次握手"></a>a TLS第一次握手</h4><p>客户端首先会发一个「<strong>Client Hello</strong>」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（*Client Random*）</strong>。</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/4" class title="图片"><h4 id="b-TLS第二次握手"><a href="#b-TLS第二次握手" class="headerlink" title="b TLS第二次握手"></a>b TLS第二次握手</h4><p>服务端收到客户端的「打招呼」，同样也要回礼，会返回「<strong>Server Hello</strong>」消息，消息面有服务器确认的 TLS 版本号，也给出了一个<strong>随机数（*Server Random*）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/5" class title="图片"><p>不过，这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思。</p><p>「 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384」</p><ul><li>密钥协商算法使用 ECDHE；</li><li>签名算法使用 RSA；</li><li>握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；</li><li>摘要算法使用 SHA384；</li></ul><p>接着，服务端为了证明自己的身份，发送「<strong>Certificate</strong>」消息，会把证书也发给客户端。</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/6" class title="图片"><p>这一步就和 RSA 握手过程有很大到区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「<strong>Server Key Exchange</strong>」消息。</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/7" class title="图片"><p>这个过程服务器做了三件事：</p><ul><li>选择了<strong>名为 named_curve 的椭圆曲线</strong>，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；</li><li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li><li>根据基点 G 和私钥计算出<strong>服务端的椭圆曲线公钥</strong>，这个会公开给客户端。</li></ul><p><strong>为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名</strong>。</p><p>随后，就是「<strong>Server Hello Done</strong>」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/8" class title="图片"><p>至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：<strong>Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥</strong>，这几个信息很重要，是后续生成会话密钥的材料。</p><h4 id="c-TLS第三次握手"><a href="#c-TLS第三次握手" class="headerlink" title="c TLS第三次握手"></a>c TLS第三次握手</h4><p>客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书到过程，会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。</p><p>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成<strong>客户端的椭圆曲线公钥</strong>，然后用「<strong>Client Key Exchange</strong>」消息发给服务端。</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/9" class title="图片"><p>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，<strong>但实际应用中，x 还不是最终的会话密钥</strong>。</p><p>还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？</p><p><strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的</strong>。</p><p>之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算出最终的会话密钥，安全性更高。</p><p>算好会话密钥后，客户端会发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端后续改用对称算法加密通信。</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/10" class title="图片"><p>接着，客户端会发「<strong>Encrypted Handshake Message</strong>」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。</p><img src="/2021/08/08/https-zhi-ecdhe-suan-fa-xiang-jie/11" class title="图片"><h4 id="d-TLS第四次握手"><a href="#d-TLS第四次握手" class="headerlink" title="d TLS第四次握手"></a>d TLS第四次握手</h4><p>最后，服务端也会有一个同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>RSA 和 ECDHE 握手过程的区别：</p><ul><li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li><li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间；</li><li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
          <category> ECDHE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> ECDHE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS之TLS握手过程</title>
      <link href="2021/08/07/https-zhi-tls-wo-shou-guo-cheng/"/>
      <url>2021/08/07/https-zhi-tls-wo-shou-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTPS之TLS握手过程"><a href="#HTTPS之TLS握手过程" class="headerlink" title="HTTPS之TLS握手过程"></a>HTTPS之TLS握手过程</h2><h3 id="1-TLS握手的流程"><a href="#1-TLS握手的流程" class="headerlink" title="1. TLS握手的流程"></a>1. TLS握手的流程</h3><p>可见，有了 TLS 协议，能保证 HTTP 通信是安全的了，那么在进行 HTTP 通信前，需要先进行 TLS 握手。TLS 的握手过程，如下图：</p><img src="/2021/08/07/https-zhi-tls-wo-shou-guo-cheng/1" alt="图片" style="zoom: 50%;"><p>上图简要概述来 TLS 的握手过程，其中每一个「框」都是一个记录（<em>record</em>），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以<strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p><p>所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p><p>传统的 TLS 握手基本都是使用<code>RSA</code>算法来实现密钥交换的，对应上图的流程图，下图是详细的过程图。</p><img src="/2021/08/07/https-zhi-tls-wo-shou-guo-cheng/2" class title="RSA流程"><h3 id="2-TLS的第一次握手"><a href="#2-TLS的第一次握手" class="headerlink" title="2. TLS的第一次握手"></a>2. TLS的第一次握手</h3><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做<code>ClientHello</code>请求。</p><p>在这一步，客户端主要向服务器提供以下信息。</p><blockquote><p>（1） 浏览器支持的SSL/TLS协议版本，比如TLS 1.0版。</p><p>（2） 一个浏览器客户端生成的随机数（Client Random），会被服务端保留，稍后用于生成对称加密算法的”对话密钥”。</p><p>（3） 浏览器支持的各种加密方法，对称的，非对称的，HASH算法。比如RSA非对称加密算法，DES对称加密算法，SHA-1 hash算法。</p><p>（4） 浏览器支持的压缩方法。</p></blockquote><img src="/2021/08/07/https-zhi-tls-wo-shou-guo-cheng/3" class title="抓包图"><p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p><p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个<a href="http://tools.ietf.org/html/rfc4366">Server Name Indication扩展</a>，允许客户端向服务器提供它所请求的域名。</p><h3 id="3-TLS的第二次握手"><a href="#3-TLS的第二次握手" class="headerlink" title="3. TLS的第二次握手"></a>3. TLS的第二次握手</h3><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（Server Random）</strong>。</p><p>接着，返回「<strong>Server Hello</strong>」消息，在这一步，服务器主要向客户端提供以下信息。</p><blockquote><p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p><p>（2） 一个服务器生成的随机数，稍后用于生成对称加密算法的”对话密钥”。</p><p>（3） 确认使用的密码套件，是从客户端的密码套件列表选择的一个合适的密码套件。</p><p>（4） 服务器证书。</p></blockquote><img src="/2021/08/07/https-zhi-tls-wo-shou-guo-cheng/4" class title="抓包图"><p>可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。</p><p>这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：</p><ul><li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li><li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li><li>摘要算法 SHA256 用于消息认证和产生随机数；</li></ul><p>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。</p><p>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。</p><p>然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p><img src="/2021/08/07/https-zhi-tls-wo-shou-guo-cheng/5" class title="抓包图"><p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p><h3 id="4-TLS的第三次握手"><a href="#4-TLS的第三次握手" class="headerlink" title="4. TLS的第三次握手"></a>4. TLS的第三次握手</h3><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>客户端验证完证书后，认为可信则继续往下走。</p><p>然后，服务器会发送下面三项信息：</p><blockquote><p>（1） 一个随机数(pre-master)。该随机数用服务器发来的公钥进行的使用非对称加密算法加密，防止被窃听。</p><p>（2） 编码改变通知（Change Cipher Spec），表示随后的信息都将用双方商定的加密方法和密钥发送。</p><p>（3） 客户端握手结束通知（Encrypted Handshake Message（Finishd）），表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote><p>客户端就会生成一个新的<strong>随机数 (pre-master)<strong>，用服务器的 RSA 公钥加密该随机数，通过「</strong>Change Cipher Key Exchange</strong>」消息传给服务端。</p><img src="/2021/08/07/https-zhi-tls-wo-shou-guo-cheng/6" class title="抓包图"><p>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。</p><p>至此，<strong>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</strong>。</p><p>于是，双方根据已经得到的三个随机数，通过密钥导出器生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。</p><p>生成完会话密钥后，然后客户端发一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。</p><img src="/2021/08/07/https-zhi-tls-wo-shou-guo-cheng/7" class title="抓包图"><p>然后，客户端再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。</p><img src="/2021/08/07/https-zhi-tls-wo-shou-guo-cheng/8" class title="抓包图"><p>可以发现，「<strong>Change Cipher Spec</strong>」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p><blockquote><p>为什么一定要用三个随机数来生成“会话密钥”？</p><blockquote><p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master  secret就有可能被猜出来，那么仅采用pre master  secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master  secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p></blockquote></blockquote><h3 id="5-TLS的第四次握手"><a href="#5-TLS的第四次握手" class="headerlink" title="5. TLS的第四次握手"></a>5. TLS的第四次握手</h3><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的对称加密算法的”会话密钥”。然后，向客户端最后发送下面信息。</p><blockquote><p>（1）编码改变通知（Change Cipher Spec），表示随后的信息都将用双方商定的对称加密算法和密钥进行加密。</p><p>（2）服务器握手结束通知（Encrypted Handshake Message），表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><h3 id="6-RSA算法的缺陷"><a href="#6-RSA算法的缺陷" class="headerlink" title="6. RSA算法的缺陷"></a>6. RSA算法的缺陷</h3><p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了（私钥很重要），过去被第三方截获的所有 TLS 通讯密文都会被破解。</p><p>为了解决这一问题，于是就有了 DH 密钥协商算法，这里简单介绍它的工作流程。</p><img src="/2021/08/07/https-zhi-tls-wo-shou-guo-cheng/9" class title="DH算法流程"><p>客户端和服务端各自会生成随机数，并以此作为私钥，然后根据公开的 DH 计算公式算出各自的公钥，通过 TLS 握手双方交换各自的公钥，这样双方都有自己的私钥和对方的公钥，然后双方根据各自持有的材料算出一个随机数，这个随机数的值双方都是一样的，这就可以作为后续对称加密时使用的密钥。</p><p>DH 密钥交换过程中，<strong>即使第三方截获了 TLS 握手阶段传递的公钥，在不知道的私钥的情况下，也是无法计算出密钥的，而且每一次对称加密密钥都是实时生成的，实现前向保密</strong>。</p><p>但因为 DH 算法的计算效率问题，后面出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。</p><p>下一篇博客将讲解DH和ECDHE算法。</p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
          <category> TLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS之加密原理详解</title>
      <link href="2021/08/07/https-zhi-jia-mi-yuan-li/"/>
      <url>2021/08/07/https-zhi-jia-mi-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTPS之加密原理详解"><a href="#HTTPS之加密原理详解" class="headerlink" title="HTTPS之加密原理详解"></a>HTTPS之加密原理详解</h2><p>上一篇博客我们在讲MD5时在文章的开头介绍了三种类型的加密算法：对称加密算法、非对称加密算法、HASH算法。</p><p>今天我们要讲的HTTPS加密用到了上面全部的三种算法。</p><h3 id="1-HTTPS的作用"><a href="#1-HTTPS的作用" class="headerlink" title="1. HTTPS的作用"></a>1. HTTPS的作用</h3><p>HTTPS简单而言，即使建立在SSL/TLS协议之上的HTTP。不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><blockquote><p>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p><p>（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p><p>（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p></blockquote><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><blockquote><p>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。</p><p>（2） 具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</p><p>（3） 配备<strong>身份证书</strong>，防止身份被冒充。</p></blockquote><h3 id="2-什么是对称加密"><a href="#2-什么是对称加密" class="headerlink" title="2. 什么是对称加密"></a>2. 什么是对称加密</h3><p>就是<strong>加密和解密使用同一个密钥的加密算法</strong>。因为加密方和解密方使用的密钥相同，所以称为称为对称加密，也称为单钥加密方法。</p><img src="/2021/08/07/https-zhi-jia-mi-yuan-li/types-of-encryption-symmetric-encryption.png" class title="对称加密"><p><strong>使用对称加密可行吗</strong>？</p><p><strong>如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。</strong></p><p>然而最大的问题就是<strong>这个密钥怎么让传输的双方知晓，同时不被别人知道</strong>。如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥被别人劫持到手了怎么办？之后他就能用密钥解开双方传输的任何内容了，所以这么做当然不行。</p><p>换种思路？试想一下，如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行了！这么做显然不现实。<br>怎么办？所以我们就需要<code>非对称加密</code> 。</p><h3 id="3-什么是非对称加密"><a href="#3-什么是非对称加密" class="headerlink" title="3. 什么是非对称加密"></a>3. 什么是非对称加密</h3><p>简单说就是有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。</p><img src="/2021/08/07/https-zhi-jia-mi-yuan-li/types-of-encryption-asymmetric-encryption.png" class title="非对称加密"><p><strong>使用非对称加密可行吗？</strong></p><p>鉴于非对称加密的机制，我们可能会有这种思路：服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！<strong>因为只有服务器有相应的私钥能解开公钥加密的数据</strong>。</p><p>然而反过来<strong>由服务器到浏览器的这条路怎么保障安全？</strong>如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。所以<strong>目前似乎只能保证由浏览器向服务器传输数据的安全性</strong>（其实仍有漏洞，下文会说），那利用这点你能想到什么解决方案吗？</p><p><strong>改良的非对称加密方案，似乎可以？</strong></p><p>我们已经理解通过一组公钥私钥，可以保证单个方向传输的安全性，那用两组公钥私钥，是否就能保证双向传输都安全了？请看下面的过程：</p><ol><li>某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。</li><li>浏览器把公钥B明文传输给服务器。</li><li>服务器把公钥A明文给传输浏览器。</li><li>之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。</li><li>同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。</li></ol><p>的确可以！抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？很重要的原因是非对称加密算法非常耗时，而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的漏洞？</p><blockquote><h2 id="漏洞-–-gt-RSA"><a href="#漏洞-–-gt-RSA" class="headerlink" title="漏洞 –&gt;RSA"></a>漏洞 –&gt;RSA</h2><p>　　加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举2个例子说明。</p><p>　　第一个场景：战场上，B要给A传递一条消息，内容为某一指令。</p><p>　　RSA的加密过程如下：</p><p>　　（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p><p>　　（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。</p><p>　　（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。</p><p> 　在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</p><p>　　第二个场景：A收到B发的消息后，需要进行回复“收到”。</p><p>　　RSA签名的过程如下：</p><p>　　（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</p><p>　　（2）A用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给B。</p><p>　　（3）B收到消息后，在获取A的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是A回复的。</p><p> 　在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。</p><p>​     但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如A和B都有一套自己的公钥和私钥，当A要给B发送消息时，先用B的公钥对消息加密，再对加密的消息使用A的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。</p><p> 　总结：公钥加密、私钥解密、私钥签名、公钥验签。</p></blockquote><h3 id="3-非对称加密-对称加密"><a href="#3-非对称加密-对称加密" class="headerlink" title="3. 非对称加密+对称加密"></a>3. 非对称加密+对称加密</h3><p>既然非对称加密耗时，那非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，且非对称加密、解密各只需用一次即可。<br>请看一下这个过程：</p><ol><li>某网站拥有用于非对称加密的公钥A、私钥A’。</li><li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</li><li>服务器拿到后用私钥A’解密得到密钥X。</li><li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。</li></ol><p>完美！HTTPS基本就是采用了这种方案。完美？还是有漏洞的。</p><h3 id="4-中间人攻击"><a href="#4-中间人攻击" class="headerlink" title="4. 中间人攻击"></a>4. 中间人攻击</h3><p>如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它，然而中间人却完全不需要拿到私钥A’就能干坏事了。请看：</p><img src="/2021/08/07/https-zhi-jia-mi-yuan-li/mitm.png" class title="中间人攻击"><ol><li>某网站有用于非对称加密的公钥A、私钥A’。</li><li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li><strong>中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）</strong>。</li><li>浏览器生成一个用于对称加密的密钥X，用<strong>公钥B</strong>（浏览器无法得知公钥被替换了）加密后传给服务器。</li><li><strong>中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器</strong>。</li><li>服务器拿到后用私钥A’解密得到密钥X。</li></ol><p>这样在双方都不会发现异常的情况下，中间人通过一套“狸猫换太子”的操作，掉包了服务器传来的公钥，进而得到了密钥X。<strong>根本原因是浏览器无法确认收到的公钥是不是网站自己的，</strong>因为公钥本身是明文传输的，难道还得对公钥的传输进行加密？这似乎变成鸡生蛋、蛋生鸡的问题了。解法是什么？</p><h3 id="5-数字证书"><a href="#5-数字证书" class="headerlink" title="5. 数字证书"></a>5. 数字证书</h3><p>其实所有证明的源头都是一条或多条不证自明的“公理”（可以回想一下数学上公理），由它推导出一切。比如现实生活中，若想证明某身份证号一定是小明的，可以看他身份证，而身份证是由政府作证的，这里的“公理”就是“政府机构可信”，这也是社会正常运作的前提。</p><p>那能不能类似地有个机构充当互联网世界的“公理”呢？让它作为一切证明的源头，给网站颁发一个“身份证”？</p><p>它就是<strong>CA机构</strong>，它是如今互联网世界正常运作的前提，而CA机构颁发的“身份证”就是<strong>数字证书</strong>。</p><p>网站在使用HTTPS前，需要向<strong>CA机构</strong>申领一份<strong>数字证书</strong>，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。而这里又有一个显而易见的问题，“<strong>证书本身的传输过程中，如何防止被篡改”</strong>？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？解决这个问题我们就接近胜利了！</p><h4 id="1-如何防止数字证书被篡改"><a href="#1-如何防止数字证书被篡改" class="headerlink" title="1. 如何防止数字证书被篡改"></a>1. 如何防止数字证书被篡改</h4><p>我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫<code>数字签名</code>：</p><p>图中左侧是数字签名的制作过程，右侧是验证过程：</p><img src="/2021/08/07/https-zhi-jia-mi-yuan-li/how-do-digital-signatures-and-digital-certificates-work-together-in-ssl.png" class title="数字证书加密"><p>数字签名的制作过程：</p><ol><li>CA机构拥有<code>非对称加密的私钥和公钥</code>。</li><li>CA机构对证书明文数据T进行hash。</li><li>对hash后的值用私钥加密，得到数字签名S。</li></ol><p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。<br>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p><p>浏览器验证过程：</p><ol><li>拿到证书，得到明文T，签名S。</li><li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li><li>用证书里指明的hash算法对明文T进行hash得到T’。</li><li>显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。</li></ol><p>为何么这样可以保证证书可信呢？我们来仔细想一下。</p><h4 id="2-中间人有可能篡改证书吗"><a href="#2-中间人有可能篡改证书吗" class="headerlink" title="2. 中间人有可能篡改证书吗"></a>2. 中间人有可能篡改证书吗</h4><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以没办法把修改后的证书进行加密，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p><p>既然不可能篡改，那整个证书被掉包呢？</p><h4 id="3-中间人有可能把证书掉包吗"><a href="#3-中间人有可能把证书掉包吗" class="headerlink" title="3. 中间人有可能把证书掉包吗"></a>3. 中间人有可能把证书掉包吗</h4><p>假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？</p><p>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p><h4 id="4-为什么制作数字签名的时候要hash一次"><a href="#4-为什么制作数字签名的时候要hash一次" class="headerlink" title="4. 为什么制作数字签名的时候要hash一次"></a>4. 为什么制作数字签名的时候要hash一次</h4><p>似乎那里的hash有点多余，把hash过程去掉也能保证证书没有被篡改。</p><p>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。</p><h4 id="5-如何保证CA机构的公钥是可信的"><a href="#5-如何保证CA机构的公钥是可信的" class="headerlink" title="5. 如何保证CA机构的公钥是可信的"></a>5. 如何保证CA机构的公钥是可信的</h4><p>你们可能会发现上文中说到CA机构的公钥，我几乎一笔带过，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？</p><p>让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站”，那CA机构的公钥是否也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。</p><p>实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做<code>信任链</code>或<code>数字证书链</code>。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。</p><p>另外，不知你们是否遇到过网站访问不了、提示需安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么你就得手动下载安装该机构的根证书（风险自己承担XD）。安装后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。</p><h4 id="6-每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗"><a href="#6-每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗" class="headerlink" title="6. 每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗"></a>6. <strong>每次进行HTTPS请求时都</strong>必须<strong>在SSL/TLS层进行握手传输密钥吗</strong></h4><p>显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？</p><p>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session  ID下，之后浏览器每次请求都会携带session ID，服务器会根据session  ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密算法之MD5加密</title>
      <link href="2021/08/07/jia-mi-suan-fa-zhi-md5-jia-mi/"/>
      <url>2021/08/07/jia-mi-suan-fa-zhi-md5-jia-mi/</url>
      
        <content type="html"><![CDATA[<h2 id="加密算法之MD5加密"><a href="#加密算法之MD5加密" class="headerlink" title="加密算法之MD5加密"></a>加密算法之MD5加密</h2><h3 id="1-加密算法基础知识"><a href="#1-加密算法基础知识" class="headerlink" title="1. 加密算法基础知识"></a>1. 加密算法基础知识</h3><p>1）对称加密算法</p><p>就是<strong>加密和解密使用同一个密钥的加密算法</strong>。因为加密方和解密方使用的密钥相同，所以称为称为对称加密，也称为单钥加密方法。</p><p>优点是：加密和解密运算速度快，所以对称加密算法通常在消息发送方需要加密大量数据时使用；</p><p>缺点是：安全性差，如果一方的密钥遭泄露，那么整个通信就会被破解。另外加密之前双方需要同步密钥;</p><p>常用对称加密算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等;</p><p>2）非对称加密算法</p><p><strong>非对称加密算法需要两个密钥来进行加密和解密</strong>，这两个秘钥是公开密钥(public key，简称公钥)和私有密钥(private key，简称私钥)。</p><p>公钥和私钥是一对：公钥用来加密，私钥解密，而且公钥是公开的，私钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</p><p> 优点是：安全性更好，私钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</p><p>缺点是：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p><p>常用的非对称加密算法有：RSA、Elgamal、Rabin、D-H、ECC等；</p><p>3）HASH算法</p><p>也称为消息摘要算法。将任意长度的二进制值映射为较短的固定长度的二进制值，该二进制值称为哈希值。</p><p>常用于检验数据的完整性，检验数据没有被篡改过。常见的有 MD5(MD系列)，SHA-1(SHA系列)</p><p>今天介绍的MD5加密算法就属于第三种类型的算法</p><h3 id="2-MD5算法原理"><a href="#2-MD5算法原理" class="headerlink" title="2. MD5算法原理"></a>2. MD5算法原理</h3><p>输入：不定长度信息（要加密的信息）</p><p>输出：固定长度128-bits。由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><p>基本方式为：求余、取余、调整长度、与链接变量进行循环运算。得出结果。</p><p>流程图：</p><img src="/2021/08/07/jia-mi-suan-fa-zhi-md5-jia-mi/1" class title="流程图"><h4 id="1-填充"><a href="#1-填充" class="headerlink" title="1. 填充"></a>1. 填充</h4><p>在MD5算法中，首先需要对输入信息进行填充，使其位长对512求余的结果等于448，并且填充必须进行，即使其位长对512求余的结果等于448。因此，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。</p><p>填充的方法如下：</p><ol><li>在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。</li><li>在这个结果后面附加一个以64位二进制表示的**填充前信息长度(这是对原始数据没有补位前长度的描述，用二进制来表示)**，如果二进制表示的填充前信息长度超过64位，则取低64位。</li></ol><p>经过这两步的处理，信息的位长=<strong>N*512+448+64=(N+1）*512</strong>，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。因为后面的处理是512位为一组来处理输入的信息，且每一分组又被划分为16个32位子分组。</p><h4 id="2-初始化变量（变量值一般不变）"><a href="#2-初始化变量（变量值一般不变）" class="headerlink" title="2. 初始化变量（变量值一般不变）"></a>2. 初始化变量（变量值一般不变）</h4><p>MD5运算要用到一个128位的MD5缓存器，用来保存中间变量和最终结果。该缓存器又可看成是4个32位的寄存器A、B、C、D，初始化为： </p><p>A=0x01234567，</p><p>B=0x89ABCDEF，</p><p>C=0xFEDCBA98，</p><p>D=0x76543210。</p><p> （由于它们是用大端法来表示的，即每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即大端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476）</p><h4 id="3-处理分组数据"><a href="#3-处理分组数据" class="headerlink" title="3.处理分组数据"></a>3.处理分组数据</h4><p>每一分组的算法流程如下：<br>（1）第一分组需要将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。</p><p>（2）从第二分组开始的变量为上一分组的运算结果，即A = a， B = b， C = c， D = d。</p><p>主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量、文本的一个子分组和一个常数。再将所得结果向左环移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。</p><p>一个MD5运算由类似的64次循环构成，分成4组16次。</p><p>F ：一个非线性函数，一个函数运算一次</p><p>Mi ：表示一个 32-bits 的输入数据</p><p>Ki：表示一个 32-bits 常数，用来完成每次不同的计算。</p><img src="/2021/08/07/jia-mi-suan-fa-zhi-md5-jia-mi/2" class title="计算流程"><p>以下是每次操作中用到的四个非线性函数（每轮一个）。</p><pre class="line-numbers language-mathematica" data-language="mathematica"><code class="language-mathematica">F( X ,Y ,Z ) &#x3D; ( X &amp; Y ) | ( (~X) &amp; Z )G( X ,Y ,Z ) &#x3D; ( X &amp; Z ) | ( Y &amp; (~Z) )H( X ,Y ,Z ) &#x3D; X ^ Y ^ ZI( X ,Y ,Z ) &#x3D; Y ^ ( X | (~Z) )这四个函数的说明：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。函数F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。假设Mj表示消息的第j个子分组（从0到15）常数ti是4294967296*abs( sin(i) ）的整数部分，i 取值从1到64，单位是弧度。（4294967296&#x3D;2^(32)）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现定义：</p><pre class="line-numbers language-mathematica" data-language="mathematica"><code class="language-mathematica">FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a &#x3D; b + ( (a + F(b,c,d) + Mj + ti) &lt;&lt; s)GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a &#x3D; b + ( (a + G(b,c,d) + Mj + ti) &lt;&lt; s)HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a &#x3D; b + ( (a + H(b,c,d) + Mj + ti) &lt;&lt; s)II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a &#x3D; b + ( (a + I(b,c,d) + Mj + ti) &lt;&lt; s)注意：“&lt;&lt;”表示循环左移位，不是左移位。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mathematica" data-language="mathematica"><code class="language-mathematica">这四轮（共64步）是：第一轮FF(a ,b ,c ,d ,M0 ,7 ,0xd76aa478 )FF(d ,a ,b ,c ,M1 ,12 ,0xe8c7b756 )FF(c ,d ,a ,b ,M2 ,17 ,0x242070db )FF(b ,c ,d ,a ,M3 ,22 ,0xc1bdceee )FF(a ,b ,c ,d ,M4 ,7 ,0xf57c0faf )FF(d ,a ,b ,c ,M5 ,12 ,0x4787c62a )FF(c ,d ,a ,b ,M6 ,17 ,0xa8304613 )FF(b ,c ,d ,a ,M7 ,22 ,0xfd469501)FF(a ,b ,c ,d ,M8 ,7 ,0x698098d8 )FF(d ,a ,b ,c ,M9 ,12 ,0x8b44f7af )FF(c ,d ,a ,b ,M10 ,17 ,0xffff5bb1 )FF(b ,c ,d ,a ,M11 ,22 ,0x895cd7be )FF(a ,b ,c ,d ,M12 ,7 ,0x6b901122 )FF(d ,a ,b ,c ,M13 ,12 ,0xfd987193 )FF(c ,d ,a ,b ,M14 ,17 ,0xa679438e )FF(b ,c ,d ,a ,M15 ,22 ,0x49b40821 )第二轮GG(a ,b ,c ,d ,M1 ,5 ,0xf61e2562 )GG(d ,a ,b ,c ,M6 ,9 ,0xc040b340 )GG(c ,d ,a ,b ,M11 ,14 ,0x265e5a51 )GG(b ,c ,d ,a ,M0 ,20 ,0xe9b6c7aa )GG(a ,b ,c ,d ,M5 ,5 ,0xd62f105d )GG(d ,a ,b ,c ,M10 ,9 ,0x02441453 )GG(c ,d ,a ,b ,M15 ,14 ,0xd8a1e681 )GG(b ,c ,d ,a ,M4 ,20 ,0xe7d3fbc8 )GG(a ,b ,c ,d ,M9 ,5 ,0x21e1cde6 )GG(d ,a ,b ,c ,M14 ,9 ,0xc33707d6 )GG(c ,d ,a ,b ,M3 ,14 ,0xf4d50d87 )GG(b ,c ,d ,a ,M8 ,20 ,0x455a14ed )GG(a ,b ,c ,d ,M13 ,5 ,0xa9e3e905 )GG(d ,a ,b ,c ,M2 ,9 ,0xfcefa3f8 )GG(c ,d ,a ,b ,M7 ,14 ,0x676f02d9 )GG(b ,c ,d ,a ,M12 ,20 ,0x8d2a4c8a )第三轮HH(a ,b ,c ,d ,M5 ,4 ,0xfffa3942 )HH(d ,a ,b ,c ,M8 ,11 ,0x8771f681 )HH(c ,d ,a ,b ,M11 ,16 ,0x6d9d6122 )HH(b ,c ,d ,a ,M14 ,23 ,0xfde5380c )HH(a ,b ,c ,d ,M1 ,4 ,0xa4beea44 )HH(d ,a ,b ,c ,M4 ,11 ,0x4bdecfa9 )HH(c ,d ,a ,b ,M7 ,16 ,0xf6bb4b60 )HH(b ,c ,d ,a ,M10 ,23 ,0xbebfbc70 )HH(a ,b ,c ,d ,M13 ,4 ,0x289b7ec6 )HH(d ,a ,b ,c ,M0 ,11 ,0xeaa127fa )HH(c ,d ,a ,b ,M3 ,16 ,0xd4ef3085 )HH(b ,c ,d ,a ,M6 ,23 ,0x04881d05 )HH(a ,b ,c ,d ,M9 ,4 ,0xd9d4d039 )HH(d ,a ,b ,c ,M12 ,11 ,0xe6db99e5 )HH(c ,d ,a ,b ,M15 ,16 ,0x1fa27cf8 )HH(b ,c ,d ,a ,M2 ,23 ,0xc4ac5665 )第四轮II(a ,b ,c ,d ,M0 ,6 ,0xf4292244 )II(d ,a ,b ,c ,M7 ,10 ,0x432aff97 )II(c ,d ,a ,b ,M14 ,15 ,0xab9423a7 )II(b ,c ,d ,a ,M5 ,21 ,0xfc93a039 )II(a ,b ,c ,d ,M12 ,6 ,0x655b59c3 )II(d ,a ,b ,c ,M3 ,10 ,0x8f0ccc92 )II(c ,d ,a ,b ,M10 ,15 ,0xffeff47d )II(b ,c ,d ,a ,M1 ,21 ,0x85845dd1 )II(a ,b ,c ,d ,M8 ,6 ,0x6fa87e4f )II(d ,a ,b ,c ,M15 ,10 ,0xfe2ce6e0 )II(c ,d ,a ,b ,M6 ,15 ,0xa3014314 )II(b ,c ,d ,a ,M13 ,21 ,0x4e0811a1 )II(a ,b ,c ,d ,M4 ,6 ,0xf7537e82 )II(d ,a ,b ,c ,M11 ,10 ,0xbd3af235 )II(c ,d ,a ,b ,M2 ,15 ,0x2ad7d2bb )II(b ,c ,d ,a ,M9 ,21 ,0xeb86d391 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有这些完成之后，将a、b、c、d分别在原来基础上再加上A、B、C、D。<br> 即a = a + A，b = b + B，c = c + C，d = d + D<br> 然后用下一分组数据继续运行以上算法。</p><h4 id="4-输出"><a href="#4-输出" class="headerlink" title="4. 输出"></a>4. 输出</h4><p>最后的输出是a、b、c和d的级联。</p><h3 id="3-JAVA-实现代码"><a href="#3-JAVA-实现代码" class="headerlink" title="3. JAVA 实现代码"></a>3. JAVA 实现代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> MD5<span class="token punctuation">&#123;</span>    <span class="token comment">/*    *四个链接变量    */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">A</span><span class="token operator">=</span><span class="token number">0x67452301</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">B</span><span class="token operator">=</span><span class="token number">0xefcdab89</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">C</span><span class="token operator">=</span><span class="token number">0x98badcfe</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">D</span><span class="token operator">=</span><span class="token number">0x10325476</span><span class="token punctuation">;</span>    <span class="token comment">/*    *ABCD的临时变量    */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">Atemp</span><span class="token punctuation">,</span><span class="token class-name">Btemp</span><span class="token punctuation">,</span><span class="token class-name">Ctemp</span><span class="token punctuation">,</span><span class="token class-name">Dtemp</span><span class="token punctuation">;</span>         <span class="token comment">/*    *常量ti    *公式:floor(abs(sin(i+1))×(2pow32)    */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">K</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span>        <span class="token number">0xd76aa478</span><span class="token punctuation">,</span><span class="token number">0xe8c7b756</span><span class="token punctuation">,</span><span class="token number">0x242070db</span><span class="token punctuation">,</span><span class="token number">0xc1bdceee</span><span class="token punctuation">,</span>        <span class="token number">0xf57c0faf</span><span class="token punctuation">,</span><span class="token number">0x4787c62a</span><span class="token punctuation">,</span><span class="token number">0xa8304613</span><span class="token punctuation">,</span><span class="token number">0xfd469501</span><span class="token punctuation">,</span><span class="token number">0x698098d8</span><span class="token punctuation">,</span>        <span class="token number">0x8b44f7af</span><span class="token punctuation">,</span><span class="token number">0xffff5bb1</span><span class="token punctuation">,</span><span class="token number">0x895cd7be</span><span class="token punctuation">,</span><span class="token number">0x6b901122</span><span class="token punctuation">,</span><span class="token number">0xfd987193</span><span class="token punctuation">,</span>        <span class="token number">0xa679438e</span><span class="token punctuation">,</span><span class="token number">0x49b40821</span><span class="token punctuation">,</span><span class="token number">0xf61e2562</span><span class="token punctuation">,</span><span class="token number">0xc040b340</span><span class="token punctuation">,</span><span class="token number">0x265e5a51</span><span class="token punctuation">,</span>        <span class="token number">0xe9b6c7aa</span><span class="token punctuation">,</span><span class="token number">0xd62f105d</span><span class="token punctuation">,</span><span class="token number">0x02441453</span><span class="token punctuation">,</span><span class="token number">0xd8a1e681</span><span class="token punctuation">,</span><span class="token number">0xe7d3fbc8</span><span class="token punctuation">,</span>        <span class="token number">0x21e1cde6</span><span class="token punctuation">,</span><span class="token number">0xc33707d6</span><span class="token punctuation">,</span><span class="token number">0xf4d50d87</span><span class="token punctuation">,</span><span class="token number">0x455a14ed</span><span class="token punctuation">,</span><span class="token number">0xa9e3e905</span><span class="token punctuation">,</span>        <span class="token number">0xfcefa3f8</span><span class="token punctuation">,</span><span class="token number">0x676f02d9</span><span class="token punctuation">,</span><span class="token number">0x8d2a4c8a</span><span class="token punctuation">,</span><span class="token number">0xfffa3942</span><span class="token punctuation">,</span><span class="token number">0x8771f681</span><span class="token punctuation">,</span>        <span class="token number">0x6d9d6122</span><span class="token punctuation">,</span><span class="token number">0xfde5380c</span><span class="token punctuation">,</span><span class="token number">0xa4beea44</span><span class="token punctuation">,</span><span class="token number">0x4bdecfa9</span><span class="token punctuation">,</span><span class="token number">0xf6bb4b60</span><span class="token punctuation">,</span>        <span class="token number">0xbebfbc70</span><span class="token punctuation">,</span><span class="token number">0x289b7ec6</span><span class="token punctuation">,</span><span class="token number">0xeaa127fa</span><span class="token punctuation">,</span><span class="token number">0xd4ef3085</span><span class="token punctuation">,</span><span class="token number">0x04881d05</span><span class="token punctuation">,</span>        <span class="token number">0xd9d4d039</span><span class="token punctuation">,</span><span class="token number">0xe6db99e5</span><span class="token punctuation">,</span><span class="token number">0x1fa27cf8</span><span class="token punctuation">,</span><span class="token number">0xc4ac5665</span><span class="token punctuation">,</span><span class="token number">0xf4292244</span><span class="token punctuation">,</span>        <span class="token number">0x432aff97</span><span class="token punctuation">,</span><span class="token number">0xab9423a7</span><span class="token punctuation">,</span><span class="token number">0xfc93a039</span><span class="token punctuation">,</span><span class="token number">0x655b59c3</span><span class="token punctuation">,</span><span class="token number">0x8f0ccc92</span><span class="token punctuation">,</span>        <span class="token number">0xffeff47d</span><span class="token punctuation">,</span><span class="token number">0x85845dd1</span><span class="token punctuation">,</span><span class="token number">0x6fa87e4f</span><span class="token punctuation">,</span><span class="token number">0xfe2ce6e0</span><span class="token punctuation">,</span><span class="token number">0xa3014314</span><span class="token punctuation">,</span>        <span class="token number">0x4e0811a1</span><span class="token punctuation">,</span><span class="token number">0xf7537e82</span><span class="token punctuation">,</span><span class="token number">0xbd3af235</span><span class="token punctuation">,</span><span class="token number">0x2ad7d2bb</span><span class="token punctuation">,</span><span class="token number">0xeb86d391</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">/*    *向左位移数,计算方法未知    */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span>        <span class="token number">12</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>        <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span>        <span class="token number">15</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>              <span class="token comment">/*    *初始化函数    */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Atemp</span><span class="token operator">=</span><span class="token class-name">A</span><span class="token punctuation">;</span>        <span class="token class-name">Btemp</span><span class="token operator">=</span><span class="token class-name">B</span><span class="token punctuation">;</span>        <span class="token class-name">Ctemp</span><span class="token operator">=</span><span class="token class-name">C</span><span class="token punctuation">;</span>        <span class="token class-name">Dtemp</span><span class="token operator">=</span><span class="token class-name">D</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*    *移动一定位数    */</span>    <span class="token keyword">private</span>    <span class="token keyword">int</span>    <span class="token function">shift</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">(</span>a<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>a<span class="token operator">>>></span><span class="token punctuation">(</span><span class="token number">32</span><span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右移的时候，高位一定要补零，而不是补充符号位</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*    *主循环    */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token class-name">MainLoop</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">M</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> <span class="token class-name">F</span><span class="token punctuation">,</span>g<span class="token punctuation">;</span>        <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token class-name">Atemp</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token class-name">Btemp</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token class-name">Ctemp</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> d<span class="token operator">=</span><span class="token class-name">Dtemp</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">64</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">F</span><span class="token operator">=</span><span class="token punctuation">(</span>b<span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>b<span class="token punctuation">)</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>                g<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">F</span><span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>d<span class="token punctuation">)</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                g<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">16</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">F</span><span class="token operator">=</span>b<span class="token operator">^</span>c<span class="token operator">^</span>d<span class="token punctuation">;</span>                g<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">16</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token class-name">F</span><span class="token operator">=</span>c<span class="token operator">^</span><span class="token punctuation">(</span>b<span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">~</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                g<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">16</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span> tmp<span class="token operator">=</span>d<span class="token punctuation">;</span>            d<span class="token operator">=</span>c<span class="token punctuation">;</span>            c<span class="token operator">=</span>b<span class="token punctuation">;</span>            b<span class="token operator">=</span>b<span class="token operator">+</span><span class="token function">shift</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token class-name">F</span><span class="token operator">+</span><span class="token class-name">K</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token class-name">M</span><span class="token punctuation">[</span>g<span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token operator">=</span>tmp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Atemp</span><span class="token operator">=</span>a<span class="token operator">+</span><span class="token class-name">Atemp</span><span class="token punctuation">;</span>        <span class="token class-name">Btemp</span><span class="token operator">=</span>b<span class="token operator">+</span><span class="token class-name">Btemp</span><span class="token punctuation">;</span>        <span class="token class-name">Ctemp</span><span class="token operator">=</span>c<span class="token operator">+</span><span class="token class-name">Ctemp</span><span class="token punctuation">;</span>        <span class="token class-name">Dtemp</span><span class="token operator">=</span>d<span class="token operator">+</span><span class="token class-name">Dtemp</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token comment">/*    *填充函数    *处理后应满足bits≡448(mod512),字节就是bytes≡56（mode64)    *填充方式为先加一个0,其它位补零    *最后加上64位的原来长度    */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//以512位，64个字节为一组，要先加上64位，即8个字节</span>        <span class="token keyword">int</span> strByte<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>num<span class="token operator">*</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//每512分成16个，32位为一组，32位即四个字节，int</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token operator">*</span><span class="token number">16</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//全部初始化0</span>            strByte<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            strByte<span class="token punctuation">[</span>i<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">|=</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 一个整数存储四个字节，因为常见的计算机架构都是小端序，所以int也是小端法，要倒序放进去才能以小端法取出来的时候是正确的。比如stud放入int中是duts，再以小端法取出来就是stud</span>        <span class="token punctuation">&#125;</span>        strByte<span class="token punctuation">[</span>i<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">|=</span><span class="token number">0x80</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//尾部添加1</span>        <span class="token comment">/*        *添加原长度，长度指位的长度，所以要乘8，然后是小端序，所以放在倒数第二个,这里长度只用了32位        */</span>        strByte<span class="token punctuation">[</span>num<span class="token operator">*</span><span class="token number">16</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> strByte<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*    *调用函数    */</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMD5</span><span class="token punctuation">(</span><span class="token class-name">String</span> source<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> strByte<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">add</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>strByte<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">16</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//512位为一组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">16</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>strByte<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">16</span><span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">MainLoop</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">changeHex</span><span class="token punctuation">(</span><span class="token class-name">Atemp</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">changeHex</span><span class="token punctuation">(</span><span class="token class-name">Btemp</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">changeHex</span><span class="token punctuation">(</span><span class="token class-name">Ctemp</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">changeHex</span><span class="token punctuation">(</span><span class="token class-name">Dtemp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token comment">/*    *整数变成16进制字符串    */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">changeHex</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            str<span class="token operator">+=</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%2s"</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">>></span>i<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*    *单例    */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">MD5</span> instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">MD5</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">MD5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>         <span class="token keyword">private</span> <span class="token function">MD5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> str<span class="token operator">=</span>MD5<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMD5</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MD5 </category>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MD5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper原理和应用</title>
      <link href="2021/08/07/zookeeper-yuan-li/"/>
      <url>2021/08/07/zookeeper-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="zookeeper原理和应用"><a href="#zookeeper原理和应用" class="headerlink" title="zookeeper原理和应用"></a>zookeeper原理和应用</h2><h3 id="1-zookeeper是什么"><a href="#1-zookeeper是什么" class="headerlink" title="1.zookeeper是什么"></a>1.zookeeper是什么</h3><p>Zookeeper 分布式服务框架是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。这些提供的功能都是分布式系统中非常底层且必不可少的基本功能，但是如果自己实现这些功能而且要达到高吞吐、低延迟同时还要保持一致性和可用性，实际上非常困难。因此zookeeper提供了这些功能，开发者在zookeeper之上构建自己的各种分布式系统。</p><h3 id="2-zookeeper提供了什么"><a href="#2-zookeeper提供了什么" class="headerlink" title="2.zookeeper提供了什么"></a>2.zookeeper提供了什么</h3><p>简单来说，zookeeper = 文件系统 + 通知机制</p><h4 id="a-文件系统"><a href="#a-文件系统" class="headerlink" title="a 文件系统"></a>a 文件系统</h4><p>zookeeper维护一个类似文件系统的数据结构：</p><img src="/2021/08/07/zookeeper-yuan-li/0.png" class title="zookeeper结构"><p>每个子目录项如 NameService 都被称作为 znode，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。</p><p>有四种类型的znode：</p><p>1、PERSISTENT-持久化目录节点</p><p>客户端与zookeeper断开连接后，该节点依旧存在</p><p>2、 PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</p><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><p>3、EPHEMERAL-临时目录节点</p><p>客户端与zookeeper断开连接后，该节点被删除</p><p>4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</p><p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p><h4 id="b-通知机制"><a href="#b-通知机制" class="headerlink" title="b 通知机制"></a>b 通知机制</h4><p> 客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。 </p><h3 id="3-zookeeper可以用来做什么"><a href="#3-zookeeper可以用来做什么" class="headerlink" title="3.zookeeper可以用来做什么"></a>3.zookeeper可以用来做什么</h3><h4 id="a-命名服务"><a href="#a-命名服务" class="headerlink" title="a 命名服务"></a>a 命名服务</h4><p>这个似乎最简单，在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现，不见不散了。</p><h4 id="b-配置管理"><a href="#b-配置管理" class="headerlink" title="b 配置管理"></a>b 配置管理</h4><p>程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。好吧，现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好。</p><img src="/2021/08/07/zookeeper-yuan-li/1.png" class title="zookeeper简介"><h4 id="c-集群管理"><a href="#c-集群管理" class="headerlink" title="c 集群管理"></a>c 集群管理</h4><p>所谓集群管理无在乎两点：是否有机器退出和加入、选举master。</p><p>​    对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除。新机器加入也是类似，所有机器收到通知：新兄弟目录加入。</p><p>​    对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p><img src="/2021/08/07/zookeeper-yuan-li/2.png" class title="zookeeper简介"><h4 id="d-分布式锁"><a href="#d-分布式锁" class="headerlink" title="d 分布式锁"></a>d 分布式锁</h4><p>​    有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p><p>​    对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。</p><p>​    对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</p><img src="/2021/08/07/zookeeper-yuan-li/3.png" class title="zookeeper简介"><h4 id="e-队列管理"><a href="#e-队列管理" class="headerlink" title="e 队列管理"></a>e 队列管理</h4><p>两种类型的队列：</p><p>1、 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</p><p>2、队列按照 FIFO 方式进行入队和出队操作。</p><p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</p><p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。         </p><p>​     终于了解完我们能用zookeeper做什么了，可是作为一个程序员，我们总是想狂热了解zookeeper是如何做到这一点的，单点维护一个文件系统没有什么难度，可是如果是一个集群维护一个文件系统保持数据的一致性就非常困难了。</p><h3 id="4-zookeeper设计原理"><a href="#4-zookeeper设计原理" class="headerlink" title="4.zookeeper设计原理"></a>4.zookeeper设计原理</h3><h4 id="a-分布式与数据容错"><a href="#a-分布式与数据容错" class="headerlink" title="a 分布式与数据容错"></a>a 分布式与数据容错</h4><p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：</p><p>1、 容错<br>一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；</p><p>2、提高系统的扩展能力<br>把负载分布到多个节点上，或者增加节点来提高系统的负载能力；</p><p>3、提高性能<br>让客户端本地访问就近的节点，提高用户访问速度。</p><p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p><p>1、写主(WriteMaster)<br>对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；</p><p>2、写任意(Write Any)<br>对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p><p>对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p><p>我们关注的重点还是在如何保证数据在集群所有机器的一致性，这就涉及到paxos算法。</p><h4 id="b-数据一致性与paxos算法"><a href="#b-数据一致性与paxos算法" class="headerlink" title="b 数据一致性与paxos算法"></a>b 数据一致性与paxos算法</h4><blockquote><p>如何保持数据的一致性，这里有个原则就是：</p><p>在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。</p></blockquote><blockquote><p>Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个全局写队列，所有写操作都必须 放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一致性。没错，就是这样，可是如果master挂了呢。</p><p>Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，只有获得过半数选票的写操作才会被 批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排 序。编号严格递增，当一个节点接受了一个编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己 数据不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。</p></blockquote><p>paxos的具体解析见我的博客-<a href="https://ciyaduxingxia.github.io/2021/05/21/fen-bu-shi-xi-tong/#toc-heading-6">分布式系统</a></p><h3 id="5-zookeeper的基本概念"><a href="#5-zookeeper的基本概念" class="headerlink" title="5.zookeeper的基本概念"></a>5.zookeeper的基本概念</h3><h4 id="a-角色"><a href="#a-角色" class="headerlink" title="a 角色"></a>a 角色</h4><p>Zookeeper中的角色主要有以下三类，如下表所示：</p><img src="/2021/08/07/zookeeper-yuan-li/4.png" class title="zookeeper简介"><p>系统模型如图所示：</p><img src="/2021/08/07/zookeeper-yuan-li/5.jpg" class title="zookeeper简介"><h4 id="b-设计目的"><a href="#b-设计目的" class="headerlink" title="b 设计目的"></a>b 设计目的</h4><p>1.最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</p><p>2 .可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</p><p>3 .实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</p><p>4 .等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</p><p>5.原子性：更新只能成功或者失败，没有中间状态。</p><p>6 .顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</p><h3 id="6-zookeeper工作原理"><a href="#6-zookeeper工作原理" class="headerlink" title="6.zookeeper工作原理"></a>6.zookeeper工作原理</h3><p>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</p><p>​    为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</p><p>每个Server在工作过程中有三种状态：</p><ul><li>LOOKING：当前Server不知道leader是谁，正在搜寻</li><li>LEADING：当前Server即为选举出来的leader</li><li>FOLLOWING：leader已经选举出来，当前Server与之同步</li></ul><h4 id="a-选主流程"><a href="#a-选主流程" class="headerlink" title="a 选主流程"></a>a 选主流程</h4><p>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的 Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：</p><p>​    1 .选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</p><p>​    2 .选举线程首先向所有Server发起一次询问(包括自己)；</p><p>​    3 .选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</p><p>​    4.  收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</p><p>​    5.  线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</p><p>​    通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.</p><p>​    每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：</p><img src="/2021/08/07/zookeeper-yuan-li/6.png" class title="zookeeper简介"><p>​    fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和 zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：</p><img src="/2021/08/07/zookeeper-yuan-li/7.png" class title="zookeeper简介"><h4 id="b-同步流程"><a href="#b-同步流程" class="headerlink" title="b 同步流程"></a>b 同步流程</h4><p>选完leader以后，zk就进入状态同步过程。</p><p>​    1. leader等待server连接；</p><p>​    2 .Follower连接leader，将最大的zxid发送给leader；</p><p>​    3 .Leader根据follower的zxid确定同步点；</p><p>​    4 .完成同步后通知follower 已经成为uptodate状态；</p><p>​    5 .Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</p><p>流程图如下所示：</p><img src="/2021/08/07/zookeeper-yuan-li/8.jpg" class title="zookeeper简介"><h4 id="c-工作流程"><a href="#c-工作流程" class="headerlink" title="c 工作流程"></a>c 工作流程</h4><h5 id="c-1-Leader工作流程"><a href="#c-1-Leader工作流程" class="headerlink" title="c.1 Leader工作流程"></a>c.1 Leader工作流程</h5><p>Leader主要有三个功能：</p><p>​    1 .恢复数据；</p><p>​    2 .维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</p><p>​    3 .Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。</p><p>​    PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是 Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。<br>Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。</p><img src="/2021/08/07/zookeeper-yuan-li/9.png" class title="zookeeper简介"><h5 id="c-2-Follower工作流程"><a href="#c-2-Follower工作流程" class="headerlink" title="c.2 Follower工作流程"></a>c.2 Follower工作流程</h5><p>Follower主要有四个功能：</p><p>​    1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</p><p>​    2 .接收Leader消息并进行处理；</p><p>​    3 .接收Client的请求，如果为写请求，发送给Leader进行投票；</p><p>​    4 .返回Client结果。</p><p>Follower的消息循环处理如下几种来自Leader的消息：</p><p>​    1 .PING消息： 心跳消息；</p><p>​    2 .PROPOSAL消息：Leader发起的提案，要求Follower投票；</p><p>​    3 .COMMIT消息：服务器端最新一次提案的信息；</p><p>​    4 .UPTODATE消息：表明同步完成；</p><p>​    5 .REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</p><p>​    6 .SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</p><p>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。</p><img src="/2021/08/07/zookeeper-yuan-li/10.png" class title="zookeeper简介"><p>对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。</p>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡简介</title>
      <link href="2021/08/01/fu-zai-jun-heng-jian-jie/"/>
      <url>2021/08/01/fu-zai-jun-heng-jian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="负载均衡简介"><a href="#负载均衡简介" class="headerlink" title="负载均衡简介"></a>负载均衡简介</h2><h3 id="一、什么是负载均衡"><a href="#一、什么是负载均衡" class="headerlink" title="一、什么是负载均衡"></a>一、什么是负载均衡</h3><p>首先我们先介绍一下什么是负载均衡: 负载平衡（Load balancing）是一种计算机网络技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。这是来自维基百科的介绍。负载均衡的目的，就在于平衡负载，给用户提供优质，可靠，稳定的服务。</p><img src="/2021/08/01/fu-zai-jun-heng-jian-jie/1.jpg" class title="负载均衡实例"><p>上图是个最简单的负载均衡实例， 应用服务器并不直接与用户相连， 用户连接负载均衡服务器，然后由负载均衡服务器把消息转发给实际应用服务器。负载均衡器内部会根据应用服务器的负载情况，决定把消息转发给哪台服务器处理。同时负载均衡器还可以对用户屏蔽应用服务器失效，只要把用户的消息转发到非失效服务器即可。</p><p>提到负载均衡，就不能不介绍另外一个概念： <strong>集群</strong>。集群就是一组部署有相同应用的服务器。例如web 服 务器。用户的请求无论连接到哪台服务器上，都能得到相同的处理。这样我们实现一种服务器，可以将用户的请求根据特定规则转发到应用服务器上进行处理。就实现了完整的集群处理系统。这个服务器如果实现了后台服务器感知和配置功能，能够了解后台服务器的可用情况。就可以被称作为负载均衡器。</p><p>负 载均衡在目前网络服务规模越来越庞大的情况下，成为一个大型服务器系统必须要面对的问题。随着用户和业务的增多，来自用户的访问量和数据流量不断增大，对 服务器的计算能力和储存要求也在不断增加，单台服务器根本无法承担这么庞大的数据处理请求。这个时候，我们必须利用集群技术，采用一组服务器对来自用户的 请求进行处理，服务器的数量要能够不断的扩充。在集群的前端，我们采用负载均衡技术，平均分散用户的请求到不同的处理服务器，并且能够在集群中某个服务失 效时，即时感知，屏蔽，将消息转发到其他可用服务器上。</p><p><strong>负载均衡分为硬件和软件：</strong></p><p><strong>(1).硬件LB（比较出名的）</strong></p><p>F5 公司的 BIG-IP系列、Citrix 公司的 NetScaler系列、A10 公司的 AX系列</p><p><strong>(2).软件LB</strong></p><p>四层：LVS(Linux VirtualServer)注：国人开发的、七层：Nginx,HAProxy</p><h3 id="二、集群的类型"><a href="#二、集群的类型" class="headerlink" title="二、集群的类型"></a>二、集群的类型</h3><p><strong>1.scale on:向上扩展</strong>  </p><p><strong>将服务器的内存容量调大和<code>cpu</code>数量增加些（简单说升级服务器硬件）</strong>  </p><p>缺点:在一定的范围之内它的性能是上升的趋势,但是超出范围之后就是下降的趋势。因为随着它的<code>cpu</code>的个数增加我们需要给我们的<code>cpu</code>仲裁，而且随着<code>cpu</code>个数的增加资源竞争性越大。</p><p><strong>2.scale out:向外扩展</strong> </p><p><strong>一台服务器应付不过来,我们就再增加一台服务器。</strong>  </p><p>优点:增减服务器很方便，而且没有向上扩展随着增加性能下降。  </p><p>向外扩张的工作模式：当客户端向服务器端发送请求，服务器端只拿出来一台服务器来相应我们的客户端的请求。</p><p><strong>(1)<code>LB:Load Balancing</code>: 负载均衡集群</strong></p><p>负载均衡集群中有一个分发器或者叫调度器，我们将其称之为Director，它处在多台服务器的上面，分发器根据内部锁定义的规则或调度方式从下面的服务器群中选择一个以此来响应客户端发送的请求。</p><p><strong>(2)<code>HA:High Availability</code>: 高可用集群</strong> </p><p>高可用集群是服务的可用性比较高，当我们某台服务器死机后不会造成我们的服务不可用。其工作模式则是将一个具有故障的服务转交给一个正常工作的服务器，从而达到服务不会中断。一般来说我们集群中工作在前端（分发器）的服务器都会对我们的后端服务器做一个健康检查，如果发现我们服务器宕机就不会对其在做转发。</p><p>衡量标准：可用性=在线时间/(在线时间+故障处理时间) 99%、99.9%、99.99%、99.999%</p><p><strong>(3)<code>HP:Hight Performance</code>: 高性能</strong> </p><p>高性能的集群是当某一个任务量非常大的时候，我们做一个集群共同来完成这一个任务。这种处理方式我们称为并行处理集群，并行处理集群是将大任务划分为小任务，分别进行处理的机制。一般这样的集群用来科学研究与大数据运算等方面的工作。现在比较火的Hadoop就是使用的并行处理集群。</p><p><strong>说明：三种集群之间的区别</strong> </p><p><strong>负载均衡着重在于提供服务并发处理能力的集群，高可用以提升服务在线的能力的集群。高性能着重用于处理一个海量任务。</strong></p><h3 id="三、主要负载均衡方案介绍"><a href="#三、主要负载均衡方案介绍" class="headerlink" title="三、主要负载均衡方案介绍"></a>三、主要负载均衡方案介绍</h3><p><strong>1:HTTP 重定向负载均衡</strong></p><img src="/2021/08/01/fu-zai-jun-heng-jian-jie/2.jpg" class title="HTTP 重定向负载均衡"><p>这种负载均衡方式仅适合WEB 服务器。用户发出请求时，负载均衡服务器会根据HTTP请求，重新计算出实际的WEB服务器地址，通过302重定向相应发送给用户浏览器。用户浏览器再根据302响应信息，对实际的WEB服务器发出请求。<strong>HTTP重定向方案有点是比较简单，缺点是性能比较差，需要2次请求才能返回实际结果,还有就是仅适合HTTP服务器使用。</strong></p><p><strong>2: DNS 域名解析负载均衡</strong></p><img src="/2021/08/01/fu-zai-jun-heng-jian-jie/3.jpg" class title="DNS 域名解析负载均衡"><p>在DNS中存储了一个域名的多个主机地址，每次域名解析请求，都可以根据负载均衡算法返回一个不同的IP地址。这样多个WEB服务器就构成了一个集群，并由DNS服务器提供了负载均衡服务。<strong>DNS域名解析负载均衡的优点是由DNS来完成负载均衡工作，服务本身不用维护负载均衡服务器的工作。缺点也是，由于负载均衡服务器不是自己维护，没法做精细控制，而且DNS在客户端往往带有缓存，服务器的变更很难及时反映到客户端上。</strong></p><p><strong>3：反向代理负载均衡</strong></p><img src="/2021/08/01/fu-zai-jun-heng-jian-jie/4.jpg" class title="反向代理负载均衡"><p>反向代理服务器位于实际的服务器之前，他能够缓存服务器响应，加速访问，同时也启到了负载均衡服务器的效果。反向代理服务器解析客户端请求，根据负载均衡算 法转发到不同的后台服务器上。用户和后台服务器之间不再有直接的链接。请求，响应都由反向代理服务器进行转发。<strong>优点是和负载均衡服务集成在一起，部署简单。缺点是所有的请求回应都需要经过反向代理服务器。其本身可能会成为性能的瓶颈。</strong>著名的 Nginx服务器就可以部署为反向代理服务器，实现WEB 应用的负载均衡。==上面的三种都是工作在OSI网络模型中的应用层，我们可以统称为应用层负载均衡(七层负载均衡)。下面介绍的几种工作在OSI网络模型中的4层以及4层以下(四层负载均衡)，解决方案也具有更大的通用性。==</p><blockquote><p><a href="https://www.cnblogs.com/mindwind/p/5339657.html">LB 负载均衡的层次结构 - mindwind - 博客园 (cnblogs.com)</a></p></blockquote><p><strong>4：IP负载均衡</strong></p><img src="/2021/08/01/fu-zai-jun-heng-jian-jie/5.jpg" class title="IP负载均衡"><p>用户请求包到达负载均衡服务器114.100.20.200后，负载均衡服务器在操作系统内核层获取网络数据包，根据负载均衡算法获取真实后台服务器地址192.168.1.1, 然后将数据包的目标地址改为192.168.1.1, 转发给内部服务器。整个过程都在内核层进行处理。收到192.168.1.1的响应包之后，会更改响应包的SRC IP, 转发给客户端用户。采用IP层负载均衡算法，全部处理过程都在内核层(Ring 0)进行。和七层负载均衡相比，具有更好的性能。<strong>但是由于所有的响应包都要经过负载均衡服务器，负载均衡服务器的网卡带宽，很容易成为系统的瓶颈</strong>，如果能够让响应包不经过负载均衡服务器，就可以极大的提升整个负载均衡服务器的服务能力。我们下面介绍的数据链路层负载均衡，就具有这个能力。</p><p><strong>5：数据链路层负载均衡</strong></p><img src="/2021/08/01/fu-zai-jun-heng-jian-jie/6.jpg" class title="数据链路层负载均衡"><p>​        数据链路层负载均衡，顾名思义，就是工作在TCP/IP协议最底层的数据链路层，进行负载均衡。我们常用的以太网中，在这一层主要<strong>采用数据帧进行通信，每个网卡都具有唯一的MAC地址，数据帧用MAC地址来标识数据的来源与目的地</strong>。数据链路层负载均衡通过修改数据包的MAC地址，实现负载均衡。</p><p>​        这种数据传输方式又称为三角传输，<strong>负载均衡数据分发过程中不修改IP地址，只修改目的MAC地址</strong>，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器IP和数据请求目的IP一致，不需要通过负载均衡服务器进行地址交换，可将响应数据包直接返回给用户，避免负载均衡服务器网卡带宽成为瓶颈。这种负载均衡方式又称之为直接路由方式（DR）.</p><p>​        如上图所示，用户请求到达负载均衡服务器114.100.20.200后，负载均衡服务器将数据包的目的MAC地址更改为00:1e:ec:bc:5e:03，并不修改数据包目的IP，由于服务器集群所有服务器的虚拟IP地址和负载均衡服务器IP地址一致，因此数据可以正常传输到达MAC地址为00:1e:ec:bc:5e:03的机器上，该服务器处理完之后，将响应数据包发送到网关服务器，网关服务器直接将数据包发送给用户，响应数据不需要通过负载均衡服务器，这样就避免了负载均衡服务器成为传输瓶颈的可能。</p><p>​        数据链路层负载均衡是目前使用最广泛的一种负载均衡方式。著名的负载均衡开源产品LVS(Linux Virtual Server)，同时支持上面的IP负载均衡和数据链路层负载均衡。是学习负载均衡技术必须了解的产品。基于数据链路层的负载均衡虽然有非常好的性能，但是对网络拓扑也有比较大的限制，负载均衡服务器和后台服务器必须处于同一网络环境中才可以。</p><h3 id="四、负载均衡算法介绍"><a href="#四、负载均衡算法介绍" class="headerlink" title="四、负载均衡算法介绍"></a>四、负载均衡算法介绍</h3><p>前面介绍的内容，解决了从用户到实际后台服务器之间的数据包发送和响应的问题。下面我们介绍选择实际后台运行服务器的具体负载均衡算法。考虑到服务请求的不同类型服务器的不同处理能力以及随机选择造成的负载分配不均匀等问题,为了更加合理的把负载分配给内部的多个服务器,就需要应用相应的能够正确反映各个服务器处理能力及网络状态的负载均衡算法。我们以LVS为参考，介绍比较经典的8种负载均衡算法。</p><p><strong>1.轮叫调度(Round Robin)</strong></p><p>调度器通过“轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上,它均等地对待每一台服务器,而不管服务器上实际的连接数和系统负载</p><p><strong>2.加权轮叫(Weighted Round Robin)</strong></p><p>调度器通过“加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求这样可以保证处理能力强的服务器能处理更多的访问流量调度器可以自动问询真实服务器的负载情况,并动态地调整其权值</p><p><strong>3.最少链接(Least Connections)</strong></p><p>调度器通过“最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上如果集群系统的真实服务器具有相近的系统性能,采用“最小连接”调度算法可以较好地均衡负载</p><p><strong>4.加权最少链接(Weighted Least Connections)</strong></p><p>在集群系统中的服务器性能差异较大的情况下,调度器采用“加权最少链接”调度算法优化负载均衡性能,具有较高权值的服务器将承受较大比例的活动连接负载调度器可以自动问询真实服务器的负载情况,并动态地调整其权值</p><p><strong>5.基于局部性的最少链接(Locality-Based Least Connections)</strong></p><p>“基于局部性的最少链接”调度算法是针对目标IP地址的负载均衡,目前主要用于Cache集群系统该算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器,若该服务器是可用的且没有超载,将请求发送到该服务器;若服务器不存在,或者该服务器超载且有服务器处于一半的工作负载,则用“最少链接”的原则选出一个可用的服务器,将请求发送到该服务器</p><p><strong>6.带复制的基于局部性最少链接(Locality-Based Least Connections with Replication)</strong></p><p>“带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡,目前主要用于Cache集群系统它与LBLC算法的不同之处是它要维护从一个目标IP地址到一组服务器的映射,而LBLC算法维护从一个目标IP地址到一台服务器的映射该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组,按“最小连接”原则从服务器组中选出一台服务器,若服务器没有超载,将请求发送到该服务器;若服务器超载,则按“最小连接”原则从这个集群中选出一台服务器,将该服务器加入到服务器组中,将请求发送到该服务器同时,当该服务器组有一段时间没有被修改,将最忙的服务器从服务器组中删除,以降低复制的程度</p><p><strong>7.目标地址散列(Destination Hashing)</strong></p><p>“目标地址散列”调度算法根据请求的目标IP地址,作为散列键(Hash Key)从静态分配的散列表找出对应的服务器,若该服务器是可用的且未超载,将请求发送到该服务器,否则返回空</p><p><strong>8.源地址散列(Source Hashing)</strong></p><p>“源地址散列”调度算法根据请求的源IP地址,作为散列键(Hash Key)从静态分配的散列表找出对应的服务器,若该服务器是可用的且未超载,将请求发送到该服务器,否则返回空</p>]]></content>
      
      
      <categories>
          
          <category> 负载均衡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>groovy的闭包详解</title>
      <link href="2021/07/31/groovy-de-bi-bao-xiang-jie/"/>
      <url>2021/07/31/groovy-de-bi-bao-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="groovy的闭包详解"><a href="#groovy的闭包详解" class="headerlink" title="groovy的闭包详解"></a>groovy的闭包详解</h2><p>Groovy中闭包是什么，官方定义是“<strong>Groovy中的闭包是一个开放，匿名的代码块，可以接受参数，返回值并分配给变量</strong>”，简而言之，他说一个匿名的代码块，可以接受参数，有返回值。</p><h3 id="1-如何定义"><a href="#1-如何定义" class="headerlink" title="1.如何定义"></a>1.如何定义</h3><blockquote><p>定义闭包的语义：{ [<code>closureParameters</code> -&gt; ] <code>statements</code> }</p></blockquote><h3 id="2-闭包的写法"><a href="#2-闭包的写法" class="headerlink" title="2.闭包的写法"></a>2.闭包的写法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//执行一句话  </span><span class="token punctuation">&#123;</span> printf <span class="token string">'Hello World'</span> <span class="token punctuation">&#125;</span>                                       <span class="token comment">//闭包有默认参数it，且不用申明      </span><span class="token punctuation">&#123;</span> println it <span class="token punctuation">&#125;</span>                    <span class="token comment">//闭包有默认参数it，申明了也无所谓                </span><span class="token punctuation">&#123;</span> it <span class="token operator">-></span> println it <span class="token punctuation">&#125;</span>          <span class="token comment">// name是自定义的参数名  </span><span class="token punctuation">&#123;</span> name <span class="token operator">-></span> println name <span class="token punctuation">&#125;</span>                   <span class="token comment">//多个参数的闭包</span><span class="token punctuation">&#123;</span> <span class="token class-name">String</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">-></span>                                    println <span class="token string">"hey $&#123;x&#125; the value is $&#123;y&#125;"</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-groovy-lang-Closure对象"><a href="#3-groovy-lang-Closure对象" class="headerlink" title="3.groovy.lang.Closure对象"></a>3.groovy.lang.Closure对象</h3><p>其实，每定义的闭包是一个Closure对象，我们可以把一个闭包赋值给一个变量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">def innerClosure <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span> def hello <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token class-name">String</span> x <span class="token operator">-></span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello $&#123;x&#125;"</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把闭包作为方法的参数类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token class-name">Closure</span> closure<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onClickListener <span class="token operator">=</span> closure<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如何执行闭包对象呢，执行闭包对象有两种，一是直接用括号+参数，二是调用call方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//执行innerClosure 闭包</span>innerClosure <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//or</span>innerClosure<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//带参数的闭包</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token comment">//or</span>hello<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-理解闭包内this，owner，delegate对象"><a href="#4-理解闭包内this，owner，delegate对象" class="headerlink" title="4.理解闭包内this，owner，delegate对象"></a>4.理解闭包内this，owner，delegate对象</h3><p>在闭包内部，有三个内置对象this，owner，delegate，我们可以直接this，owner，delegate调用，或者用get方法：</p><ul><li><code>getThisObject() </code>等于 this</li><li><code>getOwner()</code> 等于 owner</li><li><code>getDelegate()</code> 等于delegate</li></ul><p>那么这三个对象，分别指代的是哪个对象，是否和java的this关键字一样，我们先做文字解释：</p><ul><li><strong>this</strong> 对应于定义闭包的那个类，如果在内部类中定义，指向的是内部类</li><li><strong>owner</strong> 对应于定义闭包的那个类或者闭包，如果在闭包中定义，对应闭包，否则同this一致</li><li><strong>delegate</strong> 默认是和owner一致，或者自定义delegate指向<br> 我们来用代码验证一下</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">OuterClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">&#123;</span>        def outerClosure <span class="token operator">=</span> <span class="token punctuation">&#123;</span>            def innerClosure <span class="token operator">=</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">printfMsg</span><span class="token punctuation">(</span><span class="token string">"innerClosure"</span><span class="token punctuation">,</span> innerClosure<span class="token punctuation">)</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------"</span><span class="token punctuation">)</span>            <span class="token function">printfMsg</span><span class="token punctuation">(</span><span class="token string">"outerClosure"</span><span class="token punctuation">,</span> outerClosure<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">printfMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> flag<span class="token punctuation">,</span> <span class="token class-name">Closure</span> closure<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            def thisObject <span class="token operator">=</span> closure<span class="token punctuation">.</span><span class="token function">getThisObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            def ownerObject <span class="token operator">=</span> closure<span class="token punctuation">.</span><span class="token function">getOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            def delegate <span class="token operator">=</span> closure<span class="token punctuation">.</span><span class="token function">getDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"$&#123;flag&#125; this: $&#123;thisObject.toString()&#125;"</span><span class="token punctuation">)</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"$&#123;flag&#125; owner: $&#123;ownerObject.toString()&#125;"</span><span class="token punctuation">)</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"$&#123;flag&#125; delegate: $&#123;delegate.toString()&#125;"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     def <span class="token function">callInnerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        def innerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        innerClass<span class="token punctuation">.</span>outerClosure<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------"</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"outerClosure toString $&#123;innerClass.outerClosure.toString()&#125;"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">OuterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">callInnerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>输出结果<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>innerClosure <span class="token keyword">this</span><span class="token operator">:</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>groovy<span class="token punctuation">.</span>bean<span class="token punctuation">.</span></span>OuterClass</span>$<span class="token class-name">InnerClass</span><span class="token annotation punctuation">@e874448</span>innerClosure owner<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>groovy<span class="token punctuation">.</span>bean<span class="token punctuation">.</span></span>OuterClass</span>$<span class="token class-name">InnerClass</span>$_closure1<span class="token annotation punctuation">@5bfbf16f</span>innerClosure delegate<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>groovy<span class="token punctuation">.</span>bean<span class="token punctuation">.</span></span>OuterClass</span>$<span class="token class-name">InnerClass</span>$_closure1<span class="token annotation punctuation">@5bfbf16f</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>outerClosure <span class="token keyword">this</span><span class="token operator">:</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>groovy<span class="token punctuation">.</span>bean<span class="token punctuation">.</span></span>OuterClass</span>$<span class="token class-name">InnerClass</span><span class="token annotation punctuation">@e874448</span>outerClosure owner<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>groovy<span class="token punctuation">.</span>bean<span class="token punctuation">.</span></span>OuterClass</span>$<span class="token class-name">InnerClass</span><span class="token annotation punctuation">@e874448</span>outerClosure delegate<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>groovy<span class="token punctuation">.</span>bean<span class="token punctuation">.</span></span>OuterClass</span>$<span class="token class-name">InnerClass</span><span class="token annotation punctuation">@e874448</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>outerClosure toString <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>groovy<span class="token punctuation">.</span>bean<span class="token punctuation">.</span></span>OuterClass</span>$<span class="token class-name">InnerClass</span>$_closure1<span class="token annotation punctuation">@5bfbf16f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>this，owner ，delegate指向总结：<br><strong>this</strong> 永远是指定义该闭包类，如果存在内部类，则是最内层的类，但this不是指当前闭包对象<br><strong>owner</strong> 永远是指定义该闭包的类或者闭包，顾名思义，闭包只能定义在类中或者闭包中<br><strong>delegate</strong> 默认是指owner，可以自己设置，自己设置的话又是什么情况</p><h3 id="5-delegate的使用（重点）"><a href="#5-delegate的使用（重点）" class="headerlink" title="5.delegate的使用（重点）"></a>5.delegate的使用（重点）</h3><p>前面已经说了，闭包可以设置delegate对象，<strong>设置delegate的意义就是讲闭包和一个具体的对象关联起来</strong>，这个如何理解，看代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"># <span class="token class-name">Person</span><span class="token punctuation">.</span>groovy<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> name    <span class="token keyword">int</span> age     <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token class-name">String</span> food<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你喂的$&#123;food&#125;真难吃"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>    <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Person&#123;"</span> <span class="token operator">+</span>                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>                <span class="token string">'&#125;'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    def cc <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        name <span class="token operator">=</span> <span class="token string">"hanmeimei"</span>        age <span class="token operator">=</span> <span class="token number">26</span>        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">"油条"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Main</span> main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token string">"lilei"</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">14</span><span class="token punctuation">)</span>        println person<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         main<span class="token punctuation">.</span>cc<span class="token punctuation">.</span>delegate <span class="token operator">=</span> person <span class="token comment">//把delegate和person联系起来了</span>        main<span class="token punctuation">.</span>cc<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        println person<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> #打印结果<span class="token class-name">Person</span><span class="token punctuation">&#123;</span>name<span class="token operator">=</span><span class="token string">'lilei'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">14</span><span class="token punctuation">&#125;</span>你喂的油条真难吃<span class="token class-name">Person</span><span class="token punctuation">&#123;</span>name<span class="token operator">=</span><span class="token string">'hanmeimei'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">26</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面我们知道了，在闭包中可以访问被代理对象的属性和方法，那么如果闭包所在的类或闭包中和被代理的类中有相同名称的方法，到底要调用哪个方法，其实这个问题groovy肯定考虑到了，为我们设定了几个代理的策略：</p></blockquote><ul><li><code>Closure.OWNER_FIRST</code>：是默认策略。优先在owner寻找，owner没有再delegate</li><li><code>Closure.DELEGATE_FIRST</code>：优先在delegate寻找，delegate没有再owner</li><li><code>Closure.OWNER_ONLY</code>：只在owner中寻找</li><li><code>Closure.DELEGATE_ONLY</code>：只在delegate中寻找</li><li><code>Closure.TO_SELF</code>：</li></ul><p>为了验证，我们现在修改一下<code>Main.groovy</code>代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token class-name">String</span> food<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        println <span class="token string">"我根本不会吃，不要喂我$&#123;food&#125;"</span>    <span class="token punctuation">&#125;</span>    def cc <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        name <span class="token operator">=</span> <span class="token string">"hanmeimei"</span>        age <span class="token operator">=</span> <span class="token number">26</span>        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">"油条"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Main</span> main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token string">"lilei"</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">14</span><span class="token punctuation">)</span>        println person<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         main<span class="token punctuation">.</span>cc<span class="token punctuation">.</span>delegate <span class="token operator">=</span> person<span class="token comment">//main.cc.setResolveStrategy(Closure.DELEGATE_FIRST)</span>        main<span class="token punctuation">.</span>cc<span class="token punctuation">.</span><span class="token function">setResolveStrategy</span><span class="token punctuation">(</span><span class="token class-name">Closure</span><span class="token punctuation">.</span>OWNER_FIRST<span class="token punctuation">)</span>        main<span class="token punctuation">.</span>cc<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        println person<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我们在Main中也定义了同名的方法eat（food）,因为当前cc闭包的owner正是Main对象，我们通过调用<code>setResolveStrategy</code>方法，修改策略，发现结果和预期的一致</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> groovy </category>
          
          <category> 闭包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> groovy </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis之分布式锁</title>
      <link href="2021/07/26/redis-zhi-fen-bu-shi-suo/"/>
      <url>2021/07/26/redis-zhi-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="redis之分布式锁"><a href="#redis之分布式锁" class="headerlink" title="redis之分布式锁"></a>redis之分布式锁</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>分布式系统是现在的一个热点，一般来说面试官会从服务框架开始聊起（<code>SpringCloud、Dubbo</code>），一路聊到分布式事务、分布式锁、<code>ZooKeeper</code>等知识。其中分布式锁又分为<code>zookeeper</code>实现的分布式锁和<code>redis</code>实现的分布式锁。</p><p>本文主要讲讲<code>redis</code>实现的分布式锁。其实<code>redis</code>官方已经做好了这个，Java的这个框架叫做<code>Redisson</code>。先看一段简单的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"myLock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-Redisson实现Redis分布式锁的底层原理"><a href="#2-Redisson实现Redis分布式锁的底层原理" class="headerlink" title="2. Redisson实现Redis分布式锁的底层原理"></a>2. Redisson实现Redis分布式锁的底层原理</h3><p><code>Redisson</code>这个开源框架对<code>Redis</code>分布式锁的实现原理如下图：</p><img src="/2021/07/26/redis-zhi-fen-bu-shi-suo/1.png" class title="Redis分布式锁的底层原理"><h4 id="1-加锁机制"><a href="#1-加锁机制" class="headerlink" title="(1) 加锁机制"></a>(1) 加锁机制</h4><p>咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个<code>redis cluster</code>集群，他首先会根据hash节点选择一台机器。<strong>这里注意</strong>，仅仅只是选择一台机器！这点很关键！紧接着，就会发送一段<code>lua</code>脚本到<code>redis</code>上，那段<code>lua</code>脚本如下所示：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token string">"if (redis.call('exists', KEYS[1]) == 0)) then "</span> <span class="token operator">+</span><span class="token string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span><span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span><span class="token string">"return nil; "</span> <span class="token operator">+</span><span class="token string">"end; "</span> <span class="token operator">+</span> <span class="token string">"if (redis.call('exists',KEYS[1],ARGV[2]) == 1)) then "</span> <span class="token operator">+</span><span class="token string">"redis.call('hincrby',KEYS[1],ARGV[2],1); "</span> <span class="token operator">+</span><span class="token string">"redis.call('pexpire',KEYS[1],ARGV[1]); "</span> <span class="token operator">+</span><span class="token string">"return nil; "</span> <span class="token operator">+</span><span class="token string">"end; "</span> <span class="token operator">+</span><span class="token string">"return redis.call('pttl',KEYS[1]);"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为啥要用<code>lua</code>脚本呢？而不使用<code>redis</code>原生的<code>setNX</code>和<code>expire</code>设置过期时间的方式(要保证这两条指令的原子性)</p><p>因为使用<code>lua</code>脚本有以下几点好处:</p><p>1.减少网络开销:本来多次网络请求的操作,可以用一个请求完成,将多次请求的逻辑放在redis服务器上完成,减少了网络往返时延</p><p>2.原子操作:<code>Redis</code>会将整个脚本作为一个整体执行,中间不会被其他命令插入</p><p>3.复用:客户端发送的脚本会永久存储在<code>Redis</code>中,意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑</p><p>那么，这段<code>lua</code>脚本是什么意思呢？这里**KEYS[1]**代表的是你加锁的那个key，比如说：<code>RLock lock = redisson.getLock(&quot;myLock&quot;)</code>;这里你自己设置了加锁的那个锁key就是“<code>myLock</code>”。</p><p>**ARGV[1]<strong>代表的就是锁key的默认生存时间，默认30秒。</strong>ARGV[2]**代表的是加锁的客户端的ID，类似于下面这样：<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code>。</p><p>给大家解释一下，第一段if判断语句，就是用“**<code>exists myLock</code><strong>”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。如何加锁呢？很简单，</strong>用下面的命令**：<code>hset myLock 8743c9c0-0795-4907-87fd-6c719a6b4586:1 1</code>，通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">myLock<span class="token punctuation">:</span><span class="token punctuation">&#123;</span>    <span class="token string">"8743c9c0-0795-4907-87fd-6c719a6b4586:1"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述就代表“<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code>”这个客户端对“<code>myLock</code>”这个锁key完成了加锁。接着会执行“**<code>pexpire myLock 30000</code><strong>”命令，设置<code>myLock</code>这个锁key的</strong>生存时间是30秒**。好了，到此为止，ok，加锁完成了。</p><h4 id="2-锁互斥机制"><a href="#2-锁互斥机制" class="headerlink" title="(2) 锁互斥机制"></a>(2) 锁互斥机制</h4><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段<code>lua</code>脚本，会咋样呢？很简单，第一个if判断会执行“**<code>exists myLock</code>**”，发现<code>myLock</code>这个锁key已经存在了。接着第二个if判断，判断一下，<code>myLock</code>锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p><p>所以，客户端2会获取到**<code>pttl myLock</code><strong>返回的一个数字，这个数字代表了<code>myLock</code>这个锁key的</strong>剩余生存时间。**比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</p><h4 id="3-watch-dog自动延期机制"><a href="#3-watch-dog自动延期机制" class="headerlink" title="(3) watch dog自动延期机制"></a>(3) watch dog自动延期机制</h4><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，<strong>他是一个后台线程，会每隔10秒检查一下</strong>，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><p>注意：如果客户端1挂了之后，锁key就自动过期。</p><h4 id="4-可重入加锁机制"><a href="#4-可重入加锁机制" class="headerlink" title="(4) 可重入加锁机制"></a>(4) 可重入加锁机制</h4><p>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？比如下面这种代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"myLock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//一段逻辑代码</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//一段逻辑代码</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时我们来分析一下上面那段<code>lua</code>脚本。<strong>第一个if判断肯定不成立</strong>，“<code>exists myLock</code>”会显示锁key已经存在了。<strong>第二个if判断会成立</strong>，因为<code>myLock</code>的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code>”</p><p>此时就会执行可重入加锁的逻辑，他会用：</p><p><code>incrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1</code> ，通过这个命令，对客户端1的加锁次数，累加1。此时<code>myLock</code>数据结构变为下面这样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">myLock<span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token string">"8743c9c0-0795-4907-87fd-6c719a6b4586:1"</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那个<code>myLock</code>的hash数据结构中的那个客户端ID，就对应着加锁的次数</p><h4 id="5-释放锁机制"><a href="#5-释放锁机制" class="headerlink" title="(5) 释放锁机制"></a>(5) 释放锁机制</h4><p>如果执行<code>lock.unlock()</code>，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白了，就是每次都对<code>myLock</code>数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：**<code>“del myLock”</code>命令<strong>，从<code>redis</code>里删除这个key。然后呢，另外的客户端2就可以尝试完成加锁了。这就是所谓的</strong>分布式锁的开源<code>Redisson</code>框架的实现机制。**</p><p>一般我们在生产系统中，可以用<code>Redisson</code>框架提供的这个类库来基于<code>redis</code>进行分布式锁的加锁与释放锁。</p><h4 id="6-上述分布式锁的缺点"><a href="#6-上述分布式锁的缺点" class="headerlink" title="(6) 上述分布式锁的缺点"></a>(6) 上述分布式锁的缺点</h4><p>其实上面那种方案最大的问题，就是如果你对某个<code>redis master</code>实例，写入了<code>myLock</code>这种锁key的value，此时会<strong>异步</strong>复制给对应的<code>master slave</code>实例。但是这个过程中一旦发生<code>redis master</code>宕机，主备切换，<code>redis slave</code>变为了<code>redis master</code>。</p><p>接着就会导致，客户端2来尝试加锁的时候，在新的<code>redis master</code>上完成了加锁，而客户端1也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，<strong>导致各种脏数据的产生</strong>。</p><p>所以这个就是<code>redis cluster</code>，或者是<code>redis master-slave</code>架构的主从异步复制导致的<code>redis</code>分布式锁的最大缺陷：<strong>在<code>redis master</code>实例宕机的时候，可能导致多个客户端同时完成加锁</strong>。</p><h4 id="7-Redlock算法"><a href="#7-Redlock算法" class="headerlink" title="(7) Redlock算法"></a>(7) Redlock算法</h4><p>在<code>Redis</code>的分布式环境中，我们假设有N个<code>Redis master</code>。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个<code>Redis master</code>节点，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。</p><p>为了取到锁，客户端应该执行以下操作:</p><ol><li>获取当前Unix时间，以毫秒为单位。</li><li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向<code>Redis</code>设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端<code>Redis</code>已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个<code>Redis</code>实例。</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到<strong>获取锁使用的时间</strong>。当且仅当从大多数（这里是3个节点）的<code>Redis</code>节点都取到锁，并且<strong>获取锁使用的时间</strong>小于<strong>锁失效时间时</strong>，锁才算获取成功。</li><li>如果取到了锁，key的<strong>真正有效时间</strong>等于<strong>有效时间</strong>减去<strong>获取锁所使用的时间</strong>（步骤3计算的结果）。</li><li>如果因为某些原因，获取锁失败（没有在至少N/2+1个<code>Redis</code>实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的<code>Redis</code>实例上进行解锁（即便某些<code>Redis</code>实例根本就没有加锁成功）。</li></ol><h4 id="8-安全争议"><a href="#8-安全争议" class="headerlink" title="(8) 安全争议"></a>(8) 安全争议</h4><p>这个算法安全么？我们可以从不同的场景讨论一下。</p><p>让我们假设客户端从大多数<code>Redis</code>实例取到了锁。所有的实例都包含同样的key，并且key的有效时间也一样。然而，key肯定是在不同的时间被设置上的，所以key的失效时间也不是精确的相同。我们假设第一个设置的key时间是T1(开始向第一个server发送命令前时间），最后一个设置的key时间是T2(得到最后一台server的答复后的时间），我们可以确认，第一个server的key至少会存活 <code>MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT</code>。所有其他的key的存活时间，都会比这个key时间晚，所以可以肯定，所有key的失效时间至少是MIN_VALIDITY。</p><p>当大部分实例的key被设置后，其他的客户端将不能再取到锁，因为至少N/2+1个实例已经存在key。所以，如果一个锁被（客户端）获取后，客户端自己也不能再次申请到锁(违反互相排斥属性）。</p><p>然而我们也想确保，当多个客户端同时抢夺一个锁时不能两个都成功。</p><p>如果客户端在获取到大多数<code>redis</code>实例锁，使用的时间接近或者已经大于失效时间，客户端将认为锁是失效的锁，并且将释放掉已经获取到的锁，所以我们只需要在有效时间范围内获取到大部分锁这种情况。在上面已经讨论过有争议的地方，在<code>MIN_VALIDITY</code>时间内，将没有客户端再次取得锁。所以只有一种情况，当在MIN_VALIDITY之后另一个客户端获取到了N/2+1个锁，那取得锁的时间也是大于失效时间（TTL time)，这样取到的锁也是无效的。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis之双写一致性策略</title>
      <link href="2021/07/26/redis-zhi-shuang-xie-yi-zhi-xing-ce-lue/"/>
      <url>2021/07/26/redis-zhi-shuang-xie-yi-zhi-xing-ce-lue/</url>
      
        <content type="html"><![CDATA[<h2 id="redis之双写一致性策略"><a href="#redis之双写一致性策略" class="headerlink" title="redis之双写一致性策略"></a>redis之双写一致性策略</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p><p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><h3 id="2-Cache-Aside-Pattern"><a href="#2-Cache-Aside-Pattern" class="headerlink" title="2. Cache Aside Pattern"></a>2. Cache Aside Pattern</h3><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern，<strong>比较适合读请求比较多的场景。</strong></p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>写的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><p>问题一：<strong>为什么是删除缓存，而不是更新缓存？</strong></p><p>答：一是很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值，可能是计算出来的值，这样的话更新代价高。</p><p>​        二是更新频繁但不代表被频繁访问。<strong>用到缓存才去算缓存。</strong>这就是懒加载的思想。</p><p>问题二：<strong>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</strong></p><p>答：这样可能会造成<strong>数据库（DB）和缓存（Cache）数据不一致</strong>的问题。为什么呢？比如说请求1 先写数据A，请求2随后读数据A的话就很有可能产生数据不一致性的问题。这个过程可以简单描述为：</p><blockquote><p>请求1先把cache中的A数据删除 -&gt; 请求2从DB中读取数据-&gt;请求1再把DB中的A数据更新。</p></blockquote><p>这样的话就会产生cache和DB不一致，很严重。</p><p><strong>（重点：串行化策略）当然这里可以使用内存队列保证串行化，等数据库更新完再去读库。这样可以保证绝对一致性</strong></p><p>问题三：<strong>在写数据的过程中，先更新DB，后删除cache就没有问题了么？</strong></p><p>答：理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的删除速度是比数据库的写入速度快很多！</p><p>比如请求1先读数据 A，请求2随后写数据A，并且数据A不在缓存中的话也有可能产生数据不一致性的问题。这个过程可以简单描述为：</p><blockquote><p>请求1从DB读数据A-&gt;请求2写更新数据 A 到数据库并把删除cache中的A数据-&gt;请求1将数据A写入cache。</p></blockquote><p>问题四：<strong>先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。如何解决？（重点）</strong></p><p>答：解决思路一：延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后。<br>        解决思路二：缓存双删。先删除缓存，更新数据库，预计数据库更新需要时间t，然后在提交数据库更新t时间后再次删除缓存。这样也同时把问题二中的场景解决了。</p><p><strong>Cache Aside Pattern 的缺陷</strong>：</p><p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong> </p><p>解决办法：可以将热点数据可以提前放入cache 中。</p><p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p><p>解决办法：</p><ul><li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li></ul><h3 id="3-Read-Write-Through-Pattern（读写穿透）"><a href="#3-Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="3. Read/Write Through Pattern（读写穿透）"></a>3. Read/Write Through Pattern（读写穿透）</h3><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p><p><strong>这种策略非常少见</strong>；一是性能方面的影响；二是经常使用的分布式缓存<code> Redis</code> 并没有提供 cache 将数据写入DB的功能。</p><p><strong>读(Read Through)：</strong> </p><ul><li>从 cache 中读取数据，读取到就直接返回 。</li><li>读取不到的话，先从 DB 加载，cache服务自己写入到 cache 后返回响应。</li></ul><p><strong>写（Write Through）：</strong></p><ul><li>先查 cache，cache 中不存在，直接更新 DB。</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li></ul><p>在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p><h3 id="4-Write-Behind-Pattern（异步缓存写入）"><a href="#4-Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="4. Write Behind Pattern（异步缓存写入）"></a>4. Write Behind Pattern（异步缓存写入）</h3><p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p><p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p><p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p><p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、<code>MySQL</code>的<code>InnoDB Buffer Pool</code>机制都用到了这种策略。</p><p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试-spock</title>
      <link href="2021/07/26/dan-yuan-ce-shi-spock/"/>
      <url>2021/07/26/dan-yuan-ce-shi-spock/</url>
      
        <content type="html"><![CDATA[<h2 id="单元测试-spock"><a href="#单元测试-spock" class="headerlink" title="单元测试-spock"></a>单元测试-spock</h2><h3 id="一、spock是什么"><a href="#一、spock是什么" class="headerlink" title="一、spock是什么"></a>一、spock是什么</h3><p><code>spock</code>是国外一款优秀的测试框架，能够让我们的测试代码规范化，结构层次清晰，结合groovy动态语言的特点以及自身提供的各种标签让编写测试代码更加高效和简洁，提供一种通用的，简单的，结构化的描述语言。</p><p>简单说Spock的特点如下:</p><ul><li>让我们的测试代码更<strong>规范</strong>, 内置多种标签来规范单测代码的语义, 从而让我们的测试代码<strong>结构清晰</strong>, 更具可读性, 降低后期维护难度 </li><li>提供很多实用的标签, 比如: where, with, thrown… 帮组我们应对复杂的测试场景</li><li>再加上使用groovy这种动态语言来编写测试代码, 可以让我们编写的测试代码更<strong>简洁</strong>, <strong>适合敏捷开发</strong>, 提高编写单测代码的<strong>效率</strong></li><li>遵从<strong>BDD</strong>行为驱动开发模式, 不单是为了测试覆盖率而测试, 有助于<strong>提升代码质量</strong></li><li>IDE兼容性好,自带mock功能</li></ul><h3 id="二、spock标签及符号的含义"><a href="#二、spock标签及符号的含义" class="headerlink" title="二、spock标签及符号的含义"></a>二、spock标签及符号的含义</h3><p>Spock标签的作用：</p><ul><li>given: 输入条件(前置参数)</li><li>when: 执行行为(mock接口、真实调用)</li><li>then: 输出条件(验证结果)</li><li>and: 衔接上个标签，补充的作用</li><li>expect: 相当于when和then的结合</li></ul><p>then模块作用是验证被测方法的结果是否正确，符合预期值，所以这个模块里的语句必须是boolean表达式，类似于junit的assert断言机制，但你不必显示的写assert，这也是一种约定优于配置的思想<br>then块中使用了spock的with功能，可以验证返回结果response对象内部的多个属性是否符合预期值，这个相对于junit的assertNotNull或assertEquals的方式更简单一些</p><p> where模块第一行代码是表格的列名，多个列使用”|”单竖线隔开，”||”双竖线区分输入和输出变量，即左边是输入值，右边是输出值<br>格式如下:<br>输入参数1 | 输入参数2 || 输出结果1 | 输出结果2</p><p>@Unroll注解，可以把每一次调用作为一个单独的测试用例运行，即把请求参数值和返回结果值的字符串里动态替换掉，”#uid、#postCodeResult、#telephoneResult” 井号后面的变量是在方法内部定义的，前面加上#号，实现占位符的功能。</p><img src="/2021/07/26/dan-yuan-ce-shi-spock/1.png" class title="@Unroll"><img src="/2021/07/26/dan-yuan-ce-shi-spock/2.png" class title="控制台输出"><p>spock其他符号的含义</p><pre class="line-numbers language-groovy" data-language="groovy"><code class="language-groovy"><span class="token comment">//>>表示即模拟getUserInfo接口的返回结果</span>userDao<span class="token punctuation">.</span><span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token punctuation">[</span>user1<span class="token punctuation">,</span> user2<span class="token punctuation">]</span><span class="token comment">//_表示匹配任意类型参数</span>List<span class="token operator">&lt;</span>UserDTO<span class="token operator">></span> users <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">)</span><span class="token comment">//如果有同名的方法，使用as指定参数类型区分</span>List<span class="token operator">&lt;</span>UserDTO<span class="token operator">></span> users <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token number">_</span> <span class="token keyword">as</span> String<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、spock代码编写"><a href="#三、spock代码编写" class="headerlink" title="三、spock代码编写"></a>三、spock代码编写</h3><p><strong>第三方依赖,接口调用,QConfig的mock用法</strong><br>先看下正常的业务代码，这是我们平时开发最常见的业务场景：<br>构造请求参数调用底层信用卡接口获取优惠信息，然后根据QConfig配置和一些判断逻辑设置不同的返回结果值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">KoreaCreditCardDiscount</span> <span class="token function">getKoreaCreditCardDiscount</span><span class="token punctuation">(</span><span class="token class-name">String</span> promotionId<span class="token punctuation">,</span> <span class="token class-name">RequestHeadDTO</span> head<span class="token punctuation">,</span> <span class="token class-name">SearchResponseDTO</span> responseDTO<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">KoreaCreditCardDiscount</span> koreaCreditCardDiscount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KoreaCreditCardDiscount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>promotionId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> koreaCreditCardDiscount<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">GetPromoteInfoRequestTypeDTO</span> promoteInfoRequestTypeDTO <span class="token operator">=</span> <span class="token function">toPayDiscountForMerchantRequestDTO</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> responseDTO<span class="token punctuation">,</span> promotionId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用底层优惠券接口</span>    <span class="token class-name">GetPromoteInfoResponseTypeDTO</span> promoteInfo <span class="token operator">=</span> getCreditCardPayWrapper<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>promoteInfoRequestTypeDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>promoteInfo <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>promoteInfo<span class="token punctuation">.</span><span class="token function">getPromotionList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> koreaCreditCardDiscount<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">KoreaCreditCardDiscountDetail</span><span class="token punctuation">></span></span> koreaCreditCardDiscountDetailList <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">PromotionDTO</span> promotion <span class="token operator">=</span> promoteInfo<span class="token punctuation">.</span><span class="token function">getPromotionList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">KoreaCreditCardDiscountDetail</span> discountDetail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KoreaCreditCardDiscountDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    discountDetail<span class="token punctuation">.</span><span class="token function">setPromotionId</span><span class="token punctuation">(</span>promotion<span class="token punctuation">.</span><span class="token function">getPromotionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    discountDetail<span class="token punctuation">.</span><span class="token function">setBrandId</span><span class="token punctuation">(</span>promotion<span class="token punctuation">.</span><span class="token function">getBrandIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取QConfig中优惠券品牌相关配置</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CreditCardBrandConfigDTO</span><span class="token punctuation">></span></span> creditCardBrandConfigList <span class="token operator">=</span> creditCardBrandConfig<span class="token punctuation">.</span><span class="token function">getCreditCardBrandConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>creditCardBrandConfigList<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">SourceEnum</span><span class="token punctuation">.</span>ONLINE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CreditCardBrandConfigDTO</span> creditCardBrandConfig <span class="token operator">=</span> creditCardBrandConfigList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>p <span class="token operator">-></span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getBrandId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> promotion<span class="token punctuation">.</span><span class="token function">getBrandIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CreditCardBrandConfigDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        discountDetail<span class="token punctuation">.</span><span class="token function">setBrandName</span><span class="token punctuation">(</span>creditCardBrandConfig<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    discountDetail<span class="token punctuation">.</span><span class="token function">setDeductionAmount</span><span class="token punctuation">(</span>promotion<span class="token punctuation">.</span><span class="token function">getDeductionAmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    discountDetail<span class="token punctuation">.</span><span class="token function">setRuleType</span><span class="token punctuation">(</span>promotion<span class="token punctuation">.</span><span class="token function">getRuleType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    koreaCreditCardDiscountDetailList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>discountDetail<span class="token punctuation">)</span><span class="token punctuation">;</span>    koreaCreditCardDiscount<span class="token punctuation">.</span><span class="token function">setKoreaCreditCardDiscountDetailList</span><span class="token punctuation">(</span>koreaCreditCardDiscountDetailList<span class="token punctuation">)</span><span class="token punctuation">;</span>    koreaCreditCardDiscount<span class="token punctuation">.</span><span class="token function">setDecimalCount</span><span class="token punctuation">(</span>promotion<span class="token punctuation">.</span><span class="token function">getDeductionAmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> koreaCreditCardDiscount<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是具体的测试代码, 前面是使用JUnit+JMockit 编写的,后面是使用Spock 的单测代码</p><p>JUnit+JMockit</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetCreditCardMapperTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">AppFlightGetInfoJavaMapper</span> testInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AppFlightGetInfoJavaMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">BookingNumberProcessor</span> bookingNumberProcessor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BookingNumberProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getKoreaCreditCardDiscount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">GetCreditCardMapper</span> testInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetCreditCardMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">MockUp</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GetCreditCardPayWrapper</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Mock</span>            <span class="token class-name">GetPromoteInfoResponseTypeDTO</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">GetPromoteInfoRequestTypeDTO</span> requestDTO<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">GetPromoteInfoResponseTypeDTO</span> promoteInfoResponseTypeDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetPromoteInfoResponseTypeDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">PromotionDTO</span> promotionDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromotionDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                promotionDTO<span class="token punctuation">.</span><span class="token function">setDeductionAmount</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>TEN<span class="token punctuation">)</span><span class="token punctuation">;</span>                promotionDTO<span class="token punctuation">.</span><span class="token function">setBrandIds</span><span class="token punctuation">(</span><span class="token string">"KoreaCreditPay"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                promotionDTO<span class="token punctuation">.</span><span class="token function">setRuleType</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PromotionDTO</span><span class="token punctuation">></span></span> promotionList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                promotionList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>promotionDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>                promoteInfoResponseTypeDTO<span class="token punctuation">.</span><span class="token function">setPromotionList</span><span class="token punctuation">(</span>promotionList<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> promoteInfoResponseTypeDTO<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">GetCreditCardPayWrapper</span> getCreditCardPayWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetCreditCardPayWrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setField</span><span class="token punctuation">(</span>testInstance<span class="token punctuation">,</span> <span class="token string">"getCreditCardPayWrapper"</span><span class="token punctuation">,</span> getCreditCardPayWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">MockUp</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CreditCardBrandConfig</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Mock</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CreditCardBrandConfigDTO</span><span class="token punctuation">></span></span> <span class="token function">getCreditCardBrandConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CreditCardBrandConfigDTO</span><span class="token punctuation">></span></span> creditCardBrandConfigList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">CreditCardBrandConfigDTO</span> creditCardBrandConfigDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreditCardBrandConfigDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                creditCardBrandConfigDTO<span class="token punctuation">.</span><span class="token function">setBrandId</span><span class="token punctuation">(</span><span class="token string">"KoreaCreditPay"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                creditCardBrandConfigDTO<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"韩国信用卡"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                creditCardBrandConfigList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>creditCardBrandConfigDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> creditCardBrandConfigList<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">CreditCardBrandConfig</span> creditCardBrandConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreditCardBrandConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setField</span><span class="token punctuation">(</span>testInstance<span class="token punctuation">,</span> <span class="token string">"creditCardBrandConfig"</span><span class="token punctuation">,</span> creditCardBrandConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> promotionId <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token class-name">RequestHeadDTO</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RequestHeadDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SearchResponseDTO</span> responseDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchResponseDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SearchResultDTO</span> searchResultDTO<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchResultDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        responseDTO<span class="token punctuation">.</span><span class="token function">setSearchResult</span><span class="token punctuation">(</span>searchResultDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">KoreaCreditCardDiscount</span> responseType <span class="token operator">=</span> testInstance<span class="token punctuation">.</span><span class="token function">getKoreaCreditCardDiscount</span><span class="token punctuation">(</span>promotionId<span class="token punctuation">,</span> head<span class="token punctuation">,</span> responseDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span>responseType<span class="token punctuation">.</span><span class="token function">getDecimalCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> responseType<span class="token punctuation">.</span><span class="token function">getDecimalCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span>responseType<span class="token punctuation">.</span><span class="token function">getKoreaCreditCardDiscountDetailList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"KoreaCreditPay"</span><span class="token punctuation">,</span> responseType<span class="token punctuation">.</span><span class="token function">getKoreaCreditCardDiscountDetailList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBrandId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> responseType<span class="token punctuation">.</span><span class="token function">getKoreaCreditCardDiscountDetailList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRuleType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> responseType<span class="token punctuation">.</span><span class="token function">getKoreaCreditCardDiscountDetailList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeductionAmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spock</p><pre class="line-numbers language-groovy" data-language="groovy"><code class="language-groovy"><span class="token keyword">class</span> <span class="token class-name">GetCreditCardMapperTest</span> <span class="token keyword">extends</span> <span class="token class-name">Specification</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">def</span> creditCardMapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetCreditCardMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> getCreditCardPayWrapper <span class="token operator">=</span> <span class="token function">Mock</span><span class="token punctuation">(</span>GetCreditCardPayWrapper<span class="token punctuation">)</span>    <span class="token keyword">def</span> creditCardBrandConfig <span class="token operator">=</span> <span class="token function">Mock</span><span class="token punctuation">(</span>CreditCardBrandConfig<span class="token punctuation">)</span>     <span class="token keyword">def</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        creditCardMapper<span class="token punctuation">.</span>getCreditCardPayWrapper <span class="token operator">=</span> getCreditCardPayWrapper        creditCardMapper<span class="token punctuation">.</span>creditCardBrandConfig <span class="token operator">=</span> creditCardBrandConfig    <span class="token punctuation">&#125;</span>     <span class="token keyword">def</span> <span class="token string gstring">"getKoreaCreditCardDiscount"</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token spock-block">given:</span> <span class="token string gstring">"设置韩国信用卡接口的请求参数"</span>        <span class="token keyword">def</span> promotionDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromotionDTO</span><span class="token punctuation">(</span>deductionAmount<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> brandIds<span class="token punctuation">:</span> <span class="token string gstring">"KoreaCreditPay"</span><span class="token punctuation">,</span> ruleType<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> responseDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchResponseDTO</span><span class="token punctuation">(</span>searchResult<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">SearchResultDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token spock-block">and:</span> <span class="token string gstring">"mock韩国信用卡接口调用"</span>        getCreditCardPayWrapper<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token keyword">new</span> <span class="token class-name">GetPromoteInfoResponseTypeDTO</span><span class="token punctuation">(</span>promotionList<span class="token punctuation">:</span> <span class="token punctuation">[</span>promotionDTO<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token spock-block">and:</span> <span class="token string gstring">"mock信用卡品牌名称配置"</span>        creditCardBrandConfig<span class="token punctuation">.</span><span class="token function">getCreditCardBrandConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">CreditCardBrandConfigDTO</span><span class="token punctuation">(</span>brandId<span class="token punctuation">:</span> <span class="token string gstring">"KoreaCreditPay"</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string gstring">"韩国信用卡"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>         <span class="token spock-block">when:</span> <span class="token string gstring">"当调用韩国信用卡接口时mock掉"</span>        <span class="token keyword">def</span> responseType <span class="token operator">=</span> creditCardMapper<span class="token punctuation">.</span><span class="token function">getKoreaCreditCardDiscount</span><span class="token punctuation">(</span><span class="token string gstring">"123456"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RequestHeadDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> responseDTO<span class="token punctuation">)</span>         <span class="token spock-block">then:</span> <span class="token string gstring">"验证返回结果里的折扣金额,支付品牌,折扣规则等字段值是否符合预期"</span>        <span class="token function">with</span><span class="token punctuation">(</span>responseType<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            decimalCount <span class="token operator">==</span> <span class="token number">10</span>            koreaCreditCardDiscountDetailList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>brandId <span class="token operator">==</span> <span class="token string gstring">"KoreaCreditPay"</span>            koreaCreditCardDiscountDetailList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ruleType <span class="token operator">==</span> <span class="token number">1</span>            koreaCreditCardDiscountDetailList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>deductionAmount <span class="token operator">==</span> <span class="token number">10</span>        <span class="token punctuation">&#125;</span>        <span class="token spock-block">where:</span> <span class="token string gstring">"表格方式验证韩国信用卡功能的多种分支调用场景"</span>        promotionId <span class="token operator">|</span> head                       <span class="token operator">|</span> responseDTO      <span class="token operator">||</span> decCount <span class="token operator">|</span> bId              <span class="token operator">|</span> bName        <span class="token string gstring">"12345"</span>     <span class="token operator">|</span> <span class="token function">getHead</span><span class="token punctuation">(</span>SourceEnum<span class="token punctuation">.</span>IOS<span class="token punctuation">)</span>    <span class="token operator">|</span> <span class="token function">getResponseDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">10</span>       <span class="token operator">|</span> <span class="token string gstring">"KoreaCreditPay"</span> <span class="token operator">|</span> null        <span class="token string gstring">"18583"</span>     <span class="token operator">|</span> <span class="token function">getHead</span><span class="token punctuation">(</span>SourceEnum<span class="token punctuation">.</span>ONLINE<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token function">getResponseDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">10</span>       <span class="token operator">|</span> <span class="token string gstring">"KoreaCreditPay"</span> <span class="token operator">|</span> <span class="token string gstring">"韩国信用卡"</span>        <span class="token string gstring">""</span>          <span class="token operator">|</span> <span class="token function">getHead</span><span class="token punctuation">(</span>SourceEnum<span class="token punctuation">.</span>WAP<span class="token punctuation">)</span>    <span class="token operator">|</span> <span class="token function">getResponseDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> null     <span class="token operator">|</span> null              <span class="token operator">|</span> null    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而且如果其中一行测试结果不符合预期，spock的错误提示信息也很详细，方便排查：</p><img src="/2021/07/26/dan-yuan-ce-shi-spock/3.png" class title="错误提示信息"><h3 id="四、Void方法单测"><a href="#四、Void方法单测" class="headerlink" title="四、Void方法单测"></a>四、Void方法单测</h3><p>无返回值方法的测试不能像上面几种有结果返回的，可以验证返回结果是否符合预期，<br>无返回值的方法主要是验证方法内部流转是否符合预期，比如应该走到哪个分支逻辑？<br>是否执行了这一行代码？for循环中的代码执行了几次？变量在方法内部的变化情况？<br>比如下面这个void方法的逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">deductionDiscountedPriceInFlightList</span><span class="token punctuation">(</span><span class="token class-name">FlightPolicySearchCommonResponseType</span> responseType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">KoreaCreditCardDiscount</span> koreaCreditCardDiscount <span class="token operator">=</span> responseType<span class="token punctuation">.</span><span class="token function">getKoreaCreditCardDiscount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>koreaCreditCardDiscount <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>koreaCreditCardDiscount<span class="token punctuation">.</span><span class="token function">getKoreaCreditCardDiscountDetailList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">PolicyInfoType</span> policyInfoType <span class="token operator">:</span> responseType<span class="token punctuation">.</span><span class="token function">getPolicyInfoList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">BigDecimal</span> viewAvgPrice <span class="token operator">=</span> policyInfoType<span class="token punctuation">.</span><span class="token function">getPriceDetailInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getViewAvgPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        viewAvgPrice <span class="token operator">=</span> getCreditCardMapper<span class="token punctuation">.</span><span class="token function">deductionMaxDiscountedPrices</span><span class="token punctuation">(</span>viewAvgPrice<span class="token punctuation">,</span> responseType<span class="token punctuation">.</span><span class="token function">getKoreaCreditCardDiscount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 其他业务逻辑省略... 比如转换对应的外币金额</span>        policyInfoType<span class="token punctuation">.</span><span class="token function">getPriceDetailInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewAvgPrice</span><span class="token punctuation">(</span>viewAvgPrice<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码：</p><pre class="line-numbers language-groovy" data-language="groovy"><code class="language-groovy"><span class="token keyword">def</span> <span class="token string gstring">"测试deductionDiscountedPriceInFlightList()方法"</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token spock-block">given:</span> <span class="token string gstring">"mock相关准备"</span>    <span class="token keyword">def</span> getCreditCardMapper <span class="token operator">=</span> <span class="token function">Mock</span><span class="token punctuation">(</span>GetCreditCardMapper<span class="token punctuation">)</span>    searchMapper<span class="token punctuation">.</span>getCreditCardMapper <span class="token operator">=</span> getCreditCardMapper     <span class="token spock-block">and:</span> <span class="token string gstring">"设置请求参数"</span>    <span class="token keyword">def</span> responseType <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlightPolicySearchCommonResponseType</span><span class="token punctuation">(</span>koreaCreditCardDiscount<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">KoreaCreditCardDiscount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    responseType<span class="token punctuation">.</span>koreaCreditCardDiscount<span class="token punctuation">.</span>koreaCreditCardDiscountDetailList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">KoreaCreditCardDiscountDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    responseType<span class="token punctuation">.</span>policyInfoList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">PolicyInfoType</span><span class="token punctuation">(</span>priceDetailInfo<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">PriceDetailInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">PolicyInfoType</span><span class="token punctuation">(</span>priceDetailInfo<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">PriceDetailInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>     <span class="token spock-block">when:</span> <span class="token string gstring">"反射调用私有方法"</span>    Method method <span class="token operator">=</span> searchMapper<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string gstring">"deductionDiscountedPriceInFlightList"</span><span class="token punctuation">,</span> FlightPolicySearchCommonResponseType<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>searchMapper<span class="token punctuation">,</span> responseType<span class="token punctuation">)</span>     <span class="token spock-block">then:</span> <span class="token string gstring">"验证调用最大折扣计算方法的行为是否符合预期: 一共调用2次, 第一次输出折扣金额是100,第二次输出折扣金额是200"</span>    <span class="token number">2</span> <span class="token operator">*</span> getCreditCardMapper<span class="token punctuation">.</span><span class="token function">deductionMaxDiscountedPrices</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">100</span> <span class="token operator">>></span> <span class="token number">200</span>     <span class="token spock-block">and:</span> <span class="token string gstring">"验证外币金额是否正确"</span>    <span class="token function">with</span><span class="token punctuation">(</span>responseType<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        policyInfoList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>priceDetailInfo<span class="token punctuation">.</span>viewAvgPrice <span class="token operator">==</span> <span class="token number">14.13</span>        policyInfoList<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>priceDetailInfo<span class="token punctuation">.</span>viewAvgPrice <span class="token operator">==</span> <span class="token number">28.26</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在then里通过<code>“2 * getCreditCardMapper.deductionMaxDiscountedPrices(_, _, _)” </code>的方式，<br>验证<code>deductionMaxDiscountedPrices()</code>是否被调用了2次，前面的数字“2”表示这行代码执行了几次，<br>如果不是则测试失败，然后2次调用分别返回不同的值，第一次返回的折扣金额是100，第二次调用返回的折扣金额是200，再通过验证输入条件<code>responseType</code>的<code>viewAvgPrice</code>在for循环中的赋值是否符合预期情况，<br>这样的测试代码也更符合<strong>BDD</strong>行为驱动的思想。<br>另外如果要使用where的方式测试void方法需要注意，因为spock要求where里的表格至少有一个输入和一个输出，对于上面的代码如果要测试分支情况的话需要下面这种写法：</p><pre class="line-numbers language-groovy" data-language="groovy"><code class="language-groovy"><span class="token spock-block">when:</span>method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>searchMapper<span class="token punctuation">,</span> responseType<span class="token punctuation">)</span> <span class="token spock-block">then:</span>responseType<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>priceDetailInfo<span class="token punctuation">.</span>viewAvgPrice <span class="token operator">==</span> price <span class="token spock-block">where:</span>price            <span class="token operator">||</span> <span class="token number">_</span>BigDecimal<span class="token punctuation">.</span>ONE   <span class="token operator">||</span> <span class="token number">_</span>BigDecimal<span class="token punctuation">.</span>TEN   <span class="token operator">||</span> <span class="token number">_</span>BigDecimal<span class="token punctuation">.</span>ZERO  <span class="token operator">||</span> <span class="token number">_</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五、Mock静态方法"><a href="#五、Mock静态方法" class="headerlink" title="五、Mock静态方法"></a>五、Mock静态方法</h3><p>业务代码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> response <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Request</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QConfigUtils</span><span class="token punctuation">.</span><span class="token function">getInsuranceConfig</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这是一个静态方法</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>单测代码实现如下:</p><pre class="line-numbers language-groovy" data-language="groovy"><code class="language-groovy"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>PowerMockRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PowerMockRunnerDelegate</span><span class="token punctuation">(</span>Sputnik<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PrepareForTest</span><span class="token punctuation">(</span><span class="token punctuation">[</span>QConfigUtils<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PowerMockIgnore</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string gstring">"javax.management.*"</span><span class="token punctuation">,</span> <span class="token string gstring">"javax.net.ssl.*"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">Specification</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        PowerMockito<span class="token punctuation">.</span><span class="token function">mockStatic</span><span class="token punctuation">(</span>QConfigUtils<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>PowerMockito<span class="token punctuation">.</span><span class="token function">when</span><span class="token punctuation">(</span>QConfigUtils<span class="token punctuation">.</span><span class="token function">getInsuranceConfig</span><span class="token punctuation">(</span><span class="token function">anyString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token string gstring">"3"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>     <span class="token annotation punctuation">@Unroll</span>    <span class="token keyword">def</span> <span class="token string gstring">"invoke"</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="六、私有方法单测"><a href="#六、私有方法单测" class="headerlink" title="六、私有方法单测"></a>六、私有方法单测</h3><pre class="line-numbers language-groovy" data-language="groovy"><code class="language-groovy"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>PowerMockRunner<span class="token punctuation">)</span><span class="token annotation punctuation">@PowerMockRunnerDelegate</span><span class="token punctuation">(</span>Sputnik<span class="token punctuation">)</span><span class="token annotation punctuation">@PowerMockIgnore</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string gstring">"javax.net.ssl.*"</span><span class="token punctuation">,</span> <span class="token string gstring">"javax.management.*"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PrepareForTest</span><span class="token punctuation">(</span><span class="token punctuation">[</span>InsuranceProcess<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> TtlOrderBookingDBFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">InsuranceProcessTest</span> <span class="token keyword">extends</span> <span class="token class-name">Specification</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">def</span> ttlOrderBookingDBFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TtlOrderBookingDBFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> iInsuranceorderDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IInsuranceorderDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> oPtorderDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OPtorderDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> InsuranceProcess <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InsuranceProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> orderPayDomain <span class="token operator">=</span> <span class="token function">Mock</span><span class="token punctuation">(</span>OrderPayDomain<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ttlOrderBookingDBFactory<span class="token punctuation">.</span>iInsuranceorderDao <span class="token operator">=</span> iInsuranceorderDao        ttlOrderBookingDBFactory<span class="token punctuation">.</span>oPtorderDao <span class="token operator">=</span> oPtorderDao        InsuranceProcess<span class="token punctuation">.</span>orderPayDomain <span class="token operator">=</span> orderPayDomain        InsuranceProcess<span class="token punctuation">.</span>ttlOrderBookingDBFactory <span class="token operator">=</span> ttlOrderBookingDBFactory    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Unroll</span>    <span class="token keyword">def</span> <span class="token string gstring">"insuranceRefund"</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token spock-block">given:</span>        InsuranceProcess<span class="token punctuation">.</span>orderPayDomain<span class="token punctuation">.</span><span class="token function">createRefund</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">>></span> refundResult        <span class="token comment">//第一个参数为对象，第二个参数为该对象的私有方法名，后面的可变参数为传入的参数</span>        <span class="token comment">//利用Whitebox.invokeMethod来反射私有方法</span>        <span class="token spock-block">when:</span>        Result result <span class="token operator">=</span> Whitebox<span class="token punctuation">.</span><span class="token function">invokeMethod</span><span class="token punctuation">(</span>InsuranceProcess<span class="token punctuation">,</span> <span class="token string gstring">"insuranceRefund"</span><span class="token punctuation">,</span> orderId<span class="token punctuation">,</span> resourceId<span class="token punctuation">,</span> billNo<span class="token punctuation">,</span> inquirySupplyId<span class="token punctuation">,</span> refundAmount<span class="token punctuation">)</span>        <span class="token spock-block">then:</span>        <span class="token function">with</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            resultCode <span class="token operator">==</span> code        <span class="token punctuation">&#125;</span>        <span class="token spock-block">where:</span>        orderId     <span class="token operator">|</span> resourceId <span class="token operator">|</span> billNo <span class="token operator">|</span> inquirySupplyId <span class="token operator">|</span> refundAmount <span class="token operator">|</span> platformUserId <span class="token operator">|</span> refundResult       <span class="token operator">||</span> code        <span class="token number">3062683975L</span> <span class="token operator">|</span> <span class="token number">37315L</span>     <span class="token operator">|</span> <span class="token number">0L</span>     <span class="token operator">|</span> <span class="token number">96446L</span>          <span class="token operator">|</span> <span class="token number">0.0</span>          <span class="token operator">|</span> <span class="token string gstring">"0"</span>            <span class="token operator">|</span> <span class="token function">getRefundResult</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">0</span>        <span class="token number">3062683975L</span> <span class="token operator">|</span> <span class="token number">37351L</span>     <span class="token operator">|</span> <span class="token number">0L</span>     <span class="token operator">|</span> <span class="token number">96446L</span>          <span class="token operator">|</span> <span class="token number">0.0</span>          <span class="token operator">|</span> <span class="token string gstring">"0"</span>            <span class="token operator">|</span> <span class="token function">getRefundResult</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">4</span>        <span class="token number">3062683975L</span> <span class="token operator">|</span> <span class="token number">37351L</span>     <span class="token operator">|</span> <span class="token number">0L</span>     <span class="token operator">|</span> <span class="token number">96446L</span>          <span class="token operator">|</span> <span class="token number">0.0</span>          <span class="token operator">|</span> <span class="token string gstring">"0"</span>            <span class="token operator">|</span> <span class="token function">getRefundResult</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">1</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Unroll</span>    <span class="token keyword">def</span> <span class="token string gstring">"checkInsuranceExpired"</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token spock-block">when:</span>        <span class="token comment">//利用普通的反射</span>        Method method <span class="token operator">=</span> InsuranceProcess<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string gstring">"checkInsuranceExpired"</span><span class="token punctuation">,</span>Calendar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>        method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Result result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>InsuranceProcess<span class="token punctuation">,</span>payExpiredTime<span class="token punctuation">)</span>        <span class="token spock-block">then:</span>        <span class="token function">with</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            resultCode <span class="token operator">==</span> status        <span class="token punctuation">&#125;</span>        <span class="token spock-block">where:</span>        payExpiredTime            <span class="token operator">||</span> status        <span class="token function">getPayExpiredTime</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token operator">||</span> <span class="token number">1</span>        <span class="token function">getPayExpiredTime</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span>     <span class="token operator">||</span> <span class="token number">2</span>        <span class="token function">getPayExpiredTime</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span>    Calendar <span class="token function">getPayExpiredTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> date<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">def</span> payExpiredTime <span class="token operator">=</span> DateTimeUtil<span class="token punctuation">.</span><span class="token function">getNowDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        payExpiredTime<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Calendar<span class="token punctuation">.</span>DATE<span class="token punctuation">,</span> date<span class="token punctuation">)</span>        <span class="token keyword">return</span> payExpiredTime    <span class="token punctuation">&#125;</span>    ActionResult<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> <span class="token function">getRefundResult</span><span class="token punctuation">(</span><span class="token keyword">int</span> resultCode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ActionResult<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> result <span class="token operator">=</span> ActionResult<span class="token punctuation">.</span><span class="token function">initActionResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">setResultCode</span><span class="token punctuation">(</span>resultCode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="七、groovy闭包的用法"><a href="#七、groovy闭包的用法" class="headerlink" title="七、groovy闭包的用法"></a>七、groovy闭包的用法</h3><p>groovy里的闭包类似于Java中的lambda表达式（但比lambda要高级一些，比如它还有委托代理的功能）</p><p>语法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//其中[closureParameters->]代表参数，多个参数用逗号分割，用->隔开参数与方法体，没有参数可以不写-></span><span class="token punctuation">&#123;</span> <span class="token punctuation">[</span>closureParameters <span class="token operator">-></span> <span class="token punctuation">]</span> statements <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常用的用法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">&#123;</span> printf <span class="token string">'Hello World'</span> <span class="token punctuation">&#125;</span>   <span class="token comment">//打印 Hello World              </span><span class="token punctuation">&#123;</span> println it <span class="token punctuation">&#125;</span>             <span class="token comment">//闭包有默认参数it，可以不用申明                       </span><span class="token punctuation">&#123;</span> name <span class="token operator">-></span> println name <span class="token punctuation">&#125;</span>   <span class="token comment">// 定义一个name参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>考虑下面的业务场景：这个方法的功能是通过<code>soaClient</code>调用接口后获取返回数据，然后进行结果转换，得到response后再做其他的业务逻辑，但是调用的接口是非核心接口，报错不会影响主流程，所以通过try/catch处理，然后继续剩下的流程，伪代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Response</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">Request</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Response</span> response <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SOAResponse</span> soaResponse <span class="token operator">=</span> soaClient<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用接口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>soaResponse <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            response<span class="token punctuation">.</span><span class="token function">setResultCode</span><span class="token punctuation">(</span>soaResponse<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            response<span class="token punctuation">.</span><span class="token function">setResultMsg</span><span class="token punctuation">(</span>soaResponse<span class="token punctuation">.</span><span class="token function">getResultMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SOAException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 其他业务逻辑</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>response <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getResultCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                           <span class="token punctuation">&#125;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getResultCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token punctuation">&#125;</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">return</span> response<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正常我们测试这个方法，更多关注的是正常业务流程是否符合预期，比如说<code>soaResponse</code>返回结果是成功<code>(success)</code>还是失败，然后catch外代码在继续其他逻辑判断，但是有一种特殊情况就是<code>&quot;soaClient.invoke&quot;</code>接口抛异常了，比如<code>TimeOutException</code>，那么下面的代码<code>&quot;if (soaResponse != null) &#123; &quot;</code>就不会执行了，这种情况如果我们不测试的话，catch外的代码可能会有问题，所以针对这种情况，单测最好也测试下，可以使用mock的方式让<code>&quot;soaClient.invoke&quot;</code>抛出一个异常出来，验证下流程是否严谨。如果希望能再where里既验证正常的业务逻辑又验证异常的逻辑，可以使用闭包的方式，如下：</p><pre class="line-numbers language-groovy" data-language="groovy"><code class="language-groovy"><span class="token annotation punctuation">@Unroll</span><span class="token keyword">def</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token spock-block">given:</span> <span class="token string gstring">"设置mock场景"</span>    soaClient<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token punctuation">&#123;</span> <span class="token function">soaResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span> <span class="token comment">// &#123; soaResponse.call() &#125; 的简化写法</span>     <span class="token spock-block">when:</span> <span class="token string gstring">"调用被测方法"</span>    <span class="token keyword">def</span> response <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token spock-block">then:</span> <span class="token string gstring">"设置需要验证的属性"</span>    response<span class="token operator">?.</span>resultCode <span class="token operator">==</span> status <span class="token comment">// ?语法类似于.Net或kotlin的空指针安全，为null则不调用resultCode属性</span>     <span class="token spock-block">where:</span> <span class="token string gstring">"验证不同业务场景"</span>    soaResponse        <span class="token operator">|</span> status    <span class="token function">getSoaResponse</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token operator">|</span> <span class="token number">0</span>    <span class="token function">getSoaResponse</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token operator">|</span> <span class="token number">1</span>    <span class="token function">getSoaResponse</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> null <span class="token comment">// 这个case就是测试接口抛异常是否影响后续流程</span><span class="token punctuation">&#125;</span> <span class="token keyword">def</span> <span class="token function">getSoaResponse</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">def</span> soaResponse <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 声明一个闭包</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>            soaResponse <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token keyword">new</span> <span class="token class-name">SOAResponse</span><span class="token punctuation">(</span><span class="token string gstring">"success"</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>            soaResponse <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token keyword">new</span> <span class="token class-name">SOAResponse</span><span class="token punctuation">(</span><span class="token string gstring">"success"</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span>        <span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            soaResponse <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SOAException</span><span class="token punctuation">(</span><span class="token string gstring">"接口异常"</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 如果不使用闭包的话，Spock编译到这里会直接抛出异常</span>            <span class="token keyword">break</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> soaResponse<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getSoaResponse()</code>方法返回的也是一个闭包，这样做的原因是因为”case:-1”是抛出一个<code>SOAException</code>异常，而不是正常的构造数据，如果不使用闭包的方式，Spock编译到这里会直接抛出异常，而<code>&quot;soaClient.invoke(_) &gt;&gt; &#123; soaResponse() &#125;&quot;</code> 这里加的花括号是表示只有在业务代码执行到<code>&quot;soaClient.invoke(_)&quot;</code> 方法时才执行闭包里的逻辑，所以这里使用了双层闭包。当然也可以针对这个异常case单独写一个单测，不放在原来的where里也可以，如果觉得闭包的语法不好理解的话。</p><h3 id="八、cleanup标签的使用"><a href="#八、cleanup标签的使用" class="headerlink" title="八、cleanup标签的使用"></a>八、cleanup标签的使用</h3><p>cleanup标签可以用于在test结束前最后一个执行的逻辑。比如你的test里面修改了数据库，但你想在测试逻辑结束后把值修改回来，就可以用这个标签。</p><pre class="line-numbers language-groovy" data-language="groovy"><code class="language-groovy"><span class="token spock-block">cleanup:</span><span class="token string gstring">"测试的最后将修改的状态改回来"</span>ttlOrderBookingDBFactory<span class="token punctuation">.</span>oTourschemeresourcebookingDao<span class="token punctuation">.</span><span class="token function">updateByOrderIdAndResourceId</span><span class="token punctuation">(</span><span class="token number">3062768228L</span><span class="token punctuation">,</span> <span class="token number">45444L</span><span class="token punctuation">,</span>ResourceBookingStatusEnum<span class="token punctuation">.</span>INBOOKING<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string gstring">"SYSTEM"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
          <category> spock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之SpringApplication的run方法</title>
      <link href="2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/"/>
      <url>2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot之SpringApplication的run方法"><a href="#springboot之SpringApplication的run方法" class="headerlink" title="springboot之SpringApplication的run方法"></a>springboot之SpringApplication的run方法</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p><code>springboot</code>与<code>spring</code>的区别有两个地方：</p><p>（1）在<code>Springboot01HelloworldApplication</code>主启动类上添加了注解<code>@SpringBootApplication</code></p><p>（2）main方法调用了<code>SpringApplication.run(Springboot01HelloworldApplication.class, args);</code></p><p>这里主要先解析第二点。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h3><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/1.png" class title="springboot.run的原理"><h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3.执行流程"></a>3.执行流程</h3><h4 id="3-1创建SpringApplication实例"><a href="#3-1创建SpringApplication实例" class="headerlink" title="3.1创建SpringApplication实例"></a>3.1创建SpringApplication实例</h4><p>1） 如果我们使用的是<code>SpringApplication的静态run方法</code>，那么，这个方法里面<code>首先要创建一个SpringApplication对象实例</code>，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> primarySources<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2）创建SpringApplication实例的时候走它的构造方法初始化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">ResourceLoader</span> resourceLoader<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> primarySources<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    、、、省略代码    <span class="token comment">//配置source</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">=</span> resourceLoader<span class="token punctuation">;</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">,</span> <span class="token string">"PrimarySources must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>primarySources <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取应用类型，判断是否是wen应用</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationType <span class="token operator">=</span> <span class="token class-name">WebApplicationType</span><span class="token punctuation">.</span><span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>bootstrapRegistryInitializers <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBootstrapRegistryInitializersFromSpringFactories</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取所有初始化器</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取所有监听器</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setListeners</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//定位main方法</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deduceMainApplicationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-1-1-获取应用类型"><a href="#3-1-1-获取应用类型" class="headerlink" title="3.1.1 获取应用类型"></a>3.1.1 获取应用类型</h5><p>跟踪deduceFromClasspath方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">WebApplicationType</span> <span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token string">"org.springframework.web.reactive.DispatcherHandler"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>  <span class="token operator">!</span><span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token string">"org.springframework.web.servlet.DispatcherServlet"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token string">"org.glassfish.jersey.servlet.ServletContainer"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> REACTIVE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"javax.servlet.Servlet"</span><span class="token punctuation">,</span><span class="token string">"org.springframework.web.context.ConfigurableWebApplicationContext"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> var1 <span class="token operator">=</span> var0<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var2 <span class="token operator">&lt;</span> var1<span class="token punctuation">;</span> <span class="token operator">++</span>var2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> className <span class="token operator">=</span> var0<span class="token punctuation">[</span>var2<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> NONE<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> SERVLET<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从返回结果我们可以看出应用类型一共有三种，分别是<br> <code>NONE</code>： 非web应用，即不会启动服务器<br> <code>SERVLET</code>： 基于servlet的web应用<br> <code>REACTIVE</code>： 响应式web应用</p><h5 id="3-1-2-获取初始化器"><a href="#3-1-2-获取初始化器" class="headerlink" title="3.1.2 获取初始化器"></a>3.1.2 获取初始化器</h5><p>跟踪进入<code>getSpringFactoriesInstances</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Use names and ensure unique to protect against duplicates</span><span class="token comment">//获取所有初始化器的名称集合，调用的是熟悉的SpringFactoriesLoader.loadFactoryNames方法</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//根据名称集合通过反射实例化这些初始化器，见下方法</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> instances <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createSpringFactoriesInstances</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> parameterTypes<span class="token punctuation">,</span> classLoader<span class="token punctuation">,</span> args<span class="token punctuation">,</span> names<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//排序</span>    <span class="token class-name">AnnotationAwareOrderComparator</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>instances<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> instances<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">createSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> names<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> instances <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>names<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Iterator</span> var7 <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>var7<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>var7<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> instanceClass <span class="token operator">=</span> <span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">isAssignable</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> instanceClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> constructor <span class="token operator">=</span> instanceClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>parameterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">T</span> instance <span class="token operator">=</span> <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">instantiateClass</span><span class="token punctuation">(</span>constructor<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            instances<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var12<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Cannot instantiate "</span> <span class="token operator">+</span> type <span class="token operator">+</span> <span class="token string">" : "</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> var12<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> instances<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从代码可以看出是在<code>META-INF/spring.factories</code>配置文件里获取初始化器，然后实例化、排序后再设置到<code>initializers</code>属性中。</p><h5 id="3-1-3-获取监听器"><a href="#3-1-3-获取监听器" class="headerlink" title="3.1.3 获取监听器"></a>3.1.3 获取监听器</h5><p>同样跟踪源码，发现其实监听器和初始化的操作调用的方法是一样的，只是参数不同。</p><h5 id="3-1-4-定位main方法"><a href="#3-1-4-定位main方法" class="headerlink" title="3.1.4 定位main方法"></a>3.1.4 定位main方法</h5><p>跟踪源码进入<code>deduceMainApplicationClass</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">deduceMainApplicationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//通过创建运行时异常的方式获取栈</span>        <span class="token class-name">StackTraceElement</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stackTrace <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">StackTraceElement</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var2 <span class="token operator">=</span> stackTrace<span class="token punctuation">;</span>        <span class="token keyword">int</span> var3 <span class="token operator">=</span> stackTrace<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token comment">//遍历获取main方法所在的类并且返回</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var4 <span class="token operator">&lt;</span> var3<span class="token punctuation">;</span> <span class="token operator">++</span>var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">StackTraceElement</span> stackTraceElement <span class="token operator">=</span> var2<span class="token punctuation">[</span>var4<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>stackTraceElement<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>stackTraceElement<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> var6<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2调用run方法"><a href="#3-2调用run方法" class="headerlink" title="3.2调用run方法"></a>3.2调用run方法</h4><p>调用springbootApplication对象的run方法，实现启动，返回当前容器的上下文</p><p>进入run方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 启动任务执行的时间监听器</span>    <span class="token class-name">StopWatch</span> stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//声明应用上下文</span>    <span class="token class-name">DefaultBootstrapContext</span> bootstrapContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createBootstrapContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ConfigurableApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//设置系统java.awt.headless属性，默认为true</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取监听器，它的作用是为后期一些环境参数进行赋值，就是加载配置文件</span>    <span class="token comment">// 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories下的SpringApplicationRunListeners并实例化</span>    <span class="token class-name">SpringApplicationRunListeners</span> listeners <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//遍历调用SpringApplicationRunListener的starting方法，内部是一个lambda表达式，用了consumer函数式接口</span>    listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建SpringBoot默认启动参数对象，将args包装成ApplicationArguments类</span>        <span class="token class-name">ApplicationArguments</span> applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ********监听器开始对对环境参数进行赋值***********</span>        <span class="token comment">//创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）</span>        <span class="token comment">//同时遍历调用所有listener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment已经准备好了”。</span>        <span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span> bootstrapContext<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">configureIgnoreBeanInfo</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//打印启动图案</span>        <span class="token class-name">Banner</span> printedBanner <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 根据应用类型WebApplicationType(3.1.1)，创建对应类型上下文ConfigurableApplicationContext</span>        context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//为上下文设置ApplicationStartup。这允许应用程序上下文在启动期间记录指标</span>        context<span class="token punctuation">.</span><span class="token function">setApplicationStartup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationStartup<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 准备Spring上下文环境</span>        <span class="token comment">// 在这个方法中，主要完成了以下几件事：</span>        <span class="token comment">//  1、context.setEnvironment(environment)：设置SpringBoot的环境配置(Environment)</span>        <span class="token comment">//  2、postProcessApplicationContext()：注册Spring Bean名称的序列化器BeanNameGenerator，并设置资源加载器ResourceLoader</span>        <span class="token comment">//  3、applyInitializers()：通过SpringFactoriesLoader加载ApplicationContextInitializer初始化器，并进行初始化</span>        <span class="token comment">//  4、listeners.contextPrepared(context)：调用所有的listener的contextPrepared方法，通知这些Listener当前ApplicationContext已经创建完毕。</span>        <span class="token comment">//  5、最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</span>        <span class="token comment">//  6、listeners.contextLoaded(context)：通知这些Listener当前ApplicationContext已经加载完毕。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareContext</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用refreshContext，调用registerShutdownHook()方法，注册一个关闭Spring容器的钩子ShutdownHook，此方法新开了一条线程，当程序在停止的时候执行doClose()方法释放资源（包括：销毁Bean（destroyBeans()），关闭SpringBean的创建工厂（closeBeanFactory()）等）</span>        <span class="token comment">// 同时刷新上下文</span>        <span class="token comment">// 注： 钩子可以在以下几种场景中被调用：</span>        <span class="token comment">// 1）程序正常退出</span>        <span class="token comment">// 2）使用System.exit()</span>        <span class="token comment">// 3）终端使用Ctrl+C触发的中断</span>        <span class="token comment">// 4）系统关闭</span>        <span class="token comment">// 5）使用Kill pid命令杀死进程</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//刷新后的方法，空方法，给用户自定义重写</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//结束计时</span>        stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//输出日志记录执行主类名、时间信息</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token comment">//********* 使用广播和回调机制告诉监听者springboot容器已经启动化成功**********</span>        listeners<span class="token punctuation">.</span><span class="token function">started</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取当前所有ApplicationRunner和CommandLineRunner接口的实现类，执行其run方法</span>        <span class="token comment">// ApplicationRunner和CommandLineRunner功能基本一样，在Spring容器启动完成时执行，唯一不同的是ApplicationRunner的run方法入参是ApplicationArguments，而CommandLineRunner是String数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callRunners</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var10<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> var10<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>var10<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//********* 使用广播和回调机制告诉已经可以运行springboot了**********</span>        listeners<span class="token punctuation">.</span><span class="token function">running</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//返回上下文</span>        <span class="token keyword">return</span> context<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var9<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> var9<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">SpringApplicationRunListeners</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>var9<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3springboot启动流程总结"><a href="#3-3springboot启动流程总结" class="headerlink" title="3.3springboot启动流程总结"></a>3.3springboot启动流程总结</h4><pre class="line-numbers language-none"><code class="language-none">--------------------------------创建springbootApplication对象---------------------------------------------1. 创建springbootApplication对象springboot容器初始化操作2. 获取当前应用的启动类型。注1：通过判断当前classpath是否加载servlet类，返回servlet web启动方式。注2：webApplicationType三种类型：1.reactive：响应式启动（spring5新特性）2.none:即不嵌入web容器启动（springboot放在外部服务器运行 ）3.servlet:基于web容器进行启动3. 读取springboot下的META-INFO&#x2F;spring.factories文件，获取对应的ApplicationContextInitializer装配到集合4. 读取springboot下的META-INFO&#x2F;spring.factories文件，获取对应的ApplicationListener装配到集合5. 定位main方法------------------调用springbootApplication对象的run方法，实现启动，返回当前容器的上下文----------------------------------------------6. 调用run方法启动7. StopWatch stopWatch &#x3D; new StopWatch()，记录项目启动时间8. getRunListeners，读取META-INF&#x2F;spring.factores，将SpringApplicationRunListeners类型存到集合中9. listeners.starting();循环调用starting方法10. prepareEnvironment(listeners, applicationArguments);将配置文件读取到容器中读取多数据源：classpath:&#x2F;,classpath:&#x2F;config&#x2F;,file:.&#x2F;,file:.&#x2F;config&#x2F;底下。其中classpath是读取编译后的，file是读取编译前的支持yml，yaml，xml，properties同时遍历调用所有listener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment已经准备好了”。11. Banner printedBanner &#x3D; printBanner(environment);开始打印banner图，就是sprongboot启动最开头的图案12. 根据应用类型WebApplicationType(3.1.1)，创建对应类型上下文ConfigurableApplicationContext13. 为上下文设置ApplicationStartup。这允许应用程序上下文在启动期间记录指标14. 准备Spring上下文环境        在这个方法中，主要完成了以下几件事：        1、context.setEnvironment(environment)：设置SpringBoot的环境配置(Environment)        2、postProcessApplicationContext()：注册Spring Bean名称的序列化器BeanNameGenerator，并设置资源加载器ResourceLoader        3、applyInitializers()：通过SpringFactoriesLoader加载ApplicationContextInitializer初始化器，并进行初始化        4、listeners.contextPrepared(context)：调用所有的listener的contextPrepared方法，通知这些Listener当前ApplicationContext已经创建完毕。        5、最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。        6、listeners.contextLoaded(context)：通知这些Listener当前ApplicationContext已经加载完毕。15. 调用refreshContext，调用registerShutdownHook()方法，注册一个关闭Spring容器的钩子ShutdownHook，此方法新开了一条线程，当程序在停止的时候执行doClose()方法释放资源（包括：销毁Bean（destroyBeans()），关闭SpringBean的创建工厂（closeBeanFactory()）等）16. 刷新后的方法，空方法，给用户自定义重写afterRefresh（）17. stopWatch.stop();结束计时18. 使用广播和回调机制告诉监听者springboot容器已经启动化成功，listeners.started(context);19. 获取当前所有ApplicationRunner和CommandLineRunner接口的实现类，执行其run方法20. 使用广播和回调机制告诉监听者springboot容器已经在运行，listeners.running(context);21. 返回上下文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-零碎知识点深入探析"><a href="#4-零碎知识点深入探析" class="headerlink" title="4.零碎知识点深入探析"></a>4.零碎知识点深入探析</h3><h4 id="4-1监听器"><a href="#4-1监听器" class="headerlink" title="4.1监听器"></a>4.1监听器</h4><p><code>run</code>方法代码里面<code>listeners</code>出现了很多次，调用了<code>starting</code>，<code>started</code>，<code>running</code>等方法。这时候你可能会问，那他们又有什么区别呢？首先，我们先跟踪源码看看这个<code>listeners</code>到底是什么。<br> 我们进入<code>getRunListeners</code>方法，可以看到</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">SpringApplicationRunListeners</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplicationRunListeners</span><span class="token punctuation">(</span>logger<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">SpringApplicationRunListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> types<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>getSpringFactoriesInstances</code>方法大家看了前面的现在应该知道了，这段代码的意思就是要去所有的META-INF文件下的<code>spring.factories</code>寻找关于key为<code>SpringApplicationRunListener</code>的value配置，ok，那我们找找，可以发现在这里存在</p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/2.png" class title="spring.factories"><p>这个方法最后返回的是<code>org.springframework.boot.context.event.EventPublishingRunListener</code>这个类，那我们就打开这个类看看是啥。</p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/3.png" class title="EventPublishingRunListener"><p>这个方法它实现了<code>SpringApplicationRunListener</code>接口，那么，这个接口是干啥的呢？没错，他就是用来加载我们配置文件用的。接下来我弄个简单的例子，大家就知道怎么用了。</p><p><strong>EventPublishingRunListener接口举例</strong></p><p>主要实现自定义监听器并且读取我们配置文件内容，先献上我的文件结构</p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/6.png" class title="目录结构"><p>创建一个<code>springboot</code>项目，添加<code>web</code>依赖</p><p>在<code>resource</code>自定义配置文件<code>my.properties</code></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">tzr.name</span><span class="token punctuation">=</span><span class="token attr-value">xxj</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自定义监听器，这里主要是对<code>starting</code>、<code>environmentPrepared</code>、<code>started</code>、<code>running</code>方法进行实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itxxj<span class="token punctuation">.</span>springbootlisten</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplicationRunListener</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">ConfigurableApplicationContext</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Ordered</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>env<span class="token punctuation">.</span></span><span class="token class-name">ConfigurableEnvironment</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>env<span class="token punctuation">.</span></span><span class="token class-name">MutablePropertySources</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>env<span class="token punctuation">.</span></span><span class="token class-name">PropertiesPropertySource</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>env<span class="token punctuation">.</span></span><span class="token class-name">PropertySource</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Properties</span><span class="token punctuation">;</span><span class="token comment">/** * 集成监听器加载我们的配置文件 * @author xxj * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyListener</span> <span class="token keyword">implements</span> <span class="token class-name">SpringApplicationRunListener</span><span class="token punctuation">,</span> <span class="token class-name">Ordered</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">SpringApplication</span> application<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"表示准备开始使用监听器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">MyListener</span><span class="token punctuation">(</span><span class="token class-name">SpringApplication</span> application<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>application <span class="token operator">=</span> application<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>args <span class="token operator">=</span> args<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">environmentPrepared</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableEnvironment</span> environment<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"表示已经开始读取配置文件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//配置文件到程序，再然后放入springboot容器</span>        <span class="token class-name">Properties</span> properties<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//读取properties容器</span>            properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"my.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//读取名字为my</span>            <span class="token class-name">PropertySource</span> propertySource<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">PropertiesPropertySource</span><span class="token punctuation">(</span><span class="token string">"my"</span><span class="token punctuation">,</span>properties<span class="token punctuation">)</span> <span class="token punctuation">;</span>            <span class="token comment">//加载资源到springboot容器</span>            <span class="token class-name">MutablePropertySources</span> propertySources<span class="token operator">=</span>environment<span class="token punctuation">.</span><span class="token function">getPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            propertySources<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>propertySource<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//换种思路，如果你配置文件是放在网络上，可以直接读取放入我们的项目中</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextPrepared</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextLoaded</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">started</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"表示初始化容器已经结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">running</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"表示可以使用springboot了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> exception<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//读取优先级</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编写controller文件对我们的配置参数进行调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itxxj<span class="token punctuation">.</span>springbootlisten<span class="token punctuation">.</span>controller</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Value</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Controller</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMapping</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">ResponseBody</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;tzr.name&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> x <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那我们自定义的监听器springboot程序又是如何获取的？前面我们代码里讲过了，它主要是读取META-INF底下的spring.factories文件，然后获取监听器。那么我们直接照着EventPublishingRunListener一样在resource增加METAA_INF/spring.factories文件</p><pre class="line-numbers language-none"><code class="language-none">org.springframework.boot.SpringApplicationRunListener&#x3D;\com.itxxj.springbootlisten.MyListener<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后设置spring启动器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itxxj<span class="token punctuation">.</span>springbootlisten</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span><span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootListenApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringbootListenApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动，可以看到启动信息</p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/4.png" class title="启动信息"><p>然后我们再调用<code>controller</code>方法</p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/5.png" class title="读取的配置信息"><p>成功读取我们自定义的配置文件</p><h4 id="4-2引入注解"><a href="#4-2引入注解" class="headerlink" title="4.2引入注解"></a>4.2引入注解</h4><p><code>springboot</code>的启动分为两部分，一部分是注解，一部分是<code>SpringApplication.run(Springboot.class, args)</code>，那么我们的注解又是如何嵌入到程序中呢？靠的就是<code>refreshContext</code>方法，同理，我们跟踪源码进入<code>refreshContext</code>方法</p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/7.png" class title="refresh"><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/8.png" class title="refresh"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalStateException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">StartupStep</span> contextRefresh <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationStartup<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"spring.context.refresh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//  准备这个上下文来刷新。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//  告诉子类刷新内部bean工厂。</span>        <span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//  准备bean在此上下文中使用。</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//  允许在上下文子类中对bean工厂进行后期处理。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">StartupStep</span> beanPostProcess <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationStartup<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"spring.context.beans.post-process"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  调用在上下文中注册为bean的工厂处理器。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  注册用于拦截创建bean的bean处理器。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            beanPostProcess<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  初始化此上下文的消息源。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  为此上下文初始化事件多播。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  在特定的上下文子类中初始化其他特殊bean。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  检查侦听器beans并注册它们。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  实例化所有剩余的(non-lazy-init)单例。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  最后一步：发布相应事件.</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> var10<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> <span class="token operator">+</span> var10<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token comment">//  销毁已经创建的单例以避免悬空资源。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">destroyBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  重置“active”标志。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cancelRefresh</span><span class="token punctuation">(</span>var10<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//  向调用者传播异常。</span>            <span class="token keyword">throw</span> var10<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//  重置Spring核心中常见的内省缓存，因为我们可能不再需要单例bean的元数据了。。。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resetCommonCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            contextRefresh<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，就可以看到一系列bean的操作，继续跟踪进入<code>invokeBeanFactoryPostProcessors</code>（调用在上下文中注册为<code>bean</code>的工厂处理器）方法</p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/9.png" class title="引入注解"><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/10.png" class title="引入注解"><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/11.png" class title="引入注解"><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/12.png" class title="引入注解"><p>进入<code>ConfigurationClassParser</code>这个类后，发现对于<code>springboot</code>注解的解析和引用就是在这个类进行的，比如<code>processConfigBeanDefinitions</code>等方法：</p><h4 id="4-3内置tomcat"><a href="#4-3内置tomcat" class="headerlink" title="4.3内置tomcat"></a>4.3内置tomcat</h4><p>其实，内置<code>tomcat</code>应该要归在<code>refreshContext</code>讲的，因为<code>tomcat</code>就是在注解引入的类中生成的，而<code>refreshContext</code>可以引入注解。不过为了更清楚，这里分开吧。前面说了，我们<code>refreshContext</code>是刷新上下文，那如果想要知道上下文中是否存在生成tomcat的类，我们直接去最后返回的上下文中找对应的类即可！</p><p>我们在main方法写获取上下文的代码，并且打印出对应的name</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootListenApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ConfigurableApplicationContext</span> configurableApplicationContext <span class="token operator">=</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringbootListenApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> xs <span class="token operator">=</span> configurableApplicationContext<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> x <span class="token operator">:</span> xs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接启动，可以看到有<code>org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration</code>这个类</p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/13.png" class title="输出"><p>我们点开这个类，跟踪源码</p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/14.png" class title="ServletWebServerFactoryAutoConfiguration类"><p>我们知道，<code>springboot</code>其实有三种内容服务器，分别是<code>Tomcat，Jetty，Undertow</code>。默认内置<code>tomcat</code>，。我们继续跟踪<code>EmbeddedTomcat.class</code></p><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/15.png" class title="EmbeddedTomcat"><img src="/2021/06/16/springboot-zhi-springapplication-de-run-fang-fa/16.png" class title="TomcatServletWebServerFactory"><p>可以看到，其实这里的tomcat服务器是内部通过java代码实现的。其实，<code>run()</code>方法总结起来并不多，大方向无非是配置环境参数，引入注解刷新上下文。其他的一些捕获异常、计时操作都是非重点操作。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> springboot启动原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> SpringApplication的run方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring注解-元数据/元注解</title>
      <link href="2021/06/11/spring-zhu-jie-yuan-zhu-jie-yuan-shu-ju/"/>
      <url>2021/06/11/spring-zhu-jie-yuan-zhu-jie-yuan-shu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="spring注解-元数据-元注解"><a href="#spring注解-元数据-元注解" class="headerlink" title="spring注解-元数据/元注解"></a>spring注解-元数据/元注解</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>Spring在2.0的时候就支持了基于XML Schema的扩展机制，让我们可以自定义的对xml配置文件进行扩展（四大步骤，有兴趣的可以自己学习），比如鼎鼎大名的Dubbo它就扩展了xml，用它来引入服务或者导出服务。<br>随着Spring3.0+的发展，xml慢慢的淡出了我们的视野，特别是Spring Boot的流行让xml彻底消失，所有的xml配置都使用注解的方式进行了代替。本文就着眼于比较费解的元数据(<code>Metadata</code>)和元注解(<code>meta-annotation</code>)进行分析，给深入理解注解编程铺路。</p><h3 id="2-什么是元数据和元注解"><a href="#2-什么是元数据和元注解" class="headerlink" title="2.什么是元数据和元注解"></a>2.什么是元数据和元注解</h3><p><strong>什么是元数据（MetaData）</strong></p><p>先直接贴一个英文解释：</p><blockquote><p>Metadata is simply data about data. It means it is a description and  context of the data. It helps to organize, find and understand data。</p></blockquote><p>上面介绍的大概意思是：元数据是关于数据的数据，元数据是数据的描述和上下文，它有助于组织，查找，理解和使用数据。比如Class就是一种元数据。<code>Metadata</code>在<code>org.springframework.core.type</code>包名下，还有用于读取的子包<code>classreading</code>也是重要知识点。此体系大致的结构树如下：</p><img src="/2021/06/11/spring-zhu-jie-yuan-zhu-jie-yuan-shu-ju/Metadata.png" class title="Metadata"><img src="/2021/06/11/spring-zhu-jie-yuan-zhu-jie-yuan-shu-ju/ReadingVisitor.png" class title="ReadingVisitor"><p>可以看到顶层接口有两个：<code>ClassMetadata</code>和<code>AnnotatedTypeMetadata</code>。</p><h3 id="3-ClassMetadata：对Class的抽象和适配"><a href="#3-ClassMetadata：对Class的抽象和适配" class="headerlink" title="3.ClassMetadata：对Class的抽象和适配"></a>3.ClassMetadata：对<code>Class</code>的抽象和适配</h3><p>ClassMetadata，顾名思义，就是<strong>表示 Java 中类的元数据</strong>。那么类的元数据有哪些呢，打开ClassMetadata的源代码（代码就不贴了），大致有下面这些：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ClassMetadata</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 返回类名（注意返回的是最原始的那个className）</span>    <span class="token class-name">String</span> <span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//是否是接口</span>    <span class="token keyword">boolean</span> <span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//是否是注解</span>    <span class="token keyword">boolean</span> <span class="token function">isAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//是否是抽象类</span>    <span class="token keyword">boolean</span> <span class="token function">isAbstract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不是接口且不是抽象类  这里就返回true了</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">isConcrete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isAbstract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//是否是final类：当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</span>    <span class="token keyword">boolean</span> <span class="token function">isFinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//是否是独立的(能够创建对象的)  比如是Class、或者内部类、静态内部类</span>    <span class="token keyword">boolean</span> <span class="token function">isIndependent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 是否有内部类之类的</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">hasEnclosingClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEnclosingClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//enclosing class和Nested Class是相对的；一个为内部类，一个是定义内部类的外部类；</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">String</span> <span class="token function">getEnclosingClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">hasSuperClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuperClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">String</span> <span class="token function">getSuperClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 会把实现的所有接口名称都返回  具体依赖于Class#getSuperclass</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getInterfaceNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//getClasses() ： 返回本类所有访问权限的内部类</span>    <span class="token comment">//getDeclaredClasses：返回public的内部类和父类的内部类</span><span class="token comment">// 基于：Class#getDeclaredClasses  返回类中定义的公共、私有、保护的内部类</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMemberClassNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其结构图如下：</p><img src="/2021/06/11/spring-zhu-jie-yuan-zhu-jie-yuan-shu-ju/1.png" class title="ClassMetadata"><p>从上面的类图中可以看出，ClassMetadata有一个实现类是StandardClassMetadata，这个类是基于反射实现获取类元数据的，这个也是类名中“Standard”的含义。</p><p>查看源代码你可以发现这个类唯一的一个构造函数已经被标注@Deprecated了，所以这个类已经不建议直接使用了。</p><h3 id="4-AnnotatedTypeMetadata：对注解元素的封装适配"><a href="#4-AnnotatedTypeMetadata：对注解元素的封装适配" class="headerlink" title="4.AnnotatedTypeMetadata：对注解元素的封装适配"></a>4.AnnotatedTypeMetadata：对注解元素的封装适配</h3><p>这个接口表示的是注解元素(AnnotatedElement)的元数据。那什么是注解元素呢？</p><p>我们常见的Class、Method、Constructor、Parameter等等都属于它的子类都属于注解元素。简单理解：只要能在上面标注注解的元素都属于这种元素。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AnnotatedTypeMetadata</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">MergedAnnotations</span> <span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 此元素是否标注有此注解,annotationName：注解全类名</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">isAnnotated</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span>annotationName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span>annotationName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//取得指定类型注解的所有的属性 - 值（k-v）</span>    <span class="token comment">// annotationName：注解全类名</span>    <span class="token comment">// classValuesAsString：若是true表示 Class用它的字符串的全类名来表示。这样可以避免Class被提前加载</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> classValuesAsString<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 支持重复注解</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> <span class="token class-name">MultiValueMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">getAllAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">default</span> <span class="token class-name">MultiValueMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">getAllAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> classValuesAsString<span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其结构图如下：</p><img src="/2021/06/11/spring-zhu-jie-yuan-zhu-jie-yuan-shu-ju/2.png" class title="AnnotatedTypedMetadata"><p>两个子接口相应的都提供了标准实现以及基于ASM的Visitor模式实现。</p><p>ASM 是一个通用的 Java 字节码操作和分析框架。它可以用于修改现有类或直接以二进制形式动态生成类。 ASM 虽然提供与其他 Java 字节码框架如 Javassist，CGLIB类似的功能，但是其设计与实现小而快，且性能足够高。</p><h3 id="5-AnnotationMetadata"><a href="#5-AnnotationMetadata" class="headerlink" title="5.AnnotationMetadata"></a>5.AnnotationMetadata</h3><p>这是理解<code>Spring</code>注解编程的必备知识，它是<code>ClassMetadata</code>和<code>AnnotatedTypeMetadata</code>的子接口，具有两者共同能力，并且新增了访问注解的相关方法。可以简单理解为它是对注解的抽象。</p><blockquote><p>经常这么使用得到注解里面所有的属性值：<br> <code>AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(annoMetadata, annType);</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AnnotationMetadata</span> <span class="token keyword">extends</span> <span class="token class-name">ClassMetadata</span><span class="token punctuation">,</span> <span class="token class-name">AnnotatedTypeMetadata</span> <span class="token punctuation">&#123;</span><span class="token comment">//拿到当前类上所有的注解的全类名（注意是全类名）</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getAnnotationTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 拿到指定的注解类型</span><span class="token comment">//annotationName:注解类型的全类名</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getMetaAnnotationTypes</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 是否包含指定注解 （annotationName：全类名）</span><span class="token keyword">boolean</span> <span class="token function">hasAnnotation</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这个厉害了，用于判断注解类型自己是否被某个元注解类型所标注</span><span class="token comment">//依赖于AnnotatedElementUtils#hasMetaAnnotationTypes</span><span class="token keyword">boolean</span> <span class="token function">hasMetaAnnotation</span><span class="token punctuation">(</span><span class="token class-name">String</span> metaAnnotationName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 类里面只有有一个方法标注有指定注解，就返回true</span><span class="token comment">//getDeclaredMethods获得所有方法， AnnotatedElementUtils.isAnnotated是否标注有指定注解</span><span class="token keyword">boolean</span> <span class="token function">hasAnnotatedMethods</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回所有的标注有指定注解的方法元信息。注意返回的是MethodMetadata 原理基本同上</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MethodMetadata</span><span class="token punctuation">></span></span> <span class="token function">getAnnotatedMethods</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//使用标准反射为给定类创建新的 AnnotationMetadata 实例的工厂方法。</span>    <span class="token keyword">static</span> <span class="token class-name">AnnotationMetadata</span> <span class="token function">introspect</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的它提供了两种实现方式。</p><p>AnnotationMetadata有三个实现类:<code>SimpleAnnotationMetadata</code>，<code>StandardAnnotationMetadata</code>，<code>AnnotationMetadataReadingVisitor</code></p><p>其中<code>StandardAnnotationMetadata</code>和<code>SimpleAnnotationMetadata</code>主要使用 Java 反射原理获取元数据，而 <code>AnnotationMetadataReadingVisitor</code> 使用 ASM 框架获取元数据。但是现在<code>StandardAnnotationMetadata</code>已经被弃用了，所以标准方式我们分析<code>SimpleAnnotationMetadata</code>，而ASM方式我们分析<code>AnnotationMetadataReadingVisitor</code>。</p><p><strong>SimpleAnnotationMetadata</strong></p><p>SimpleAnnotationMetadata继承了<code>AnnotationMetadata</code>，很明显关于<code>ClassMetadata</code>的实现部分就交给<code>ClassMetadata</code>的实现类了，自己只关注于<code>AnnotationMetadata</code>接口的实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SimpleAnnotationMetadata</span> <span class="token keyword">implements</span> <span class="token class-name">AnnotationMetadata</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MethodMetadata</span><span class="token punctuation">[</span><span class="token punctuation">]</span> annotatedMethods<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MergedAnnotations</span> annotations<span class="token punctuation">;</span>        <span class="token comment">// 获取本Class类上的所有注解</span>    <span class="token comment">//调用了父类接口实现的AnnotationMetadata.super.getAnnotationTypes()方法。</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getAnnotationTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> annotationTypes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>annotationTypes<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>annotationTypes <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>annotationTypes <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableSet</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getAnnotationTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>annotationTypes <span class="token operator">=</span> annotationTypes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> annotationTypes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MethodMetadata</span><span class="token punctuation">></span></span> <span class="token function">getAnnotatedMethods</span><span class="token punctuation">(</span><span class="token class-name">String</span> annotationName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MethodMetadata</span><span class="token punctuation">></span></span> annotatedMethods <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MethodMetadata</span> annotatedMethod <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>annotatedMethods<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>annotatedMethod<span class="token punctuation">.</span><span class="token function">isAnnotated</span><span class="token punctuation">(</span>annotationName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>annotatedMethods <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>annotatedMethods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>annotatedMethods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>annotatedMethod<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> annotatedMethods <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> annotatedMethods <span class="token operator">:</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">MergedAnnotations</span> <span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>annotations<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>AnnotationMetadataReadingVisitor</strong></p><p>ASM 是一个通用的 Java 字节码操作和分析框架。它可以用于修改现有类或直接以二进制形式动态生成类。 ASM 虽然提供与其他 Java 字节码框架如 <code>Javassist</code>，<code>CGLIB  </code>类似的功能，但是其设计与实现小而快，且性能足够高。</p><p>Spring 直接将 ASM 框架核心源码内嵌于 <code>Spring-core</code>中。</p><p><strong>ASM 框架简单应用</strong></p><p>Java 源代码经过编译器编译之后生成了 <code>.class </code> 文件。</p><blockquote><p>Class文件是有8个字节为基础的字节流构成的，这些字节流之间都严格按照规定的顺序排列，并且字节之间不存在任何空隙，对于超过8个字节的数据，将按  照Big-Endian的顺序存储的，也就是说高位字节存储在低的地址上面，而低位字节存储到高地址上面，其实这也是class文件要跨平台的关键，因为  PowerPC架构的处理采用Big-Endian的存储顺序，而x86系列的处理器则采用Little-Endian的存储顺序，因此为了Class文 件在各中处理器架构下保持统一的存储顺序，虚拟机规范必须对起进行统一。</p></blockquote><p>Class 文件中包含类的所有信息，如接口，字段属性，方法，在内部这些信息按照一定规则紧凑排序。ASM 框会以文件流的形式读取 class 文件，然后解析过程中使用观察者模式（Visitor），当解析器碰到相应的信息委托给观察者（Visitor）。</p><p>使用 ASM 框架首先需要继承 <code>ClassVisitor</code>，完成解析相应信息，如解析方法，字段等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token namespace">jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>org<span class="token punctuation">.</span>objectweb<span class="token punctuation">.</span>asm<span class="token punctuation">.</span></span><span class="token class-name">Opcodes</span><span class="token punctuation">.</span>ASM4<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassPrinter</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ClassPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//传入API的值 该字段的值必须为如下几个之一：Opcodes.ASM4，ASM5，ASM6，ASM7</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>ASM4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> version<span class="token punctuation">,</span> <span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span> superName<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" extends "</span> <span class="token operator">+</span> superName <span class="token operator">+</span> <span class="token string">"&#123;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">AnnotationVisitor</span> <span class="token function">visitAnnotation</span><span class="token punctuation">(</span><span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token keyword">boolean</span> visible<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"    "</span> <span class="token operator">+</span> desc <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">FieldVisitor</span> <span class="token function">visitField</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"    "</span> <span class="token operator">+</span> desc <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"  "</span> <span class="token operator">+</span> <span class="token class-name">Type</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span>desc<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">MethodVisitor</span> <span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> access<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> descriptor<span class="token punctuation">,</span> <span class="token class-name">String</span> signature<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> exceptions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"    "</span> <span class="token operator">+</span> name <span class="token operator">+</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用 <code>ClassReader</code> 读取类文件，然后再使用 <code>ClassReader#accpet</code> 接受 <code>ClassVisitor</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ClassPrinter</span> classPrinter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ClassReader</span> classReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassReader</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        classReader<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>classPrinter<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>控制台输出如下：<span class="token class-name">Person</span> <span class="token keyword">extends</span> java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">Object</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span> name  <span class="token keyword">class</span> <span class="token class-name"><span class="token namespace">jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>org<span class="token punctuation">.</span>objectweb<span class="token punctuation">.</span>asm<span class="token punctuation">.</span></span>Type</span>    <span class="token class-name">I</span> age  <span class="token keyword">class</span> <span class="token class-name"><span class="token namespace">jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>org<span class="token punctuation">.</span>objectweb<span class="token punctuation">.</span>asm<span class="token punctuation">.</span></span>Type</span>    <span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">V</span>    <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span>    <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token class-name">V</span>    <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">I</span>    <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token class-name">I</span><span class="token punctuation">)</span><span class="token class-name">V</span>    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 <code>ClassVisitor</code> 相应方法可以用来解析类的相关信息，这里我们主要关注解析类上注解信息。这里没有注解就没有注解信息。解析注解将会在 <code>ClassVisitor#visitAnnotation</code>完成解析。 该方法返回了一个 <code>AnnotationVisitor</code> 对象，其也是一个 Visitor 对象。后续解析器会继续调用 <code>AnnotationVisitor</code>内部方法进行再次解析。</p><p>回到<code>AnnotationMetadataReadingVisitor</code>，发现是继承了<code>ClassMetadataReadingVisitor</code>，而<code>ClassMetadataReadingVisitor</code>继承ClassVisitor实现了visit的功能。但是实际上<code>AnnotationMetadataReadingVisitor</code>已经被弃用，现在都是使用<code>SimpleAnnotationMetadataReadingVisitor</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationMetadataReadingVisitor</span> <span class="token keyword">extends</span> <span class="token class-name">ClassMetadataReadingVisitor</span> <span class="token keyword">implements</span> <span class="token class-name">AnnotationMetadata</span>    <span class="token keyword">class</span> <span class="token class-name">ClassMetadataReadingVisitor</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span> <span class="token keyword">implements</span> <span class="token class-name">ClassMetadata</span>    <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SimpleAnnotationMetadataReadingVisitor</span> <span class="token keyword">extends</span> <span class="token class-name">ClassVisitor</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们需要寻找哪个类继承了reader，将visitor给accept了。</p><p>我们先看看MetadataReader接口此接口是一个访问ClassMetadata等的简单门面，实现是委托给org.springframework.asm.ClassReader、ClassVisitor来处理的，它不用把Class加载进JVM就可以拿到元数据，因为它读取的是资源：Resource，这是它最大的优势所在。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MetadataReader</span> <span class="token punctuation">&#123;</span><span class="token comment">// 返回此Class文件的来源（资源）</span><span class="token class-name">Resource</span> <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回此Class的元数据信息</span><span class="token class-name">ClassMetadata</span> <span class="token function">getClassMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回此类的注解元信息（包括方法的）</span><span class="token class-name">AnnotationMetadata</span> <span class="token function">getAnnotationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>他的实现类是<code>SimpleMetadataReader</code>。它是基于<code>ASM</code>的<code>org.springframework.asm.ClassReader</code>的简单实现。请注意：此类是非public的，而是default包访问权限。可以看到<code>SimpleMetadataReader</code>在构造函数中accept了<code>SimpleAnnotationMetadataReadingVisitor</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SimpleMetadataReader</span> <span class="token keyword">implements</span> <span class="token class-name">MetadataReader</span> <span class="token punctuation">&#123;</span><span class="token class-name">SimpleMetadataReader</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> resource<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token class-name">SimpleAnnotationMetadataReadingVisitor</span> visitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAnnotationMetadataReadingVisitor</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在这accept</span><span class="token function">getClassReader</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">,</span> PARSING_OPTIONS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>resource <span class="token operator">=</span> resource<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>annotationMetadata <span class="token operator">=</span> visitor<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-MetadataReaderFactory"><a href="#6-MetadataReaderFactory" class="headerlink" title="6.MetadataReaderFactory"></a>6.MetadataReaderFactory</h3><p>MetadataReader的实现都并未public暴露出来，所以我们若想得到它的实例，就只能通过此工厂。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MetadataReaderFactory</span> <span class="token punctuation">&#123;</span><span class="token comment">//className： the class name (to be resolved to a ".class" file)</span><span class="token class-name">MetadataReader</span> <span class="token function">getMetadataReader</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token class-name">MetadataReader</span> <span class="token function">getMetadataReader</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> resource<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继承树如下：</p><img src="/2021/06/11/spring-zhu-jie-yuan-zhu-jie-yuan-shu-ju/3.png" class title="MetadataReaderFactory"><h4 id="6-1SimpleMetadataReaderFactory"><a href="#6-1SimpleMetadataReaderFactory" class="headerlink" title="6.1SimpleMetadataReaderFactory"></a>6.1SimpleMetadataReaderFactory</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleMetadataReaderFactory</span> <span class="token keyword">implements</span> <span class="token class-name">MetadataReaderFactory</span> <span class="token punctuation">&#123;</span><span class="token comment">// ResourceLoader这个资源加载类应该不陌生了吧</span><span class="token comment">// 默认使用的是DefaultResourceLoader，当然你可以通过构造器指定</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ResourceLoader</span> resourceLoader<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SimpleMetadataReaderFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultResourceLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">ResourceLoader</span> <span class="token function">getResourceLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 根据类名找到一个Resource</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">MetadataReader</span> <span class="token function">getMetadataReader</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 把..形式换成//.class形式。使用前缀是：classpath:</span><span class="token class-name">String</span> resourcePath <span class="token operator">=</span> <span class="token class-name">ResourceLoader</span><span class="token punctuation">.</span>CLASSPATH_URL_PREFIX <span class="token operator">+</span><span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">convertClassNameToResourcePath</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">ClassUtils</span><span class="token punctuation">.</span>CLASS_FILE_SUFFIX<span class="token punctuation">;</span><span class="token class-name">Resource</span> resource <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>resourcePath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">getMetadataReader</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用重载方法</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 此处是兼容内部类形式，代码略</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 默认使用的是SimpleMetadataReader</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">MetadataReader</span> <span class="token function">getMetadataReader</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> resource<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleMetadataReader</span><span class="token punctuation">(</span>resource<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此工厂生产的是SimpleMetadataReader。</p><h4 id="6-2CachingMetadataReaderFactory"><a href="#6-2CachingMetadataReaderFactory" class="headerlink" title="6.2CachingMetadataReaderFactory"></a>6.2CachingMetadataReaderFactory</h4><p>它继承自<code>SimpleMetadataReaderFactory</code>，没有其它特殊的，就是提供了缓存能力<code>private Map&lt;Resource, MetadataReader&gt; metadataReaderCache</code>，提高访问效率。<br>因为有了它，所以<code>SimpleMetadataReaderFactory</code>就不需要被直接使用了，用它代替。Spring内自然也使用的便是效率更高的它</p><h3 id="7-Spring注解编程中AnnotationMetadata的使用"><a href="#7-Spring注解编程中AnnotationMetadata的使用" class="headerlink" title="7.Spring注解编程中AnnotationMetadata的使用"></a>7.Spring注解编程中AnnotationMetadata的使用</h3><p>Spring从3.0开始就大量的使用到了注解编程模式，所以可想而知它对元数据（特别是注解元数据）的使用是非常多的，此处我只给出非常简单的总结。</p><p>对于MetadataReaderFactory的应用主要体现在几个地方：</p><ol><li><code>ConfigurationClassPostProcessor</code>：该属性值最终会传给<code>ConfigurationClassParser</code>，用于<code>@EnableXXX / @Import</code>等注解的解析上<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 私有成员变量，默认使用的CachingMetadataReaderFactory</span><span class="token keyword">private</span> <span class="token class-name">MetadataReaderFactory</span> metadataReaderFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingMetadataReaderFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><code>ClassPathScanningCandidateComponentProvider</code>：它用于<code>@ComponentScan</code>的时候解析，拿到元数据判断是否是<code>@Component</code>的派生注解    </li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">MetadataReaderFactory</span> <span class="token function">getMetadataReaderFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>metadataReaderFactory <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>metadataReaderFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingMetadataReaderFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>metadataReaderFactory<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><code>Mybatis</code>的<code>SqlSessionFactoryBean</code>：它在使用上非常简单，只是为了从Resouece里拿到ClassName而已。<code>classMetadata.getClassName()</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">MetadataReaderFactory</span> METADATA_READER_FACTORY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingMetadataReaderFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">scanClasses</span><span class="token punctuation">(</span><span class="token class-name">String</span> packagePatterns<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> assignableType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token class-name">ClassMetadata</span> classMetadata <span class="token operator">=</span> METADATA_READER_FACTORY<span class="token punctuation">.</span><span class="token function">getMetadataReader</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> clazz <span class="token operator">=</span> <span class="token class-name">Resources</span><span class="token punctuation">.</span><span class="token function">classForName</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><code>SourceClass</code>：它是对source对象一个轻量级的包装，持有AnnotationMetadata 元数据，如下一般实际为一个<code>StandardAnnotationMetadata</code>，比如<code>@EnableTransactionManagement</code>用的就是它</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SourceClass</span> <span class="token keyword">implements</span> <span class="token class-name">Ordered</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> source<span class="token punctuation">;</span>  <span class="token comment">// Class or MetadataReader</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SourceClass</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>source <span class="token operator">=</span> source<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token keyword">instanceof</span> <span class="token class-name">Class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>metadata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardAnnotationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> source<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>metadata <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MetadataReader</span><span class="token punctuation">)</span> source<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAnnotationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<code>Spring</code>的<code>@EnableXXX</code>模块注解很多都使用到了<code>ImportSelector</code>这个接口，此接口的回调方法参数第一个便是<code>AnnotationMetadata</code>代表着<code>@Import</code>所在类的注解的一些元数据们。通常我们会这样使用它：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 1、转换成AnnotationAttributes（LinkedHashMap），模糊掉注解类型（常用）</span><span class="token class-name">AnnotationAttributes</span> attributes <span class="token operator">=</span> <span class="token class-name">AnnotationConfigUtils</span><span class="token punctuation">.</span><span class="token function">attributesFor</span><span class="token punctuation">(</span>importingClassMetadata<span class="token punctuation">,</span> annType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2、拿到指定类型注解的元数据信息（也较为常用）</span><span class="token class-name">AnnotationAttributes</span> attributes <span class="token operator">=</span> <span class="token class-name">AnnotationAttributes</span><span class="token punctuation">.</span><span class="token function">fromMap</span><span class="token punctuation">(</span>metadata<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 3、直接使用MetaData</span><span class="token class-name">MultiValueMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> attributes <span class="token operator">=</span> metadata<span class="token punctuation">.</span><span class="token function">getAllAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">EnableConfigurationProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-使用示例"><a href="#8-使用示例" class="headerlink" title="8.使用示例"></a>8.使用示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 准备一个Class类 作为Demo演示</span><span class="token annotation punctuation">@Repository</span><span class="token punctuation">(</span><span class="token string">"repositoryName"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span><span class="token string">"serviceName"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableAsync</span><span class="token keyword">class</span> <span class="token class-name">MetaDemo</span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"demo"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">StandardAnnotationMetadata</span> metadata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardAnnotationMetadata</span><span class="token punctuation">(</span><span class="token class-name">MetaDemo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 演示ClassMetadata的效果</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==============ClassMetadata=============="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ClassMetadata</span> classMetadata <span class="token operator">=</span> metadata<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">getEnclosingClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">arrayToCommaDelimitedString</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">getMemberClassNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">arrayToCommaDelimitedString</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">getInterfaceNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">hasSuperClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">getSuperClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">isAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">isFinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">.</span><span class="token function">isIndependent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 演示AnnotatedTypeMetadata的效果</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==============AnnotatedTypeMetadata=============="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">AnnotatedTypeMetadata</span> annotatedTypeMetadata <span class="token operator">=</span> metadata<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotatedTypeMetadata<span class="token punctuation">.</span><span class="token function">isAnnotated</span><span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotatedTypeMetadata<span class="token punctuation">.</span><span class="token function">isAnnotated</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotatedTypeMetadata<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotatedTypeMetadata<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotatedTypeMetadata<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">EnableAsync</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotatedTypeMetadata<span class="token punctuation">.</span><span class="token function">getAllAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotatedTypeMetadata<span class="token punctuation">.</span><span class="token function">getAllAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotatedTypeMetadata<span class="token punctuation">.</span><span class="token function">getAllAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">EnableAsync</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 演示AnnotationMetadata子接口的效果（重要）</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==============AnnotationMetadata=============="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">AnnotationMetadata</span> annotationMetadata <span class="token operator">=</span> metadata<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">.</span><span class="token function">getAnnotationTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">.</span><span class="token function">getMetaAnnotationTypes</span><span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">.</span><span class="token function">getMetaAnnotationTypes</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">.</span><span class="token function">hasAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">.</span><span class="token function">hasAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">.</span><span class="token function">hasMetaAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Service</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">.</span><span class="token function">hasMetaAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">.</span><span class="token function">hasAnnotatedMethods</span><span class="token punctuation">(</span><span class="token class-name">Autowired</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     annotationMetadata<span class="token punctuation">.</span><span class="token function">getAnnotatedMethods</span><span class="token punctuation">(</span><span class="token class-name">Autowired</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>methodMetadata <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>methodMetadata<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>methodMetadata<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>methodMetadata<span class="token punctuation">.</span><span class="token function">getReturnTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>像这些元数据，在框架设计时候很多时候我们都希望从<code>File(Resource)</code>里得到，而不是从<code>Class</code>文件里获取，所以就是<code>MetadataReader</code>和<code>MetadataReaderFactory</code>。下面我也给出使用案例：</p><blockquote><p>因为<code>MetadataReader</code>的实现类都是包级别的访问权限，所以它的实例只能来自工厂</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CachingMetadataReaderFactory</span> readerFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingMetadataReaderFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 下面两种初始化方式都可，效果一样</span>    <span class="token comment">//MetadataReader metadataReader = readerFactory.getMetadataReader(MetaDemo.class.getName());</span>    <span class="token class-name">MetadataReader</span> metadataReader <span class="token operator">=</span> readerFactory<span class="token punctuation">.</span><span class="token function">getMetadataReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">"com/itxxj/maintest/MetaDemo.class"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ClassMetadata</span> classMetadata <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getClassMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">AnnotationMetadata</span> annotationMetadata <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getAnnotationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Resource</span> resource <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h3><p>元数据，是框架设计中必须的一个概念，所有的流行框架里都能看到它的影子，包括且不限于Spring、SpringBoot、SpringCloud、MyBatis、Hibernate等。它的作用肯定是大大的，它能模糊掉具体的类型，能让数据输出变得统一，能解决Java抽象解决不了的问题，比如运用得最广的便是注解，因为它不能继承无法抽象，所以用元数据方式就可以完美行成统一的向上抽取让它变得与类型无关，也就是常说的模糊效果，这便是框架的核心设计思想。</p><p>不管是ClassMetadata还是AnnotatedTypeMetadata都会有基于反射和基于ASM的两种解决方案，他们能使用于不同的场景：</p><ul><li>标准反射：它依赖于Class，优点是实现简单，缺点是使用时必须把Class加载进来。</li><li>ASM：无需提前加载Class入JVM，所有特别特别适用于形如Spring应用扫描的场景（扫描所有资源，但并不是加载所有进JVM/容器~）</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> 注解 </category>
          
          <category> 元注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 注解 </tag>
            
            <tag> 元注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java嵌套类（Nested Classes）</title>
      <link href="2021/06/10/java-qian-tao-lei/"/>
      <url>2021/06/10/java-qian-tao-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="java嵌套类（Nested-Classes）"><a href="#java嵌套类（Nested-Classes）" class="headerlink" title="java嵌套类（Nested Classes）"></a>java嵌套类（Nested Classes）</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>Nested Classes定义：在java语言规范里面，嵌套类(Nested Classes)定义是：</p><p><em><strong>A nested class is any class whose declaration occurs  within the body of another class or interface. A top level class is a  class that is not a nested class.</strong></em></p><p>说的简单一点，就是定义在类里面的类。一般把定义内部类的外围类称为包装类（enclosing class)或者外部类</p><h3 id="2-嵌套类分类"><a href="#2-嵌套类分类" class="headerlink" title="2.嵌套类分类"></a>2.嵌套类分类</h3><p>根据nested class定义的地方，可以分为member nested class,local nested class , anonymous nested class</p><blockquote><p>member nested class（成员嵌套类） ：成员嵌套类 作为 enclosing class 的成员定义的，成员嵌套类有enclosing class属性</p><p>local nested class （局部嵌套类）: 局部嵌套类定义在 enclosing class 的方法里面，局部嵌套类有enclosing class 属性和enclosing method 属性</p><p>anonymous nested class（匿名嵌套类）：匿名嵌套类没有显示的定义一个类，直接通过new 的方法创建类的实例。一般回调模式情况下使用的比较多</p></blockquote><p>member nested class 可以使用public,private,protected访问控制符，也可以用static,final关键字</p><p>local nested class 可以使用final关键字</p><p>anonymous nested class 不使用任何关键字和访问控制符</p><p>示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnclosingClass</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NestedMemberClass</span> <span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">nestedLocalClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NestedLocalClass</span> <span class="token punctuation">&#123;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">nestedAnonymousClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在大多数情况下，一般把nested classes 分为两种：</p><blockquote><p>Static Nested Classes（静态嵌套类）: 就是用static修饰的成员嵌套类</p><p>InnerClass：静态嵌套类之外所有的嵌套类的总称,也就是没有用static定义的nested classes，Inner  Classes 不能定义为static，不能有static方法和static初始化语句块。在JLS（java语言规范）里面是这么定义的：</p><p><em><strong>An inner class is a nested class that is not explicitly  or implicitly declared static. Inner classes may not declare static  initializers (§8.7) or member inter- faces</strong></em> </p></blockquote><p>其中Inner Class又可以分为三种：</p><p>1 inner member classes ：没有用static 修饰的成员内部类</p><p>2 local inner classes ： 定义在方法里面的内部类，方法可以是static的也可以是非static的，也可以是构造器方法。</p><p>3 anonymous inner classes ：定义在方法里面匿名类，方法可以是static的也可以是非static的</p><p><strong>Static Nested Classes 以及 inner classes 有一些限制规则，下面介绍一下这些规则。</strong></p><h3 id="3-Static-Nested-Classes访问规则"><a href="#3-Static-Nested-Classes访问规则" class="headerlink" title="3.Static Nested Classes访问规则"></a>3.Static Nested Classes访问规则</h3><p>用Static修饰的Nested Classes，只能访问外部类的非static变量。对于public 的 static Nested  Classes 可以用 new 外部类.内部类()的方式直接创建。而默认的static Nested Classes 可以在同一包名下，用  new  外部类.内部类()的方式创建。其实和外部类的方式差不多。静态成员类可以使用访问控制符，可以使用static修饰，可以是abstract抽象类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticNestedClass</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 私有局部</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 静态</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 不变值</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// static final</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 静态嵌套类，这里不是innerclass,可以直接new出来</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">PublicNestedClass</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// System.out.println(i); 非innerClass不能访问enclosing类的非static属性</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// System.out.println(k); 非innerClass不能访问enclosing类的非static属性</span>        <span class="token punctuation">&#125;</span>         <span class="token comment">// 可以定义static方法</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 静态嵌套类，这里不是innerclass,由于是私有的，不可以直接new出来</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">PrivateNestedClass</span> <span class="token punctuation">&#123;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的例子演示了static Nested class的创建：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                 <span class="token comment">//任何地方都可以创建</span>        <span class="token class-name">StaticNestedClass<span class="token punctuation">.</span>PublicNestedClass</span> publicNestedClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticNestedClass<span class="token punctuation">.</span>PublicNestedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//编译错误，无法访问内部类</span>        <span class="token comment">//StaticNestedClass.PrivateNestedClass privateNestedClass = new StaticNestedClass.PrivateNestedClass();</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-Inner-Class访问规则"><a href="#4-Inner-Class访问规则" class="headerlink" title="4.Inner Class访问规则"></a>4.Inner Class访问规则</h3><h4 id="4-1inner-member-classes（内部成员类）"><a href="#4-1inner-member-classes（内部成员类）" class="headerlink" title="4.1inner member classes（内部成员类）"></a>4.1inner member classes（内部成员类）</h4><p>内部成员类可以访问外部类的所有实例属性，静态属性。因为内部成员类持有一个外部对象的引用，内部类的实例可以对外部类的实例属性进行修改。如果是public的  inner  member classes，可以通过 外部类实例.new  内部类()的方式进行创建，当调用内部类的构造器的时候，会把当前创建的内部类对象实例中持有的外部对象引用赋值为当前创建内部类的外部类实例。内部成员类可以是使用访问控制符，可以定义为final，也可以是抽象类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberInnerClass</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 私有局部</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 静态</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 不变值</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// static final</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PublicMemberInnerClass</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// enclosing Class的属性都可以访问</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">public</span> <span class="token class-name">MemberInnerClass</span> <span class="token function">getOutterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token class-name">MemberInnerClass</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 这里会报错，不允许定义static方法</span>        <span class="token comment">// private static final void test();</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 私有的innerclass 外部不能访问</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">PrivateMemberInnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 公开局部类，外部可以访问和创建，但是只能通过OutterClass实例创建</span>    <span class="token keyword">class</span> <span class="token class-name">DefaultMemberInnerClass</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token class-name">MemberInnerClass</span> <span class="token function">getOutterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token class-name">MemberInnerClass</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面例子演示了内部成员类的创建：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 任何地方都可以创建</span>        <span class="token class-name">MemberInnerClass</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MemberInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 可以创建，pmic里面保存对t的引用</span>        <span class="token class-name">MemberInnerClass<span class="token punctuation">.</span>PublicMemberInnerClass</span> pmic <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">PublicMemberInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 可以在同一package下创建，dmic保存对t的引用</span>        <span class="token class-name">MemberInnerClass<span class="token punctuation">.</span>DefaultMemberInnerClass</span> dmic <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">DefaultMemberInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 编译错误，无法访问内部内</span>        <span class="token comment">// MemberInnerClass.PrivateMemberInnerClass pmic = t.new</span>        <span class="token comment">// PrivateMemberInnerClass();</span>         <span class="token comment">// 下面验证一下outterClass是同一个对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pmic<span class="token punctuation">.</span><span class="token function">getOutterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dmic<span class="token punctuation">.</span><span class="token function">getOutterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>控制台输出：<span class="token boolean">true</span><span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2local-inner-classes（局部类）"><a href="#4-2local-inner-classes（局部类）" class="headerlink" title="4.2local inner classes（局部类）"></a>4.2local inner classes（局部类）</h4><p>局部类定义在类方法里面。这个方法既可以是静态方法，也可以是实例方法，也可以是构造器方法或者静态初始化语句块。</p><p>局部类可以定义在一个static上下文里面 和 非static上下文里面。局部类不能有访问控制符(private,public,protected修饰），可以是抽象的,也可以定义为final</p><p>定义在static上下文（static 字段初始化，static初始化块，static方法）里面的local inner classes  可以访问类的静态属性，如果定义在静态方法里面的局部类，还可以方法里面定义的final变量。在static上下文定义的局部类，没有指向父类实例变量的引用，因为static方法不属于类的实例，属于类本身。而且局部类不能在外部进行创建，只能在方法调用的时候进行创建。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LocalInnerClass</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 私有局部</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 静态</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 不变值</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// static final</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// local inner class不能够有访问控制符 比如public private</span>        <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LocalStaticInnerClass</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// local inner class不能定义静态属性</span>            <span class="token comment">// private static int c;</span>            <span class="token keyword">private</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">public</span> <span class="token class-name">LocalStaticInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 可以访问方法里面定义的final 变量</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 不能访问b 因为b不是final</span>                <span class="token comment">// System.out.println(b);       </span>                <span class="token comment">// 定义在static上下文里面的local inner class 不能访问外部类的非static字段</span>                <span class="token comment">// System.out.println(i);</span>                <span class="token comment">// System.out.println(k);</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// local inner class不能定义静态方法</span>            <span class="token comment">// public static void test()&#123;&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">LocalNonStaticInnerClass</span><span class="token punctuation">&#123;</span>               <span class="token keyword">public</span> <span class="token class-name">LocalNonStaticInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//定义在非static上下文的local inner class 可以访问外部类的所有属性</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3anonymous-inner-classes-匿名类）"><a href="#4-3anonymous-inner-classes-匿名类）" class="headerlink" title="4.3anonymous inner classes (匿名类）"></a>4.3anonymous inner classes (匿名类）</h4><p>匿名类也是定义在方法里面，匿名类和局部类访问规则一样，只不过内部类显式的定义了一个类，然后通过new的方式创建这个局部类实例，而匿名类直接new一个类实例，没有定义这个类。匿名类最常见的方式就是回调模式的使用，通过默认实现一个接口创建一个匿名类然后，然后new这个匿名类的实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnonymousInnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//访问规则和局部类一样</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                 <span class="token comment">//匿名类实现</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//非匿名类实现</span>        <span class="token keyword">class</span> <span class="token class-name">NoneAnonymousClass</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>           <span class="token class-name">NoneAnonymousClass</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NoneAnonymousClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-嵌套类的层次"><a href="#5-嵌套类的层次" class="headerlink" title="5.嵌套类的层次"></a>5.嵌套类的层次</h3><p>嵌套类是可以有层次的，也就是说嵌套类里面还是定义类，成为嵌套类中的嵌套类。虚拟机如何保证嵌套类正确的嵌套层层次？</p><p>对于merber class，内部嵌套类的可以表示为 <code>A$B</code> 其中A为外部类，B为内部成员类  ，如果B里面又有成员为C的嵌套类，那么C就可以表示为<code>A$B$C</code>,如果A定义了两个同名member  class，那么编译器就会报错。如果B里面又包含了为名B的nested class，则编译器会报错.</p><p>对于local inner Class，局部类可以表示为<code>A$1B</code>的方式，其中A为外部类，B为第一个局部类  如果在不同的方法里面定义了同名的局部类B，编译器是可以编译通过的，那么定义的第二个局部类B可以表示为<code>A$2B</code>，如果在同一个方法里面同定义两个相同的局部类B，那么编译错是要报错的。如果B里面又定义了同名的成员类，则可以表示为<code>A$1B$B</code>。</p><p>对于anonymous inner classes，匿名类可以表示为<code>A$1</code>的方式，代表程序里面有一个匿名类。如果有N个，可以表示为<code>A$N</code>的方式(N为自然数).</p><p>看看下面的例子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NestedClassLevel</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 编译器会报错,A里面不能在定义名为A的nested classes</span>        <span class="token comment">// class A&#123;&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">//可以在继续定义B</span>    <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//可以无限定义匿名类</span>            <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//可以无限定义匿名类</span>                    <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                 <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 只能定义一个B</span>    <span class="token comment">// class B&#123;&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 可以定义A</span>        <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//可以有同名的局部类B和成员类B</span>                <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                             <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">//局部类A里面不能在定义A</span>                <span class="token comment">//class A&#123;&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//可以有同名的局部类B和成员类B</span>        <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于定义在非static上下文里面的nested类层次，比如A$B$1C  ,则最内层的嵌套类C有一个指向B实例的引用，B有一个指向A实例的引用，最终最内层的嵌套类可以访问A中的属性可以方法，一般把B成为A的直接嵌套类。但是A不可以访问B或者C中属性或者方法。</p><h3 id="6-nested-interface"><a href="#6-nested-interface" class="headerlink" title="6.nested interface"></a>6.nested interface</h3><p>由于interface默认是定义为一个 public static的特殊类，所以interface可以直接作为 static member class。可以通过A.B的方式进行访问。</p>]]></content>
      
      
      <categories>
          
          <category> Nested Classes </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Nested Classes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内省</title>
      <link href="2021/06/10/java-nei-sheng/"/>
      <url>2021/06/10/java-nei-sheng/</url>
      
        <content type="html"><![CDATA[<h2 id="java内省"><a href="#java内省" class="headerlink" title="java内省"></a>java内省</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>内省(Introspector) 是Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。</p><p>JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。</p><p>访问属性的getter()和setter()有以下两种方法：</p><p>1)内省(Introspector)。这些 API  存放于包 java.beans 中。 </p><p>2)直接通过属性的描述器java.beans.PropertyDescriptor类，来访问属性的getter/setter 方法;</p><p>例如类UserInfo就是JavaBean，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">UserInfo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> userId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> emailAddress<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userId<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserId</span><span class="token punctuation">(</span><span class="token keyword">long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userId <span class="token operator">=</span> userId<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userName<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getEmailAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> emailAddress<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setEmailAddress</span><span class="token punctuation">(</span><span class="token class-name">String</span> emailAddress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>emailAddress <span class="token operator">=</span> emailAddress<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-JDK内省类库"><a href="#2-JDK内省类库" class="headerlink" title="2.JDK内省类库"></a>2.JDK内省类库</h3><p><strong>PropertyDescriptor类</strong></p><p>PropertyDescriptor类表示JavaBean类通过存储器导出一个属性：</p><p>实例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">BeanInfoUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token class-name">UserInfo</span> userInfo<span class="token punctuation">,</span> <span class="token class-name">String</span> userName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PropertyDescriptor</span> propDesc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PropertyDescriptor</span><span class="token punctuation">(</span>userName<span class="token punctuation">,</span> <span class="token class-name">UserInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//getWriteMethod():获得用于写入属性值的方法</span>        <span class="token class-name">Method</span> methodSetUserName <span class="token operator">=</span> propDesc<span class="token punctuation">.</span><span class="token function">getWriteMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        methodSetUserName<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"肖相杰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"set userName:"</span> <span class="token operator">+</span> userInfo<span class="token punctuation">.</span><span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token class-name">UserInfo</span> userInfo<span class="token punctuation">,</span> <span class="token class-name">String</span> userName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PropertyDescriptor</span> propDesc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PropertyDescriptor</span><span class="token punctuation">(</span>userName<span class="token punctuation">,</span> <span class="token class-name">UserInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// getPropertyType():获得属性的Class对象; 输出class java.lang.String</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> propertyType <span class="token operator">=</span> propDesc<span class="token punctuation">.</span><span class="token function">getPropertyType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>propertyType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//getReadMethod():获得用于读取属性值的方法</span>        <span class="token class-name">Method</span> methodGetUserName <span class="token operator">=</span> propDesc<span class="token punctuation">.</span><span class="token function">getReadMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> objUserName <span class="token operator">=</span> methodGetUserName<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"get userName:"</span> <span class="token operator">+</span> objUserName<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Introspector类:</strong></p><p>　　将JavaBean中的属性封装起来进行操作。在程序把一个类当做JavaBean来看，就是调用Introspector.getBeanInfo()方法，得到的BeanInfo对象封装了把这个类当做JavaBean看的结果信息，即属性的信息。</p><p>BeanInfo结构如下：</p><img src="/2021/06/10/java-nei-sheng/1.png" class title="BeanInfo"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//获取beaninfo的properties和methods</span><span class="token class-name">PropertyDescriptor</span><span class="token punctuation">[</span><span class="token punctuation">]</span> propDescriptors<span class="token operator">=</span>beanInfo<span class="token punctuation">.</span><span class="token function">getPropertyDescriptors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">MethodDescriptor</span><span class="token punctuation">[</span><span class="token punctuation">]</span> methodDescriptors <span class="token operator">=</span> beanInfo<span class="token punctuation">.</span><span class="token function">getMethodDescriptors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中properties和methods具体结构如下</p><img src="/2021/06/10/java-nei-sheng/2.png" class title="properties"><img src="/2021/06/10/java-nei-sheng/3.png" class title="methods"><p>使用Introspector的具体代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">BeanInfoUtil</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//我这里通过hashmap存储PropertyDescriptor，其键就是property的name</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setPropertyByIntroSpector</span><span class="token punctuation">(</span><span class="token class-name">UserInfo</span> userInfo<span class="token punctuation">,</span> <span class="token class-name">String</span> propName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">BeanInfo</span> beanInfo <span class="token operator">=</span> <span class="token class-name">Introspector</span><span class="token punctuation">.</span><span class="token function">getBeanInfo</span><span class="token punctuation">(</span><span class="token class-name">UserInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PropertyDescriptor</span><span class="token punctuation">[</span><span class="token punctuation">]</span> propDescriptors <span class="token operator">=</span> beanInfo<span class="token punctuation">.</span><span class="token function">getPropertyDescriptors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">PropertyDescriptor</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>propDescriptors <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> propDescriptors<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">PropertyDescriptor</span> propDesc <span class="token operator">:</span> propDescriptors<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>propDesc<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> propDesc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">PropertyDescriptor</span> propDesc <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Method</span> methodSetUserName <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>propName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"userName"</span><span class="token operator">:</span>                propDesc <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                methodSetUserName <span class="token operator">=</span> propDesc<span class="token punctuation">.</span><span class="token function">getWriteMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                methodSetUserName<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"王鲁军"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"set userName:"</span> <span class="token operator">+</span> userInfo<span class="token punctuation">.</span><span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"age"</span><span class="token operator">:</span>                propDesc <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                methodSetUserName <span class="token operator">=</span> propDesc<span class="token punctuation">.</span><span class="token function">getWriteMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                methodSetUserName<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"24"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"set age:"</span> <span class="token operator">+</span> userInfo<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"userId"</span><span class="token operator">:</span>                propDesc <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                methodSetUserName <span class="token operator">=</span> propDesc<span class="token punctuation">.</span><span class="token function">getWriteMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                methodSetUserName<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"set userId:"</span> <span class="token operator">+</span> userInfo<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"emailAddress"</span><span class="token operator">:</span>                propDesc <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"emailAddress"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                methodSetUserName <span class="token operator">=</span> propDesc<span class="token punctuation">.</span><span class="token function">getWriteMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                methodSetUserName<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"1467600745@qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"set emailAddress:"</span> <span class="token operator">+</span> userInfo<span class="token punctuation">.</span><span class="token function">getEmailAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"没有这个属性"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这两个类的比较可以看出，都是需要获得PropertyDescriptor，只是方式不一样：前者通过创建对象直接获得，后者需要遍历。</p><p>使用示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntroSpectorDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">UserInfo</span> userInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userInfo<span class="token punctuation">.</span><span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token string">"peter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">BeanInfoUtil</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">BeanInfoUtil</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">BeanInfoUtil</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">BeanInfoUtil</span><span class="token punctuation">.</span><span class="token function">setPropertyByIntroSpector</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">BeanInfoUtil</span><span class="token punctuation">.</span><span class="token function">getPropertyByIntroSpector</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">BeanInfoUtil</span><span class="token punctuation">.</span><span class="token function">setPropertyByIntroSpector</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"emailAddress"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>控制台输出get userName<span class="token operator">:</span>peterset userName<span class="token operator">:</span>肖相杰get userName<span class="token operator">:</span>肖相杰set userName<span class="token operator">:</span>王鲁军get userName<span class="token operator">:</span>王鲁军set emailAddress<span class="token operator">:</span><span class="token number">1467600745</span><span class="token annotation punctuation">@qq.com</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-BeanUtils工具包"><a href="#3-BeanUtils工具包" class="headerlink" title="3.BeanUtils工具包"></a>3.BeanUtils工具包</h3><p>由上述可看出，内省操作非常的繁琐，所以所以Apache开发了一套简单、易用的API来操作Bean的属性——BeanUtils工具包。<br>　　BeanUtils工具包：下载：<a href="http://commons.apache.org/beanutils/">http://commons.apache.org/beanutils/</a>　<br>        注意：应用的时候还需要一个logging包 <a href="http://commons.apache.org/logging/">http://commons.apache.org/logging/</a></p><p>​        或者导入maven依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--beanUtils工具包--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-beanutils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-beanutils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.9.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--使用beanUtils必须附带logging包--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntroSpectorDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//这里好像不能用在同一个java文件下的UserInfo类，因为BeanUtils是在类加载的时候生成beaninfo，具体原因还不知道</span>        <span class="token class-name">UserInfo</span> userInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span><span class="token string">"userName"</span><span class="token punctuation">,</span><span class="token string">"peter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"set userName:"</span><span class="token operator">+</span>userInfo<span class="token punctuation">.</span><span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"get userName:"</span><span class="token operator">+</span><span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"set age:"</span><span class="token operator">+</span>userInfo<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"get age:"</span><span class="token operator">+</span><span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"get userName type:"</span><span class="token operator">+</span><span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"get age type:"</span><span class="token operator">+</span><span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">PropertyUtils</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">PropertyUtils</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">PropertyUtils</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">PropertyUtils</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>控制台输出如下：set userName<span class="token operator">:</span>peterget userName<span class="token operator">:</span>peterset age<span class="token operator">:</span><span class="token number">18</span>get age<span class="token operator">:</span><span class="token number">18</span>get userName type<span class="token operator">:</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span>get age type<span class="token operator">:</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token number">8</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Integer</span><span class="token comment">//报错信息</span><span class="token class-name">Exception</span> in thread <span class="token string">"main"</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>IllegalArgumentException</span><span class="token operator">:</span> <span class="token class-name">Cannot</span> invoke <span class="token class-name"><span class="token namespace">introSpectorDemo<span class="token punctuation">.</span></span>User</span><span class="token punctuation">.</span>setAge on bean <span class="token keyword">class</span> <span class="token string">'class introSpectorDemo.User'</span> <span class="token operator">-</span> argument type mismatch <span class="token operator">-</span> had objects of type <span class="token string">"java.lang.String"</span> but expected signature <span class="token string">"int"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><p>　　1.获得属性的值，例如，BeanUtils.getProperty(userInfo,”userName”)，返回字符串<br>　　2.设置属性的值，例如，BeanUtils.setProperty(userInfo,”age”,8)，参数是字符串或基本类型自动包装。设置属性的值是字符串，获得的值也是字符串，不是基本类型。　　　<br>        3.BeanUtils的特点：</p><blockquote><p>1). 对基本数据类型的属性的操作：在WEB开发、使用中，录入和显示时，值会被转换成字符串，但底层运算用的是基本类型，这些类型转到动作由BeanUtils自动完成。<br>2). 对引用数据类型的属性的操作：首先在类中必须有对象，不能是null，例如，<code>private Date birthday=new  Date()</code>；操作的是对象的属性而不是整个对象，例如，<code>BeanUtils.setProperty(userInfo,&quot;birthday.time&quot;,111111)</code>。<br>3).PropertyUtils类和BeanUtils这两个工具设置属性的时候一个主要区别是PropertyUtils.getPropety方法获得的属性值的类型为该属性本来的类型，而BeanUtils.getProperty则是将该属性的值转换成字符串后才返回。由于age属性的数据类型是int，所以方法PropertyUtils.setProperty(userInfo, “age”, “8”)会爆出数据类型不匹配，无法将值赋给属性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaBean </category>
          
          <category> 内省 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaBean </tag>
            
            <tag> 内省 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PO,BO,VO,DTO,POJO,JavaBean等名词的释义</title>
      <link href="2021/06/09/po-bo-vo-dto-pojo-javabean-deng-ming-ci-de-shi-yi/"/>
      <url>2021/06/09/po-bo-vo-dto-pojo-javabean-deng-ming-ci-de-shi-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>在java开发中总是有一些专有名词的概念非常相近，可能会产生理解混淆或理解不到位，特此在这对这些概念进行记录，加深自己的理解。</p><h2 id="2-什么是JavaBean"><a href="#2-什么是JavaBean" class="headerlink" title="2.什么是JavaBean"></a>2.什么是JavaBean</h2><p>JavaBean实际上是指一种特殊的Java类，它通常用来实现一些比较常用的简单功能，并可以很容易的被重用或者是插入其他应用程序中去。所有遵循“一定编程原则”的Java类都可以被称作JavaBean。</p><p>JavaBean是一个遵循特定写法的Java类，是一种Java语言编写的可重用组件，它的方法命名，构造及行为必须符合特定的约定：</p><p>1、这个类必须具有一个公共的(public)无参构造函数；<br>2、所有属性私有化（private）；<br>3、私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。<br>4、这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）</p><p>JavaBean在Java EE开发中，通常用于封装数据，对于遵循以上写法的JavaBean组件，其它程序可以通过反射技术实例化JavaBean对象（<code>内省机制</code>），并且通过反射那些遵循命名规范的方法，从而获知JavaBean的属性，进而调用其属性保存数据。</p><p>因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO。（可以这么理解，POJO按JavaBean的规则来，就可以变成JavaBean）。</p><p>简而言之，当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个JavaBean。</p><h2 id="3-什么是POJO"><a href="#3-什么是POJO" class="headerlink" title="3.什么是POJO"></a>3.什么是POJO</h2><p>POJO（Plain Old Java Object）这种叫法是Martin Fowler、Rebecca Parsons和Josh MacKenzie在2000年的一次演讲的时候提出来的。一般被称为简单java对象。</p><p><strong>POJO是一个简单的、普通Java对象，它包含业务逻辑处理或持久化逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色，不继承或不实现任何其它Java框架的类或接口。</strong> <strong>可以包含类似与JavaBean属性和对属性访问的setter和getter方法的。</strong></p><p>POJO例子及反例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>spring</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DbHello</span> <span class="token punctuation">&#123;</span> <span class="token comment">//简单的Java类，称之为POJO，不继承，不实现接口</span>    　　<span class="token keyword">private</span> <span class="token class-name">DictionaryDAO</span> dao<span class="token punctuation">;</span>    　　<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDao</span><span class="token punctuation">(</span><span class="token class-name">DictionaryDAO</span> dao<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           　　<span class="token keyword">this</span><span class="token punctuation">.</span>dao <span class="token operator">=</span> dao<span class="token punctuation">;</span>    　　<span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>spring</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DbHello</span> <span class="token keyword">implements</span> <span class="token class-name">Hello</span> <span class="token punctuation">&#123;</span> <span class="token comment">//实现了接口，就不能称之为POJO，这已经不是简单的Java类了</span>    　　<span class="token keyword">private</span> <span class="token class-name">DictionaryDAO</span> dao<span class="token punctuation">;</span>    　　<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDao</span><span class="token punctuation">(</span><span class="token class-name">DictionaryDAO</span> dao<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           　　<span class="token keyword">this</span><span class="token punctuation">.</span>dao <span class="token operator">=</span> dao<span class="token punctuation">;</span>    　　<span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>辅助理解</strong>：POJO可以认为是一个中间对象。</p><p>一个中间对象，可以转化为PO、DTO、VO。</p><p>1 ．POJO持久化之后==〉PO（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于程序员来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。PO在向数据库中添加新数据时创建，在删除数据库中数据时删除，只能存活在一个数据库连接中，断开连接即被销毁；且PO对象需要实现序列化接口。）</p><p>2 ．POJO传输过程中==〉DTO</p><p>3 ．POJO用作表示层==〉VO</p><h2 id="4-什么是PO"><a href="#4-什么是PO" class="headerlink" title="4.什么是PO"></a>4.什么是PO</h2><p>PO ：persistent object持久对象。<br>O/R Mapping 是 Object Relational Mapping（对象关系映射）的缩写。通俗点讲，就是将对象与关系数据库绑定，用对象来表示关系数据。</p><p>PO是在O/R映射的时候出现的概念，如果没有O/R映射，没有这个概念存在了。常用的O/R映射框架有hibernate等。通常对应数据模型(数据库)，本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。</p><p>1、有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。<br>2、在hibernate持久化框架中与insert/delete操作密切相关。<br>3、PO中不应该包含任何对数据库的操作。<br>4、PO的属性是跟数据库表的字段一一对应的。<br>5、PO对象需要实现序列化接口。</p><p>就是说在一些Object/Relation Mapping工具中，能够做到维护数据库表记录的PO完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。全都是这样子的： </p><h2 id="5-什么是DTO"><a href="#5-什么是DTO" class="headerlink" title="5.什么是DTO"></a>5.什么是DTO</h2><p>DTO （TO） ：Data Transfer Object 数据传输对象。<br>主要用于远程调用等需要大量传输对象的地方。不应该包含业务逻辑。</p><p>可以将PO中的部分属性抽取出来，就形成了DTO。</p><p>比如我们一张表有100个字段，那么对应的PO就有100个属性。<br>但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO（View Object）。</p><h2 id="6-什么是VO"><a href="#6-什么是VO" class="headerlink" title="6.什么是VO"></a>6.什么是VO</h2><p>VO ：value object 值对象 / view object 表现层（视图）对象。</p><p>先说 value object 值对象：<br>通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象，可以和表对应，也可以不，这根据业务的需要。个人觉得同DTO(数据传输对象)，在web上传递。</p><p>①VO（value object）是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。<br>VO是什么？它是值对象，准确地讲，它是业务对象，是生活在业务层的，是业务逻辑需要了解，需要使用的，再简单地讲，它是概念模型转换得到的。 </p><p>首先说PO和VO吧，它们的关系应该是相互独立的，一个VO可以只是PO的部分，也可以是多个PO构成，同样也可以等同于一个PO（当然我是指他们的属性）。正因为这样，PO独立出来，数据持久层也就独立出来了，它不会受到任何业务的干涉。又正因为这样，业务逻辑层也独立开来，它不会受到数据持久层的影响，业务层关心的只是业务逻辑的处理，至于怎么存怎么读交给别人吧！不过，另外一点，如果我们没有使用数据持久层，或者说没有使用hibernate，那么PO和VO也可以是同一个东西，虽然这并不好。</p><p>② VO（view object）表现层对象，视图对象。<br>用一个VO对象对应整个界面的值。</p><p>1、主要对应页面显示（web页面）的数据对象。<br>2、可以和表对应，也可以不，这根据业务的需要。<br>注 ：在struts中，用ActionForm做VO，需要做一个转换，因为PO是面向对象的，而ActionForm是和view对应的，要将几个PO要显示的属性合成一个ActionForm，可以使用BeanUtils的copy方法。</p><h2 id="7-什么是BO"><a href="#7-什么是BO" class="headerlink" title="7.什么是BO"></a>7.什么是BO</h2><p>BO ：business object 业务层对象。对象的属性和当前业务逻辑所需的数据的名称一一对应。</p><p>主要作用是把业务逻辑所需的数据封装为一个对象。这个对象可以包括一个或多个其它的对象。<br>比如一个简历，有教育经历、工作经历、社会关系等等。<br>我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。<br>建立一个对应简历的BO对象处理简历，每个BO包含这些PO。<br>这样处理业务逻辑时，我们就可以针对BO去处理。</p><p>封装业务逻辑的java对象，通过调用DAO方法，结合PO，VO进行业务操作。可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从数据库中得到的PO，需要转化成BO才能在业务层使用）。</p><p>关于BO主要有三种概念<br>1 、只包含业务对象的属性；<br>2 、只包含业务方法；<br>3 、两者都包含。<br>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。</p><h2 id="8-什么是DAO"><a href="#8-什么是DAO" class="headerlink" title="8.什么是DAO"></a>8.什么是DAO</h2><p>DAO ：data access object 数据访问对象。<br>这个大家最熟悉，和上面几个O区别最大，基本没有互相转化的可能性和必要.<br>主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO。</p><p>DAO为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO，提供数据库的CRUD操作…<br>1、主要用来封装对DB（数据库）的访问（CRUD操作）。<br>2、通过接收业务层的数据，把POJO持久化为PO。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2021/06/09/po-bo-vo-dto-pojo-javabean-deng-ming-ci-de-shi-yi/1.png" class title="总结图"><p>其实大多时候我们使用的都是一个对象，只是在不同的时间段，它的身份不同。比如在创建这条数据的时候首先在controller层接收数据，这时候可以理解为VO；到了业务层，可能会做一些校验和逻辑处理，这时候就是BO；到了DAO层，要进行数据持久化那么此时就成为PO。</p>]]></content>
      
      
      <categories>
          
          <category> POJO </category>
          
          <category> JavaBean </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POJO </tag>
            
            <tag> JavaBean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis之哨兵模式</title>
      <link href="2021/06/02/redis-zhi-shao-bing-mo-shi/"/>
      <url>2021/06/02/redis-zhi-shao-bing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="redis之哨兵模式"><a href="#redis之哨兵模式" class="headerlink" title="redis之哨兵模式"></a>redis之哨兵模式</h2><p>redis的高并发和高可用分别是通过主从复制和哨兵进行主从切换来实现的</p><p>本文主要讲的是哨兵模式</p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>在主从复制中当主服务器宕机后，需要手动把一台从服务器切换为主服务器，使用命令 <code>slaveof no one</code>，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。</p><p>Redis Sentinel为Redis提供了高可用解决方案。实际上这意味着使用Sentinel可以部署一套Redis，在没有人为干预的情况下去应付各种各样的失败事件。</p><p>Redis Sentinel同时提供了一些其他的功能，例如：监控、通知、并为client提供配置。</p><p>下面是Sentinel的功能列表：</p><ul><li>  监控（Monitoring）：Sentinel不断的去检查你的主从实例是否按照预期在工作。</li><li>  通知（Notification）：Sentinel可以通过一个api来通知系统管理员或者另外的应用程序，被监控的Redis实例有一些问题。</li><li>  自动故障转移（Automatic failover）：如果一个主节点没有按照预期工作，Sentinel会开始故障转移过程，把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用Redis服务的应用程序在连接的时候也被通知新的地址。</li><li>  配置提供者（Configuration provider）：Sentinel给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到Sentinels来寻找当前主节点的地址。当故障转移发生的时候，Sentinels将报告新的地址。</li></ul><img src="/2021/06/02/redis-zhi-shao-bing-mo-shi/1.png" class title="哨兵模式架构图"><p>Redis Sentinel是一个分布式系统，Sentinel运行在有许多Sentinel进程互相合作的环境下，它本身就是这样被设计的。有许多Sentinel进程互相合作的优点如下：</p><img src="/2021/06/02/redis-zhi-shao-bing-mo-shi/2.png" class title="哨兵集群"><ol><li> 当多个Sentinel同意一个master不再可用的时候，就执行故障检测。这明显降低了错误概率。</li><li> 即使并非全部的Sentinel都在工作，Sentinel也可以正常工作，这种特性，让系统非常的健康。</li></ol><h3 id="2-哨兵模式开启流程及配置"><a href="#2-哨兵模式开启流程及配置" class="headerlink" title="2.哨兵模式开启流程及配置"></a>2.哨兵模式开启流程及配置</h3><p><strong>哨兵模式的前置知识</strong></p><ul><li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li><li>哨兵 + Redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 Redis 集群的高可用性。</li><li>对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li></ul><p>哨兵集群必须部署 2 个以上节点，如果哨兵集群仅仅部署了 2 个哨兵实例，quorum = 1。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+----+         +----+<span class="token operator">|</span> M1 <span class="token operator">|</span>---------<span class="token operator">|</span> R1 <span class="token operator">|</span><span class="token operator">|</span> S1 <span class="token operator">|</span>         <span class="token operator">|</span> S2 <span class="token operator">|</span>+----+         +----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置 <code>quorum=1</code> ，如果 master 宕机， s1 和 s2 中只要有 1 个哨兵认为 master 宕机了，就可以进行切换，同时 s1 和 s2 会选举出一个哨兵来执行故障转移。但是同时这个时候，需要 majority，也就是大多数哨兵都是运行的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2</span> 个哨兵，majority<span class="token operator">=</span><span class="token number">2</span><span class="token number">3</span> 个哨兵，majority<span class="token operator">=</span><span class="token number">2</span><span class="token number">4</span> 个哨兵，majority<span class="token operator">=</span><span class="token number">2</span><span class="token number">5</span> 个哨兵，majority<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果此时仅仅是 M1 进程宕机了，哨兵 s1 正常运行，那么故障转移是 OK 的。但是如果是整个 M1 和 S1 运行的机器宕机了，那么哨兵只有 1 个，此时就没有 majority 来允许执行故障转移，虽然另外一台机器上还有一个 R1，但是故障转移不会执行。</p><p>经典的 3 节点哨兵集群是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">       +----+       <span class="token operator">|</span> M1 <span class="token operator">|</span>       <span class="token operator">|</span> S1 <span class="token operator">|</span>       +----+          <span class="token operator">|</span>+----+    <span class="token operator">|</span>    +----+<span class="token operator">|</span> R2 <span class="token operator">|</span>----+----<span class="token operator">|</span> R3 <span class="token operator">|</span><span class="token operator">|</span> S2 <span class="token operator">|</span>         <span class="token operator">|</span> S3 <span class="token operator">|</span>+----+         +----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置 <code>quorum=2</code> ，如果 M1 所在机器宕机了，那么三个哨兵还剩下 2 个，S2 和 S3 可以一致认为 master 宕机了，然后选举出一个来执行故障转移，同时 3 个哨兵的 majority 是 2，所以还剩下的 2 个哨兵运行着，就可以允许执行故障转移。</p><h4 id="2-1配置sentinel-conf配置文件"><a href="#2-1配置sentinel-conf配置文件" class="headerlink" title="2.1配置sentinel.conf配置文件"></a>2.1配置<code>sentinel.conf</code>配置文件</h4><p>使用一个配置文件来运行Sentinel是必须的，这个文件被系统使用来存储当前状态，如果重启，这些状态会被重新载入。如果没有配置文件或者配置文件的路径不对，Sentinel将会拒绝启动。</p><p>默认情况下，Sentinels监听TCP端口26379，所以为了让Sentinels运行，你的机器的26379端口必须是打开的，用来接收其他Sentinel实例的连接，否则，Sentinels不能互相交流，也不知道该干什么，也不会执行故障转移。</p><blockquote><p>配置文件配置说明</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Example sentinel.conf<span class="token comment"># 哨兵sentinel实例运行的端口 默认26379</span>port <span class="token number">26379</span><span class="token comment"># 哨兵sentinel的工作目录</span><span class="token function">dir</span> /tmp<span class="token comment"># 哨兵sentinel监控的redis主节点的 ip port</span><span class="token comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span><span class="token comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span><span class="token comment"># sentinel monitor &lt;master-name> &lt;ip> &lt;redis-port> &lt;quorum></span>sentinel monitor mymaster <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token number">2</span><span class="token comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><span class="token comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><span class="token comment"># sentinel auth-pass &lt;master-name> &lt;password></span>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<span class="token comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><span class="token comment"># sentinel down-after-milliseconds &lt;master-name> &lt;milliseconds></span>sentinel down-after-milliseconds mymaster <span class="token number">30000</span><span class="token comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><span class="token comment"># sentinel parallel-syncs &lt;master-name> &lt;numslaves></span>sentinel parallel-syncs mymaster <span class="token number">1</span><span class="token comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><span class="token comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><span class="token comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><span class="token comment">#3.当想要取消一个正在进行的failover所需要的时间。</span><span class="token comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><span class="token comment"># 默认三分钟</span><span class="token comment"># sentinel failover-timeout &lt;master-name> &lt;milliseconds></span>sentinel failover-timeout mymaster <span class="token number">180000</span><span class="token comment"># SCRIPTS EXECUTION</span><span class="token comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><span class="token comment">#对于脚本的运行结果有以下规则：</span><span class="token comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><span class="token comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><span class="token comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><span class="token comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><span class="token comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><span class="token comment">#通知脚本</span><span class="token comment"># sentinel notification-script &lt;master-name> &lt;script-path></span>sentinel notification-script mymaster /var/redis/notify.sh<span class="token comment"># 客户端重新配置主节点参数脚本</span><span class="token comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><span class="token comment"># 以下参数将会在调用脚本时传给脚本:</span><span class="token comment"># &lt;master-name> &lt;role> &lt;state> &lt;from-ip> &lt;from-port> &lt;to-ip> &lt;to-port></span><span class="token comment"># 目前&lt;state>总是“failover”,</span><span class="token comment"># &lt;role>是“leader”或者“observer”中的一个。</span><span class="token comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><span class="token comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><span class="token comment"># sentinel client-reconfig-script &lt;master-name> &lt;script-path></span>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2启动sentinel"><a href="#2-2启动sentinel" class="headerlink" title="2.2启动sentinel"></a>2.2启动sentinel</h4><p>使用如下命令来启动sentinel</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-sentinel /path/to/sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-哨兵模式的sdown和-odown"><a href="#3-哨兵模式的sdown和-odown" class="headerlink" title="3.哨兵模式的sdown和 odown"></a>3.哨兵模式的sdown和 odown</h3><ul><li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li><li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li></ul><p>sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。</p><h3 id="4-哨兵模式的quorum-和-majority"><a href="#4-哨兵模式的quorum-和-majority" class="headerlink" title="4.哨兵模式的quorum 和 majority"></a>4.哨兵模式的quorum 和 majority</h3><p>每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，即majority的哨兵存活，才能正式执行切换。</p><p>如果 quorum &lt; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。</p><p>但是如果 quorum &gt;= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。</p><h3 id="5-哨兵集群的自动发现机制"><a href="#5-哨兵集群的自动发现机制" class="headerlink" title="5.哨兵集群的自动发现机制"></a>5.哨兵集群的自动发现机制</h3><p>哨兵互相之间的发现，是通过 Redis 的 <code>pub/sub</code> 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 <code>__sentinel__:hello</code> channel 里<strong>发送一个消息</strong>，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。</p><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 master+slaves 对应的 <code>__sentinel__:hello</code> channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。</p><p>每个哨兵还会跟其他哨兵交换对 <code>master</code> 的监控配置，互相进行监控配置的同步。</p><h3 id="6-哨兵集群的slave-gt-master-选举算法"><a href="#6-哨兵集群的slave-gt-master-选举算法" class="headerlink" title="6.哨兵集群的slave-&gt;master 选举算法"></a>6.哨兵集群的slave-&gt;master 选举算法</h3><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p><pre class="line-numbers language-none"><code class="language-none">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来会对 slave 进行排序：</p><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><h3 id="7-哨兵集群的configuration-epoch和configuration-传播"><a href="#7-哨兵集群的configuration-epoch和configuration-传播" class="headerlink" title="7.哨兵集群的configuration epoch和configuration 传播"></a>7.哨兵集群的configuration epoch和configuration 传播</h3><p>哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置。</p><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。</p><p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 <code>pub/sub</code> 消息机制。</p><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master  配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。</p><h3 id="8-哨兵主备切换的数据丢失问题及解决方案"><a href="#8-哨兵主备切换的数据丢失问题及解决方案" class="headerlink" title="8.哨兵主备切换的数据丢失问题及解决方案"></a>8.哨兵主备切换的数据丢失问题及解决方案</h3><h4 id="8-1数据丢失的两种情况"><a href="#8-1数据丢失的两种情况" class="headerlink" title="8.1数据丢失的两种情况"></a>8.1数据丢失的两种情况</h4><p>主备切换的过程，可能会导致数据丢失：</p><ul><li>异步复制导致的数据丢失</li></ul><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p><img src="/2021/06/02/redis-zhi-shao-bing-mo-shi/async-replication-data-lose-case.png" class title="async-replication-data-lose-case"><ul><li>脑裂导致的数据丢失</li></ul><p>脑裂，也就是说，某个 master 所在机器突然<strong>脱离了正常的网络</strong>，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会<strong>认为</strong> master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的<strong>脑裂</strong>。</p><p>此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master  写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了</p><img src="/2021/06/02/redis-zhi-shao-bing-mo-shi/redis-cluster-split-brain.png" class title="Redis-cluster-split-brain"><h4 id="8-2数据丢失问题的解决方案"><a href="#8-2数据丢失问题的解决方案" class="headerlink" title="8.2数据丢失问题的解决方案"></a>8.2数据丢失问题的解决方案</h4><p>进行如下配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">min-slaves-to-write <span class="token number">1</span> min-slaves-max-lag <span class="token number">10</span> <span class="token comment">#这两行配置表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。</span><span class="token comment">#一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>减少异步复制数据的丢失</li></ul><p>有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。</p><ul><li>减少脑裂的数据丢失</li></ul><p>如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且  slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 哨兵模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis之分区和集群</title>
      <link href="2021/06/02/redis-zhi-fen-qu-he-ji-qun/"/>
      <url>2021/06/02/redis-zhi-fen-qu-he-ji-qun/</url>
      
        <content type="html"><![CDATA[<h2 id="redis之分区和集群"><a href="#redis之分区和集群" class="headerlink" title="redis之分区和集群"></a>redis之分区和集群</h2><blockquote><p>前言：如果你的场景是<strong>海量数据+高并发+高可用</strong>，那么仅仅是主从复制和哨兵模式还不够，你需要用的分区的方法来将海量的数据进行存储，而redis提供了redis cluster集群模式实现了分来解决海量数据问题。本文将介绍分区以及redis集群</p></blockquote><h3 id="1-分区"><a href="#1-分区" class="headerlink" title="1.分区"></a>1.分区</h3><h4 id="1-1分区的概念"><a href="#1-1分区的概念" class="headerlink" title="1.1分区的概念"></a>1.1分区的概念</h4><p>分区就是把你的数据分割到多个Redis实例中的一个过程，因此每个实例仅仅包含部分键。</p><p>分区在Redis中主要有两个目的：</p><ul><li>分区利用多台机器的内存构建一个更大数据库。如果不使用分区，数据库大小受限于单个计算机内存。</li><li>分区可以在多核和多计算机之间弹性扩展计算能力，并且分区可以在多计算机和网络适配器之间弹性扩展网络带宽。</li></ul><h4 id="1-2分区算法"><a href="#1-2分区算法" class="headerlink" title="1.2分区算法"></a>1.2分区算法</h4><p>假设我们有4个Redis实例 <strong>R0,R1,R2,R3</strong>，很多表示用户的键例如 <strong>user:1,user:2</strong>等等，我们可以找到不同方式选择实例存储指定的键。换句话说有不同的系统映射一个指定的键到一个给定的Redis服务器。</p><p><strong>范围分区</strong></p><p>通过映射某一范围的对象到特定的Redis实例。例如，我可以指定ID 0到10000的用户存储到实例<strong>R0</strong>，而ID 10001到20000的用户存储到实例<strong>R2</strong>等等。</p><p>该方案实际上是可以应用在实践中的，尽管他的缺点是需要一张映射对象范围与实例的表。这张表需要进行维护，并且我们需要为每种类型对象建立一张表，所以范围分区在Redis中常常是不受欢迎的，因为比其他分区方法更低效。</p><p><strong>哈希分区</strong></p><p>此方案适用于任何形式键，无需像范围分区一样键格式形如object_name:<id>，从而通过id来划分范围。<br>使用哈希方法（例如<a href="http://baike.baidu.com/link?url=ZxSDrvzSFWPPddBHfmCBA54HK7kJXP10dHsXHh0-UOac5M8D00Sqcoy4zfXUVW20-E3t8cXLDauWnrFlQf80Uq">crc32哈希方法</a>）将键名转换成数字。例如一个键名是foobar，crc32(foobar)输出结果就是93024922。</id></p><p>然后通过取模操作将该数字转换成0到3的数字，以便映射到四个Redis实例中的一个。93024922对4取余数等于2，这样我知道foobar键应该存储到<strong>R2</strong>实例中。</p><blockquote><p>常见的哈希分区算法有：</p><ul><li>hash 算法</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis cluster 的 hash slot 算法</li></ul></blockquote><h4 id="1-3redis的预分区"><a href="#1-3redis的预分区" class="headerlink" title="1.3redis的预分区"></a>1.3redis的预分区</h4><blockquote><p>常见面试题：分布式Redis是前期做还是后期规模上来了再做好？为什么？</p></blockquote><p>从分区的概念中，我们知道分区有一个缺点：除非只把Redis当作缓存服务器来使用，<strong>否则添加和删除Redis节点都会非常复杂</strong>。相反使用固定的键值和实例映射更加简单。</p><p>然而数据存储会经常需要变化。今天我只需要10个Redis节点（实例），但是明天我可能会需要50个节点。</p><p>因为Redis足够轻量和小巧(一个备用实例使用1M的内存)<strong>，解决这个问题的简单方法就是一开始就使用大量的实例节点</strong>。即使你开始只有一个服务器，你可以换成分布式的结构，通过分区分方式在单个服务器上来运行多个Redis实例。</p><p>你一开始可以选择的实例可数可以非常大。例如，32或者64个实例能够满足绝大多数的用户，并且可以为其提供足够的增长空间。</p><p>通过这样的方法，当摸得数据存储需求增加时，你只需要更多的Redis服务器，然后把一个节点移动到另外的服务器上面。一旦你添加了额外的服务器，你需要将一半的Redis的实例移动到第二个服务器，以此类推。</p><p>你可以使用Redis 的主从复制来减少服务的停止时间：</p><ul><li>在新服务器上开启新的redis空实例。</li><li>将节点的数据配置移动到新的从服务器上</li><li>停止你的redis客户端。</li><li>在新的服务器上更新IP地址到移动过来的节点配置文件中。</li><li>发送SLAVEOF NO ONE 命令到新服务器的从节点。</li><li>使用新的配置重启客户端。</li><li>最后关闭老服务器上不再使用的节点。</li></ul><h4 id="1-4redis分区的缺点"><a href="#1-4redis分区的缺点" class="headerlink" title="1.4redis分区的缺点"></a>1.4redis分区的缺点</h4><p>Redis分区在有些方面做的并不好：</p><ul><li>不支持多个键的操作。比如你不能操作映射在两个Redis实例上的两个集合的交叉集。（其实可以做到这一点，但是需要间接的解决）.</li><li>Redis不支持多个键的事务。</li><li>Redis是以键来分区，因此不能使用单个大键对数据集进行分片，例如一个非常大的有序集。</li><li>如果使用分区，数据的处理会变得复杂，比如你必须处理多个RDB和AOF文件，在多个实例和主机之间持久化你的数据。</li><li>添加和删除节点也会变得复杂。例如通过在运行时添加和删除节点，Redis集群通常支持透明地再均衡数据，但是其他系统像客户端分区或者代理分区的特性就不支持该特性。不过<em>Pre-sharding</em>(预分片)可以在这方面提供帮助。</li></ul><h4 id="1-5分区实现"><a href="#1-5分区实现" class="headerlink" title="1.5分区实现"></a>1.5分区实现</h4><p>分区可以在redis软件栈的不同部分被实现，我们来看看下面几种：</p><h5 id="1-5-1客户端实现"><a href="#1-5-1客户端实现" class="headerlink" title="1.5.1客户端实现"></a>1.5.1客户端实现</h5><p>客户端实现即key在redis客户端就决定了要被存储在那台Redis实例中，见下图：</p><img src="/2021/06/02/redis-zhi-fen-qu-he-ji-qun/1.png" class title="客户端实现"><p>像java实现了shardedJedisPool以及shardedJedis来实现分区</p><h5 id="1-5-2代理实现"><a href="#1-5-2代理实现" class="headerlink" title="1.5.2代理实现"></a>1.5.2代理实现</h5><p>代理实现即客户端将请求发往代理服务器，代理服务器实现了Redis协议，因此代理服务器可以代理客户端和Redis服务器通信。代理服务器通过配置的分区schema来将客户端的请求转发到正确的Redis实例中，同时将反馈消息返回给客户端。</p><p>代理实现Redis分区示意图如下：</p><img src="/2021/06/02/redis-zhi-fen-qu-he-ji-qun/2.jpg" class title="代理实现"><h5 id="1-5-3查询路由"><a href="#1-5-3查询路由" class="headerlink" title="1.5.3查询路由"></a>1.5.3查询路由</h5><p>查询路由是Redis Cluster实现的一种Redis分区方式：</p><img src="/2021/06/02/redis-zhi-fen-qu-he-ji-qun/3.jpg" class title="查询路由"><p>查询路由的过程中，我们可以将查询请求随机的发送到任意一个Redis实例，这个Redis实例负责将请求转发至正确的Redis实例中。Redis集群实现了一个通过和客户端协作的hybrid来做查询路由。</p><h4 id="1-6持久化和缓存下的分区"><a href="#1-6持久化和缓存下的分区" class="headerlink" title="1.6持久化和缓存下的分区"></a>1.6持久化和缓存下的分区</h4><p>尽管数据分区对于Redis来说无论是数据持久化存储还是缓存，在概念上都是一样的，然而对于数据持久化存储还是有一个很大的限制。</p><p>当我们使用Redis来作为持久化存储的时候，每一个key必须一直被映射到同一个Redis实例。而当Redis被当做缓存使用的时候，对于这个key，如果一个实例不能用了，这个key还可以被映射到其他的实例中。</p><p>一致性哈希实现通常使得当一个key被映射到的实例不能用的时候将这个key映射到其他实例成为可能。类似，如果增加了一台机器，一部分的key将会被映射到这台新的机器上，我们需要了解的两点如下：</p><p>1、如果Redis被用来当做缓存，且要求容易增加或删除机器，使用一致性哈希是非常简单的。</p><p>2、如果Redis被用来当做（持久）存储，一个固定的key到实例的映射是需要的，因此我们不能够再灵活的添加或删除服务器。否则，我们需要在增加或删除机器的时候系统能够重新分配key，当前Redis Cluster已经支持。</p><h3 id="2-redis集群"><a href="#2-redis集群" class="headerlink" title="2.redis集群"></a>2.redis集群</h3><p>redis集群是redis实现分区的实践</p><p>Redis集群混合使用了<strong>查询路由</strong>和<strong>客户端分区</strong>。</p><h5 id="2-1redis分区实践的发展（集群架构发展）"><a href="#2-1redis分区实践的发展（集群架构发展）" class="headerlink" title="2.1redis分区实践的发展（集群架构发展）"></a>2.1redis分区实践的发展（集群架构发展）</h5><p><strong>集群（proxy型）</strong></p><p>在前几年，Redis如果要实现分区，得<strong>借助一些中间件</strong>来实现，比如说有 <code>codis</code> ，或者 <code>twemproxy</code> 。当你读写 Redis 中间件，Redis 中间件负责将你的数据分布式存储在多台机器上的 Redis 实例中。其集群的架构如下：</p><img src="/2021/06/02/redis-zhi-fen-qu-he-ji-qun/4.png" class title="集群（proxy型）"><blockquote><p>特点：</p><p>1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins </p><p>2、支持失败节点自动删除</p><p>3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</p><p>缺点：</p><p>1、增加了新的 proxy，需要维护其高可用。</p><p>2、failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预</p></blockquote><p><strong>集群（直连型）</strong></p><p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。其架构图如下：</p><img src="/2021/06/02/redis-zhi-fen-qu-he-ji-qun/5.png" class title="集群（直连型）"><blockquote><p>特点：</p><p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p><p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p><p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p><p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p><p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p><p>缺点：</p><p>1、资源隔离性较差，容易出现相互影响的情况。</p><p>2、数据通过异步复制,不保证数据的强一致性</p></blockquote><h5 id="2-2redis集群介绍"><a href="#2-2redis集群介绍" class="headerlink" title="2.2redis集群介绍"></a>2.2redis集群介绍</h5><p>Redis cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master node，每个 master node 都可以挂载多个 slave node。这样整个 Redis  就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p><p>redis集群在启动的时候就自动在多个节点间分好片。同时提供了分片之间的可用性：当一部分redis节点故障或网络中断，集群也能继续工作。但是，当大面积的节点故障或网络中断（比如大部分的主节点都不可用了），集群就不能使用。</p><p>所以，从实用性的角度，Redis集群提供以下功能：</p><ul><li><strong>自动把数据切分到多个redis节点中</strong></li><li><strong>当一部分节点挂了或不可达，集群依然能继续工作</strong></li></ul><h5 id="2-3redis集群的tcp端口"><a href="#2-3redis集群的tcp端口" class="headerlink" title="2.3redis集群的tcp端口"></a>2.3redis集群的tcp端口</h5><p>redis集群中的每个节点都需要建立2个tcp连接，监听这2个端口：</p><blockquote><p>一个端口称之为“客户端端口”，用于接受客户端指令，与客户端交互，比如6379；</p><p>另一个端口称之为“集群总线端口”，是在客户端端口号上加10000，比如16379，用于节点之间通过二进制协议通讯。各节点通过集群总线检测宕机节点、更新配置、故障转移验证等。</p></blockquote><p>客户端只能使用客户端端口，不能使用集群总线端口。</p><p>请确保你的防火墙允许打开这两个端口，否则redis集群没法工作。客户端端口和集群总线端口之间的差值是固定的，集群总线端口比客户端端口高10000。</p><p>注意，关于集群的２个端口：</p><ul><li>客户端端口（一般是6379）需要对所有客户端和集群节点开放，因为集群节点需要通过该端口转移数据。</li><li>集群总线端口（一般是16379）只需对集群中的所有节点开放</li></ul><h5 id="2-4redis集群的分片算法"><a href="#2-4redis集群的分片算法" class="headerlink" title="2.4redis集群的分片算法"></a>2.4redis集群的分片算法</h5><p>Redis集群不是使用一致性哈希，而是使用哈希槽（hash slot）。</p><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个  hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot  的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器</p><h5 id="2-5redis集群的主从模式"><a href="#2-5redis集群的主从模式" class="headerlink" title="2.5redis集群的主从模式"></a>2.5redis集群的主从模式</h5><p>为了保证在部分节点故障或网络不通时集群依然能正常工作，集群使用了主从模型，每个哈希槽有一（主节点）到N个副本（N-1个从节点）。在我们刚才的集群例子中，有A,B,C三个节点，如果B节点故障集群就不能正常工作了，因为Ｂ节点中的哈希槽数据没法操作。但是，如果我们给每一个节点都增加一个从节点，就变成了：A,B,C三个节点是主节点，A1, B1, C1  分别是他们的从节点，当B节点宕机时，我们的集群也能正常运作。B1节点是B节点的副本，如果B节点故障，集群会提升B1为主节点，从而让集群继续正常工作。但是，如果B和B1同时故障，集群就不能继续工作了。</p><h5 id="2-6redis集群的一致性保证"><a href="#2-6redis集群的一致性保证" class="headerlink" title="2.6redis集群的一致性保证"></a>2.6redis集群的一致性保证</h5><p>Redis集群不能保证强一致性。一些已经向客户端确认写成功的操作，会在某些不确定的情况下丢失。</p><p>产生写操作丢失的第一个原因，是因为主从节点之间使用了异步的方式来同步数据。</p><p>一个写操作是这样一个流程：</p><ul><li>客户端向主节点B发起写的操作</li><li>主节点B回应客户端写操作成功</li><li>主节点B向它的从节点B1,B2,B3同步该写操作</li></ul><p>从上面的流程可以看出来，主节点B并没有等从节点B1,B2,B3写完之后再回复客户端这次操作的结果。所以，如果主节点B在通知客户端写操作成功之后，但同步给从节点之前，主节点Ｂ故障了，其中一个没有收到该写操作的从节点会晋升成主节点，该写操作就这样永远丢失了。</p><p>就像传统的数据库，在不涉及到分布式的情况下，它每秒写回磁盘。为了提高一致性，可以在写回磁盘完成之后再回复客户端，但这样就要损失性能。这种方式就等于Redis集群使用同步复制的方式。</p><p>基本上，在性能和一致性之间，需要一个权衡。如果真的需要，Redis集群支持同步复制的方式，通过WAIT指令来实现，这可以让丢失写操作的可能性降到很低。</p><h5 id="2-7redis集群节点间通信原理"><a href="#2-7redis集群节点间通信原理" class="headerlink" title="2.7redis集群节点间通信原理"></a>2.7redis集群节点间通信原理</h5><p>集群元数据的维护有两种方式：集中式、Gossip 协议。<br>Redis cluster 节点间采用 gossip 协议进行通信。</p><p><strong>集中式</strong>是将集群元数据（包括故障信息，节点的增加和删除信息，hash slot 信息等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code> 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。</p><img src="/2021/06/02/redis-zhi-fen-qu-he-ji-qun/zookeeper-centralized-storage.png" class title="zookeeper-centralized-storage"><p>Redis 维护集群元数据采用另一个方式， <strong>gossip协议</strong>，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><img src="/2021/06/02/redis-zhi-fen-qu-he-ji-qun/redis-gossip.png" class title="Redis-gossip"><p><strong>集中式</strong>的好处在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；不好在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p><p><strong>gossip</strong> 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p><h5 id="2-8redis集群的高可用和主从切换原理"><a href="#2-8redis集群的高可用和主从切换原理" class="headerlink" title="2.8redis集群的高可用和主从切换原理"></a>2.8redis集群的高可用和主从切换原理</h5><p>Redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p><p><strong>判断节点宕机</strong></p><p>如果一个节点认为另外一个节点宕机，那么就是 <code>pfail</code> ，<strong>主观宕机</strong>。如果多个节点都认为另外一个节点宕机了，那么就是 <code>fail</code> ，<strong>客观宕机</strong>，跟哨兵的原理几乎一样，sdown，odown。</p><p>在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回 <code>pong</code> ，那么就被认为 <code>pfail</code> 。</p><p>如果一个节点认为某个节点 <code>pfail</code> 了，那么会在 <code>gossip ping</code> 消息中， <code>ping</code> 给其他节点，如果<strong>超过半数</strong>的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code> 。</p><p><strong>从节点过滤</strong></p><p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。</p><p>检查每个 slave node 与 master node 断开连接的时间，如果超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code> ，那么就<strong>没有资格</strong>切换成 <code>master</code> 。</p><p><strong>从节点选举</strong></p><p>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p><p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node <code>（N/2 + 1）</code> 都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。</p><p>从节点执行主备切换，从节点切换为主节点。</p><p><strong>与哨兵比较</strong></p><p>整个流程跟哨兵相比，非常类似，所以说，Redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 分区 </category>
          
          <category> 集群 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 分区 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis之持久化</title>
      <link href="2021/06/02/redis-zhi-chi-jiu-hua/"/>
      <url>2021/06/02/redis-zhi-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="redis之持久化"><a href="#redis之持久化" class="headerlink" title="redis之持久化"></a>redis之持久化</h2><h3 id="1-redis持久化的两种方式"><a href="#1-redis持久化的两种方式" class="headerlink" title="1.redis持久化的两种方式"></a>1.redis持久化的两种方式</h3><p>redis提供了多种不同级别的持久化方式：</p><ul><li>  RDB持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li><li>  AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对AOF 文件进行重写（rewrite），使得 AOF文件的体积不会超出保存数据集状态所需的实际大小。Redis 还可以同时使AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时，它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比RDB文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li></ul><h3 id="2-redis持久化RDB"><a href="#2-redis持久化RDB" class="headerlink" title="2.redis持久化RDB"></a>2.redis持久化RDB</h3><p>RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。</p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</p><p>既然RDB机制是通过把某个时刻的所有数据生成一个快照来保存，那么就应该有一种触发机制，是实现这个过程。对于RDB来说，提供了三种机制：save、bgsave、自动化。我们分别来看一下</p><p><strong>2.1、save触发方式</strong></p><p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p><img src="/2021/06/02/redis-zhi-chi-jiu-hua/1.jpeg" class title="save触发方式"><p><strong>2.2、bgsave触发方式</strong></p><p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p><img src="/2021/06/02/redis-zhi-chi-jiu-hua/2.jpeg" class title="bgsave触发方式"><p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p><p><strong>2.3、自动触发</strong></p><p>自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p><p>①save：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发==bgsave==。</p><p>默认如下配置：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># You can set these explicitly by uncommenting the three following lines.</span><span class="token comment">#</span><span class="token comment"># save 3600 1    #表示3600 秒内如果至少有 1 个 key 的值变化，则保存</span><span class="token comment"># save 300 100   #表示300 秒内如果至少有 100 个 key 的值变化，则保存</span><span class="token comment"># save 60 10000  #表示60 秒内如果至少有 10000 个 key 的值变化，则保存save</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。</p><p>②stop-writes-on-bgsave-error ：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</p><p>③rdbcompression ；默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</p><p>④rdbchecksum ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p><p>⑤dbfilename ：设置快照的文件名，默认是 dump.rdb</p><p>⑥dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</p><p>我们可以修改这些配置来实现我们想要的效果。因为第三种方式是配置的，所以我们对前两种进行一个对比：</p><img src="/2021/06/02/redis-zhi-chi-jiu-hua/3.jpeg" class title="save与bgsave对比"><p><strong>2.4、RDB 的优点</strong></p><ul><li>  RDB是一种表示某个即时点的Redis数据的紧凑文件。RDB文件适合用于备份。例如，你可能想要每小时归档最近24小时的RDB文件，每天保存近30天的RDB快照。这允许你很容易的恢复不同版本的数据集以容灾。</li><li>  RDB非常适合于灾难恢复，作为一个紧凑的单一文件，可以被传输到远程的数据中心，或者是Amazon            S3(可能得加密)。</li><li>  RDB最大化了Redis的性能，因为Redis父进程持久化时唯一需要做的是启动(fork)一个子进程，由子进程完成所有剩余工作。父进程实例不需要执行像磁盘IO这样的操作。</li><li>  RDB在重启保存了大数据集的实例时比AOF要快。</li></ul><p><strong>2.5、RDB 的缺点</strong></p><ul><li>  当你需要在Redis停止工作(例如停电)时最小化数据丢失，RDB可能不太好。你可以配置不同的保存点(save             point)来保存RDB文件(例如，至少5分钟和对数据集100次写之后，但是你可以有多个保存点)。然而，你通常每隔5分钟或更久创建一个RDB快照，所以一旦Redis因为任何原因没有正确关闭而停止工作，你就得做好最近几分钟数据丢失的准备了。</li><li>   RDB需要经常调用fork()子进程来持久化到磁盘。如果数据集很大的话，fork()比较耗时，结果就是，当数据集非常大并且CPU性能不够强大的话，Redis会停止服务客户端几毫秒甚至一秒。AOF也需要fork()，但是你可以调整多久频率重写日志而不会有损(trade-off)持久性(durability)。</li></ul><h3 id="3-redis持久化AOF"><a href="#3-redis持久化AOF" class="headerlink" title="3.redis持久化AOF"></a>3.redis持久化AOF</h3><p>全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，我们通过配置 redis.conf 中的appendonly yes 就可以打开 AOF 功能。redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。</p><p><strong>3.1、持久化原理</strong></p><img src="/2021/06/02/redis-zhi-chi-jiu-hua/4.jpeg" class title="持久化原理"><p>每当有一个写命令过来时，就直接保存在我们的AOF文件中。</p><p><strong>3.2、日志修复</strong></p><p>如果在追加日志时，恰好遇到磁盘空间满、inode 满或断电等情况导致日志写入不完整，也没有关系，redis 提供了 redis-check-aof 工具，可以用来进行日志修复。</p><p><strong>3.3、日志重写（rewrite）原理</strong></p><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。</p><p>redis 启动 AOF 文件的内容压缩的时候，只保留可以恢复数据的最小指令集。举个例子，假如我们调用了 100 次 INCR 指令，在 AOF 文件中就要存储 100 条指令，但这明显是很低效的，完全可以把这 100 条指令合并成一条 SET 指令，这就是重写机制的原理。</p><img src="/2021/06/02/redis-zhi-chi-jiu-hua/5.jpeg" class title="rewrite原理"><p>重写aof文件的操作，并没有读取旧的aof文件，而是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响 AOF 文件的可用性，这点和快照有点类似。</p><p><strong>3.4、AOF的三种触发机制</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">appendfsync everysec <span class="token comment"># appendfsync aof持久化策略的配置</span>                     <span class="token comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span>                     <span class="token comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span>                     <span class="token comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/06/02/redis-zhi-chi-jiu-hua/6.jpeg" class title="AOF的三种触发机制"><p><strong>3.5、AOF的优点</strong></p><ul><li>  使用AOFRedis会更具有可持久性(durable)：你可以有很多不同的fsync策略：没有fsync，每秒fsync，每次请求时fsync。使用默认的每秒fsync策略，写性能也仍然很不错(fsync是由后台线程完成的，主线程继续努力地执行写请求)，即便你也就仅仅只损失一秒钟的写数据。</li><li>  AOF日志是一个追加文件，所以不需要定位，在断电时也没有损坏问题。即使由于某种原因文件末尾是一个写到一半的命令(磁盘满或者其他原因),redis-check-aof工具也可以很轻易的修复。</li><li>  当AOF文件变得很大时，Redis会自动在后台进行重写。重写是绝对安全的，因为Redis继续往旧的文件中追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦第二个文件创建完毕，Redis就会切换这两个文件，并开始往新文件追加。</li><li>   AOF文件里面包含一个接一个的操作，以易于理解和解析的格式存储。你也可以轻易的导出一个AOF文件。例如，即使你不小心错误地使用FLUSHALL命令清空一切，如果此时并没有执行重写，你仍然可以保存你的数据集，你只要停止服务器，删除最后一条命令，然后重启Redis就可以。</li></ul><p><strong>3.6、AOF的缺点</strong></p><ul><li>  对同样的数据集，AOF文件通常要大于等价的RDB文件。</li><li>  AOF可能比RDB慢，这取决于准确的fsync策略。通常fsync设置为每秒一次的话性能仍然很高，如果关闭fsync，即使在很高的负载下也和RDB一样的快。不过，即使在很大的写负载情况下，RDB还是能提供能好的最大延迟保证。</li><li>  以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</li></ul><h3 id="4-AOF和RDB对比及选择"><a href="#4-AOF和RDB对比及选择" class="headerlink" title="4.AOF和RDB对比及选择"></a>4.AOF和RDB对比及选择</h3><p>选择的话，两者加一起才更好。因为两个持久化机制你明白了，剩下的就是看自己的需求了，需求不同选择的也不一定，但是通常都是结合使用。有一张图可供总结：</p><img src="/2021/06/02/redis-zhi-chi-jiu-hua/7.jpeg" class title="AOF和RDB对比">]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis之主从复制</title>
      <link href="2021/06/02/redis-zhi-zhu-cong-fu-zhi/"/>
      <url>2021/06/02/redis-zhi-zhu-cong-fu-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="redis之主从复制"><a href="#redis之主从复制" class="headerlink" title="redis之主从复制"></a>redis之主从复制</h2><p>redis的高并发和高可用分别是通过主从复制和哨兵进行主从切换来实现的</p><p>本文主要讲的是主从复制</p><h3 id="1-主从复制的概念"><a href="#1-主从复制的概念" class="headerlink" title="1.主从复制的概念"></a>1.主从复制的概念</h3><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><h3 id="2-主从复制的作用"><a href="#2-主从复制的作用" class="headerlink" title="2.主从复制的作用"></a>2.主从复制的作用</h3><ul><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务<br>的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务<br>（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写<br>少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是<br>Redis高可用的基础。</li></ul><h3 id="3-主从复制使用场景"><a href="#3-主从复制使用场景" class="headerlink" title="3.主从复制使用场景"></a>3.主从复制使用场景</h3><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：<br>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较<br>大；<br>2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有<br>内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。<br>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。<br>对于这种场景，我们可以使如下这种架构：</p><img src="/2021/06/02/redis-zhi-zhu-cong-fu-zhi/1.png" class title="主从复制架构"><h3 id="4-主从复制配置及命令"><a href="#4-主从复制配置及命令" class="headerlink" title="4.主从复制配置及命令"></a>4.主从复制配置及命令</h3><p><strong>不配置服务器的配置文件</strong></p><p>在不配置服务器的配置文件时，redis服务器启动后默认是主节点，我们可以通过命令来实现主从复制。</p><p>首先查看服务器的状态，可以用info replication或者role命令，如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> info replication<span class="token comment"># Replication</span>role:masterconnected_slaves:0master_failover_state:no-failovermaster_replid:9577659227d8a99d60421bb0101bf3d127e64d61master_replid2:563db112a7e48e4c77f894c62b8a779bd9f1bd97master_repl_offset:125second_repl_offset:85repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:125<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> role<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"slave"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6380</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"connect"</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，如果没有在配置文件中配置，每次服务器启动都是主节点。</p><p>然后通过以下命令设置服务器为slave节点。在从机只能读。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:638<span class="token operator"><span class="token file-descriptor important">0</span>></span> SLAVEOF <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token comment">#将本机配置为6379的从机</span>OK<span class="token number">127.0</span>.0.1:638<span class="token operator"><span class="token file-descriptor important">0</span>></span> ROLE <span class="token comment">#信息</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"slave"</span> <span class="token comment">#现在是从机了</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6379</span> <span class="token comment">#主机信息</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"connected"</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">139</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果主机挂了，从机没有写的功能，这个服务就崩了，可以通过以下命令将服务器从slave节点变回master。即使主机恢复了，也只是光杆司令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:638<span class="token operator"><span class="token file-descriptor important">0</span>></span> SLAVEOF no oneOK<span class="token number">127.0</span>.0.1:638<span class="token operator"><span class="token file-descriptor important">0</span>></span> role<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"master"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">433</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>empty array<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>配置服务器的配置文件</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">replicaof <span class="token operator">&lt;</span>masterip<span class="token operator">></span> <span class="token operator">&lt;</span>masterport<span class="token operator">></span> <span class="token comment">#如果要配置为salve，配置文件中需要配置这个</span>masterauth <span class="token operator">&lt;</span>master-password<span class="token operator">></span> <span class="token comment">#验证主机用户名和密码</span>masteruser <span class="token operator">&lt;</span>username<span class="token operator">></span>replica-read-only <span class="token function">yes</span> <span class="token comment">#默认从机是只读的</span>repl-diskless-sync no <span class="token comment">#是否启动无磁盘复制 默认不开启</span>repl-diskless-sync-delay <span class="token number">5</span> <span class="token comment">#配置传输开始的延迟时间，以便等待更多的从服务器连接上来</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-主从复制的原理及核心机制"><a href="#5-主从复制的原理及核心机制" class="headerlink" title="5.主从复制的原理及核心机制"></a>5.主从复制的原理及核心机制</h3><h4 id="5-1主从复制的原理"><a href="#5-1主从复制的原理" class="headerlink" title="5.1主从复制的原理"></a>5.1主从复制的原理</h4><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 <code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node  有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><img src="/2021/06/02/redis-zhi-zhu-cong-fu-zhi/redis-master-slave-replication.png" class title="Redis-master-slave-replication"><h4 id="5-2主从复制的核心机制"><a href="#5-2主从复制的核心机制" class="headerlink" title="5.2主从复制的核心机制"></a>5.2主从复制的核心机制</h4><ul><li>Redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li></ul><blockquote><p>注意，如果采用了主从架构，那么建议必须<strong>开启</strong> master node 的<a href="https://doocs.gitee.io/advanced-java/#/docs/high-concurrency/redis-persistence">持久化</a>，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p><p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使高可用时采用了哨兵机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p></blockquote><h4 id="5-3主从复制的断点续传"><a href="#5-3主从复制的断点续传" class="headerlink" title="5.3主从复制的断点续传"></a>5.3主从复制的断点续传</h4><p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p><p>它的工作原理是这样，<strong>主服务器端为复制流维护一个内存缓冲区</strong>（in-memory backlog）。<strong>主从服务器都维护一个复制偏移量（replication offset）和master run id ，当连接断开时，从服务器会重新连接上主服务器，然后请求继续复制</strong>，<strong>假如主从服务器的两个master run id相同，并且指定的偏移量在内存缓冲区中还有效，复制就会从上次中断的点开始继续</strong>。如果其中一个条件不满足，就会进行完全重新同步（在2.8版本之前就是直接进行完全重新同步）。因为主运行id不保存在磁盘中，如果从服务器重启了的话就只能进行完全同步了。</p><h4 id="5-4主从复制的无磁盘复制"><a href="#5-4主从复制的无磁盘复制" class="headerlink" title="5.4主从复制的无磁盘复制"></a>5.4主从复制的无磁盘复制</h4><p>通常来讲，一个完全重新同步需要在磁盘上创建一个RDB文件，然后加载这个文件以便为从服务器发送数据。</p><p><strong>如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力</strong>。Redis从2.8.18版本开始尝试支持无磁盘的复制。使用这种设置时，子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">repl-diskless-sync no <span class="token comment">#是否启动无磁盘复制 默认不开启</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-5主从复制的过期key处理"><a href="#5-5主从复制的过期key处理" class="headerlink" title="5.5主从复制的过期key处理"></a>5.5主从复制的过期key处理</h4><p>slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p><h4 id="5-6主从复制的全量复制和增量复制"><a href="#5-6主从复制的全量复制和增量复制" class="headerlink" title="5.6主从复制的全量复制和增量复制"></a>5.6主从复制的全量复制和增量复制</h4><p><strong>复制的完整流程</strong></p><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><blockquote><p>tips<br>异步复制:  master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</p></blockquote><img src="/2021/06/02/redis-zhi-zhu-cong-fu-zhi/redis-master-slave-replication-detail.png" class title="Redis-master-slave-replication-detail"><h5 id="5-6-1全量复制"><a href="#5-6-1全量复制" class="headerlink" title="5.6.1全量复制"></a>5.6.1全量复制</h5><ul><li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li><li>master node 将 rdb  快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node  就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</li><li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</li><li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">client-output-buffer-limit slave 256MB 64MB <span class="token number">60</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时<strong>基于旧的数据版本</strong>对外提供服务。</li><li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</li></ul><h5 id="5-6-2增量复制"><a href="#5-6-2增量复制" class="headerlink" title="5.6.2增量复制"></a>5.6.2增量复制</h5><ul><li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li><li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</li><li>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</li></ul><h4 id="5-7主从复制的heartbeat"><a href="#5-7主从复制的heartbeat" class="headerlink" title="5.7主从复制的heartbeat"></a>5.7主从复制的heartbeat</h4><p>主从节点互相都会发送 heartbeat 信息。</p><p>master 默认每隔 10 秒发送一次 heartbeat，slave node 每隔 1 秒发送一个 heartbeat。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 主从复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis之起步</title>
      <link href="2021/06/02/redis-zhi-tan-tan-shu-ju-jia-gou/"/>
      <url>2021/06/02/redis-zhi-tan-tan-shu-ju-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="redis起步"><a href="#redis起步" class="headerlink" title="redis起步"></a>redis起步</h2><h3 id="1-数据架构前言"><a href="#1-数据架构前言" class="headerlink" title="1.数据架构前言"></a>1.数据架构前言</h3><p>现如今的数据架构：</p><p>业务模型的不同字段分布在不同的数据源，以商品信息为例：</p><p>1、商品的基本信息</p><blockquote><p>名称、价格、出厂日期、生产厂商等</p><p>存储在关系型数据库mysql、oracle</p></blockquote><p>2、商品描述、详情、评价信息（多文字类）</p><blockquote><p>多文字信息描述类，IO读写性能变差</p><p>存储在文档数据库MongDB中</p></blockquote><p>3、商品图片</p><blockquote><p>商品图片展现类<br>分布式文件系统中</p><ul><li>淘宝自己的 TFS</li><li>Google的 GFS</li><li>Hadoop的 HDFS</li></ul></blockquote><p>4、商品关键字</p><blockquote><p>搜索引擎（solar、ES、ISearch（淘宝内用））</p></blockquote><p>5、商品的波段性的热点高频信息</p><blockquote><p>内存数据库<br>Tair、Redis、Memcache等</p></blockquote><p>6、商品的交易，价格计算，积分累计！</p><blockquote><p>外部系统，外部第三方支付接口<br>支付宝</p></blockquote><h3 id="2-难点及解决方案"><a href="#2-难点及解决方案" class="headerlink" title="2.难点及解决方案"></a>2.难点及解决方案</h3><p>大型互联网应用（大数据，高并发，多样数据类型）的难点和解决方案</p><p>难点：</p><ul><li>数据类型的多样性</li><li>数据源多样性和变化重构</li><li>数据源改造而数据服务平台不需要大面积重构</li></ul><p>解决办法：</p><p>可参考阿里巴巴中文站架构实践文档。</p><h3 id="3-NoSQL分类及介绍对比"><a href="#3-NoSQL分类及介绍对比" class="headerlink" title="3.NoSQL分类及介绍对比"></a>3.NoSQL分类及介绍对比</h3><p><strong>NoSQL四大分类</strong></p><p><code>KV键值</code>：</p><ul><li>新浪：BerkeleyDB+redis</li><li>美团：redis+tair</li><li>阿里、百度：memcache+redis</li></ul><p><code>文档型数据库(bson格式比较多)</code>：</p><ul><li>CouchDB</li><li>MongoDB<ul><li>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可<br>扩展的高性能数据存储解决方案。</li><li>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰<br>富，最像关系数据库的。</li></ul></li></ul><p><code>列存储数据库</code>：</p><ul><li>Cassandra, HBase</li><li>分布式文件系统</li></ul><p><code>图关系数据库</code>：</p><ul><li>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统</li><li>社交网络，推荐系统等。专注于构建关系图谱</li><li>Neo4J, InfoGrid</li></ul><p>四者对比：</p><table><thead><tr><th>分类</th><th>典型应用场景</th><th>Examples举例</th><th>数据模型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>键值对</td><td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些</td><td>Tokyo Cabinet/Tyrant，Redis，Voldmort，Oracle BDB</td><td>Key指向Value的键值对，通常用hash table来实现</td><td>查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td></tr><tr><td>列存储数据库</td><td>Cassandra，HBase，Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td>文档型数据库</td><td>CouchDB，MongoDB</td><td>Web应用（与key-value类似，value是结构化的，不同的是数据库能够了解value的内容）</td><td>key-value对应的键值对，value为结构化数据</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样预先定义表的结构</td><td>查询性能不高，而且缺乏统一的查询语法</td></tr><tr><td>图形数据库</td><td>Neo4J，InfoGrid，Infinite Graph</td><td>社交网络，推荐系统等。专注构建关系图谱</td><td>图结构</td><td>利用图结构相关算法。比如最短路径算法，A*算法</td><td>需要对整个图进行计算才能得到所需要的信息，而且这种结构不好做分布式的集群方案</td></tr></tbody></table><p>tips</p><blockquote><p>分布式和集群释义：<br>1、分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc通信和调用，对外<br>提供服务和组内协作。<br>2、集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供<br>服务和访问。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 数据架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis之redis配置文件详解</title>
      <link href="2021/06/02/redis-zhi-redis-pei-zhi-wen-jian-xiang-jie/"/>
      <url>2021/06/02/redis-zhi-redis-pei-zhi-wen-jian-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="redis之redis配置文件详解"><a href="#redis之redis配置文件详解" class="headerlink" title="redis之redis配置文件详解"></a>redis之redis配置文件详解</h2><h3 id="1-配置文件位置"><a href="#1-配置文件位置" class="headerlink" title="1.配置文件位置"></a>1.配置文件位置</h3><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf</p><p>我们一般情况下，会单独拷贝出来一份进行操作。来保证初始文件的安全。</p><h3 id="2-通过命令获取并修改配置"><a href="#2-通过命令获取并修改配置" class="headerlink" title="2.通过命令获取并修改配置"></a>2.通过命令获取并修改配置</h3><p>redis操作配置文件的命令是config</p><p>获取所有配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> config get *  <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"rdbchecksum"</span>  <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"yes"</span>  <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"daemonize"</span>  <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"yes"</span>  <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"io-threads-do-reads"</span>  <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"no"</span>  <span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"lua-replicate-commands"</span>  <span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">"yes"</span>  、、、<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取制定配置或者通过通配符过滤想要的配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> config get *pass<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"requirepass"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">""</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> config get requirepass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为指定配置设置值</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> config <span class="token builtin class-name">set</span> requirepass <span class="token number">123456</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> config get requirepass<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"requirepass"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"123456"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-不同模块的配置详解"><a href="#3-不同模块的配置详解" class="headerlink" title="3.不同模块的配置详解"></a>3.不同模块的配置详解</h3><blockquote><p>units 单位</p></blockquote><img src="/2021/06/02/redis-zhi-redis-pei-zhi-wen-jian-xiang-jie/1.png" class title="单位的配置"><p>1、配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>2、对大小写 不敏感</p><blockquote><p>INCLUDES 包含</p></blockquote><img src="/2021/06/02/redis-zhi-redis-pei-zhi-wen-jian-xiang-jie/2.png" class title="INCLUDES配置"><p>和Spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！</p><blockquote><p>NETWORK 网络配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">bind</span> <span class="token number">127.0</span>.0.1 <span class="token comment"># 绑定的ip</span>protected-mode <span class="token function">yes</span> <span class="token comment"># 保护模式</span>port <span class="token number">6379</span> <span class="token comment"># 默认端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>GENERAL 通用配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">daemonize <span class="token function">yes</span> <span class="token comment"># 默认情况下，Redis不作为守护进程运行。需要开启的话，改为 yes</span>supervised no <span class="token comment"># 可通过upstart和systemd管理Redis守护进程</span>pidfile /var/run/redis_6379.pid <span class="token comment"># 以后台进程方式运行redis，则需要指定pid 文件</span><span class="token function">timeout</span> <span class="token number">300</span> <span class="token comment">#当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span>loglevel notice <span class="token comment"># 日志级别。可选项有：</span><span class="token comment"># debug（记录大量日志信息，适用于开发、测试阶段）；</span><span class="token comment"># verbose（较多日志信息）；</span><span class="token comment"># notice（适量日志信息，使用于生产环境）；</span><span class="token comment"># warning（仅有部分重要、关键信息才会被记录）。</span>logfile <span class="token string">""</span> <span class="token comment"># 日志文件的位置，当指定为空字符串时，为标准输出</span>databases <span class="token number">16</span> <span class="token comment"># 设置数据库的数目。默认的数据库是DB 0</span>always-show-logo <span class="token function">yes</span> <span class="token comment"># 是否总是显示logo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>SNAPSHOPTING 快照配置（快照配置即RDB持久方式的配置）</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）</span>save <span class="token number">900</span> <span class="token number">1</span><span class="token comment"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）</span>save <span class="token number">300</span> <span class="token number">10</span><span class="token comment"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span>save <span class="token number">60</span> <span class="token number">10000</span>stop-writes-on-bgsave-error <span class="token function">yes</span> <span class="token comment"># 当后台持久化出现错误后，是否停止写入</span>rdbcompression <span class="token function">yes</span> <span class="token comment"># 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span>rdbchecksum <span class="token function">yes</span> <span class="token comment"># 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗</span>dbfilename dump.rdb <span class="token comment"># dbfilenamerdb文件名称</span><span class="token function">dir</span> ./ <span class="token comment"># dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>REPLICATION 主从复制配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">replicaof <span class="token operator">&lt;</span>masterip<span class="token operator">></span> <span class="token operator">&lt;</span>masterport<span class="token operator">></span> <span class="token comment">#如果要配置为salve，配置文件中需要配置这个</span>masterauth <span class="token operator">&lt;</span>master-password<span class="token operator">></span> <span class="token comment">#验证主机用户名和密码</span>masteruser <span class="token operator">&lt;</span>username<span class="token operator">></span>replica-read-only <span class="token function">yes</span> <span class="token comment">#默认从机是只读的</span>repl-diskless-sync no <span class="token comment">#是否启动无磁盘复制 默认不开启</span>repl-diskless-sync-delay <span class="token number">5</span> <span class="token comment">#配置传输开始的延迟时间，以便等待更多的从服务器连接上来</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>SECURITY 安全配置</p></blockquote><p>访问密码的查看，设置和取消</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 启动redis</span><span class="token comment"># 连接客户端</span><span class="token comment"># 获得和设置密码</span>config get requirepassconfig <span class="token builtin class-name">set</span> requirepass <span class="token string">"123456"</span><span class="token comment">#测试ping，发现需要验证</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token function">ping</span>NOAUTH Authentication required.<span class="token comment"># 验证</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> auth <span class="token number">123456</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token function">ping</span>PONG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>CLIENTS和MEMORY MANAGEMENT  客户端和内存管理配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">maxclients <span class="token number">10000</span> <span class="token comment"># 设置能连上redis的最大客户端连接数量</span>maxmemory <span class="token operator">&lt;</span>bytes<span class="token operator">></span> <span class="token comment"># redis配置的最大内存容量</span>maxmemory-policy noeviction <span class="token comment"># maxmemory-policy 内存达到上限的处理策略</span><span class="token comment">#volatile-lru：利用LRU算法移除设置过过期时间的key。</span>                            <span class="token comment">#volatile-random：随机移除设置过过期时间的key。</span>                            <span class="token comment">#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）</span>                            <span class="token comment">#allkeys-lru：利用LRU算法移除任何key。</span>                            <span class="token comment">#allkeys-random：随机移除任何key。</span>                            <span class="token comment">#noeviction：不移除任何key，只是返回一个写错误。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>AOF配置</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">appendonly no <span class="token comment"># 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种方式在许多应用中已经足够用了</span>appendfilename <span class="token string">"appendonly.aof"</span> <span class="token comment"># appendfilename AOF 文件名称</span>appendfsync everysec <span class="token comment"># appendfsync aof持久化策略的配置</span>                     <span class="token comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span>                     <span class="token comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span>                     <span class="token comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git分支</title>
      <link href="2021/05/30/git-fen-zhi/"/>
      <url>2021/05/30/git-fen-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p><p>有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p><h3 id="2-git分支原理介绍"><a href="#2-git分支原理介绍" class="headerlink" title="2.git分支原理介绍"></a>2.git分支原理介绍</h3><blockquote><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 <strong>快照</strong> 。</p></blockquote><p>在进行提交操作时，Git 会保存一个提交对象（commit object）。该提交对象会包含一个指向<code>暂存内容快照的指针</code>以及<code>作者的姓名和邮箱</code>、<code>提交时输入的信息</code>以及<code>指向它的父对象的指针</code>。 ==首次提交==产生的提交对象没有父对象，==普通提交==操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象，</p><p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 <a href="https://git-scm.com/book/zh/v2/ch00/ch01-getting-started">起步</a> 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 <em>blob</em> 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git add README test.rb LICENSE$ git commit -m &#39;The initial commit of my project&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为<em>树(tree)对象</em>。随后，Git 便会创建一个<em>提交(commit)对象</em>， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>现在，Git 仓库中有五个对象：三个 <em>blob</em> 对象（保存着文件快照）、一个 <strong>树</strong> 对象 （记录着目录结构和 blob 对象索引）以及一个 <strong>提交</strong> 对象（包含着指向前述树对象的指针和所有提交信息）。</p><img src="/2021/05/30/git-fen-zhi/commit-and-tree.png" class title="首次提交对象及其树结构。"><p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><img src="/2021/05/30/git-fen-zhi/commits-and-parents.png" class title="提交对象及其父对象。"><p><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 <code>master</code> 分支会在每次提交时自动向前移动。</strong></p><p>下图是分支及其提交历史：（v1.0和master分别是两个分支，都指向最后一次修改的提交对象，HEAD指向正在使用的分支）</p><img src="/2021/05/30/git-fen-zhi/branch-and-history.png" class title="分支及其提交历史。"><h3 id="3-分支创建"><a href="#3-分支创建" class="headerlink" title="3.分支创建"></a>3.分支创建</h3><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch testing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会在当前所在的提交对象上创建一个指针。</p><img src="/2021/05/30/git-fen-zhi/two-branches.png" class title="两个指向相同提交历史的分支。"><p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <strong>创建</strong> 一个新分支，并不会自动切换到新分支中去。</p><img src="/2021/05/30/git-fen-zhi/head-to-master.png" class title="HEAD 指向当前所在的分支。"><p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log --oneline --decoratef30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new formats to the central interface34ac2 Fixed bug #1328 - stack overflow under certain conditions98ca9 The initial commit of my project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>正如你所见，当前 <code>master</code> 和 <code>testing</code> 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p><h3 id="4-分支切换"><a href="#4-分支切换" class="headerlink" title="4.分支切换"></a>4.分支切换</h3><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout testing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p><img src="/2021/05/30/git-fen-zhi/head-to-testing.png" class title="HEAD 指向当前所在的分支。"><p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ vim test.rb$ git commit -a -m &#39;made a change&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/05/30/git-fen-zhi/advance-testing.png" class title="HEAD 分支随着提交操作自动向前移动。"><p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/05/30/git-fen-zhi/checkout-master.png" class title="检出时 HEAD 随之移动。"><p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code> 分支所做的修改，以便于向另一个方向进行开发。</p><table><thead><tr><th>Note</th><th>分支切换会改变你工作目录中的文件 在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>我们不妨再稍微做些修改并提交：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ vim test.rb$ git commit -a -m &#39;made other changes&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，这个项目的提交历史已经产生了分叉。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><img src="/2021/05/30/git-fen-zhi/advance-master.png" class title="项目分叉历史。"><p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log --oneline --decorate --graph --all* c2b9e (HEAD, master) made other changes| * 87ab2 (testing) made a change|&#x2F;* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p><p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p><h3 id="5-分支创建与合并实例"><a href="#5-分支创建与合并实例" class="headerlink" title="5.分支创建与合并实例"></a>5.分支创建与合并实例</h3><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ol><li>开发某个网站。</li><li>为实现某个新的用户需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h4 id="5-1新建分支"><a href="#5-1新建分支" class="headerlink" title="5.1新建分支"></a>5.1新建分支</h4><p>首先，我们假设你正在你的项目上工作，并且在 <code>master</code> 分支上已经有了一些提交。</p><img src="/2021/05/30/git-fen-zhi/basic-branching-1.png" class title="一个简单的提交历史。"><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout -b iss53Switched to a new branch &quot;iss53&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它是下面两条命令的简写：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch iss53$ git checkout iss53<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/05/30/git-fen-zhi/basic-branching-2.png" class title="创建一个新分支指针。"><p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经checkout到该分支 （也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ vim index.html$ git commit -a -m &#39;added a new footer [issue 53]&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/05/30/git-fen-zhi/basic-branching-3.png" class title="&#96;iss53&#96; 分支随着工作的进展向前推进。"><p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起， 你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p><p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改， 它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout masterSwitched to branch &#39;master&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p><p>接下来，你要修复这个紧急问题。 我们来建立一个 <code>hotfix</code> 分支，在该分支上工作直到问题解决：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout -b hotfixSwitched to a new branch &#39;hotfix&#39;$ vim index.html$ git commit -a -m &#39;fixed the broken email address&#39;[hotfix 1fb7853] fixed the broken email address 1 file changed, 2 insertions(+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/05/30/git-fen-zhi/basic-branching-4.png" class title="基于 &#96;master&#96; 分支的紧急问题分支（hotfix branch）。"><h4 id="5-2分支快进合并-fast-forward"><a href="#5-2分支快进合并-fast-forward" class="headerlink" title="5.2分支快进合并(fast-forward)"></a>5.2分支快进合并(fast-forward)</h4><p>你可以运行你的测试，确保你的修改是正确的，然后将 <code>hotfix</code> 分支合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在合并的时候，你应该注意到了“快进（fast-forward）”这个词。 由于你想要合并的分支 <code>hotfix</code> 所指向的提交 <code>C4</code> 是你所在的提交 <code>C2</code> 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p><img src="/2021/05/30/git-fen-zhi/basic-branching-5.png" class title="&#96;master&#96; 被快进到 &#96;hotfix&#96;。"><h4 id="5-3分支删除"><a href="#5-3分支删除" class="headerlink" title="5.3分支删除"></a>5.3分支删除</h4><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code> 分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch -d hotfixDeleted branch hotfix (3a0874c).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout iss53Switched to branch &quot;iss53&quot;$ vim index.html$ git commit -a -m &#39;finished the new footer [issue 53]&#39;[iss53 ad82d7a] finished the new footer [issue 53]1 file changed, 1 insertion(+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/05/30/git-fen-zhi/basic-branching-6.png" class title="继续在 &#96;iss53&#96; 分支上的工作。"><p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p><h4 id="5-4分支的合并-recursive"><a href="#5-4分支的合并-recursive" class="headerlink" title="5.4分支的合并(recursive)"></a>5.4分支的合并(recursive)</h4><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout masterSwitched to branch &#39;master&#39;$ git merge iss53Merge made by the &#39;recursive&#39; strategy.index.html |    1 +1 file changed, 1 insertion(+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的公共祖先（<code>C2</code>），做一个简单的三方合并。</p><img src="/2021/05/30/git-fen-zhi/basic-merging-1.png" class title="一次典型合并中所用到的三个快照。"><p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><img src="/2021/05/30/git-fen-zhi/basic-merging-2.png" class title="一个合并提交。"><p>既然你的修改已经合并进来了，就不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch -d iss53<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-3遇到冲突时的分支合并"><a href="#5-3遇到冲突时的分支合并" class="headerlink" title="5.3遇到冲突时的分支合并"></a>5.3遇到冲突时的分支合并</h4><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 分支的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git statusOn branch masterYou have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)    both modified:      index.htmlno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>contact : email.support@github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>=======<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> please contact us at support@github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>>>>>>>> iss53:index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>please contact us at email.support@github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。<br> 在你解决了所有文件里的冲突之后，对每个文件使用 ==git add== 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git statusOn branch masterAll conflicts fixed but you are still merging.  (use &quot;git commit&quot; to conclude merge)Changes to be committed:    modified:   index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 ==git commit== 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">Merge branch &#39;iss53&#39;Conflicts:    index.html## It looks like you may be committing a merge.# If this is not correct, please remove the file#.git&#x2F;MERGE_HEAD# and try again.# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.# On branch master# All conflicts fixed but you are still merging.## Changes to be committed:#modified:   index.html#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-分支管理"><a href="#6-分支管理" class="headerlink" title="6.分支管理"></a>6.分支管理</h3><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch  iss53* master  testing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。  如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch -v  iss53   93b412c fix javascript issue* master  7a98805 Merge branch &#39;iss53&#39;  testing 782fd34 add scott to the author list in the readmes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch --merged  iss53* master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch --no-merged  testing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch -d testingerror: The branch &#39;testing&#39; is not fully merged.If you are sure you want to delete it, run &#39;git branch -D testing&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><h3 id="7-git开发工作流"><a href="#7-git开发工作流" class="headerlink" title="7.git开发工作流"></a>7.git开发工作流</h3><p>现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？ 在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷， 才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。</p><h4 id="7-1长期分支"><a href="#7-1长期分支" class="headerlink" title="7.1长期分支"></a>7.1长期分支</h4><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。</p><p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的主题分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><img src="/2021/05/30/git-fen-zhi/lr-branches-1.png" class title="趋于稳定分支的线性图。"><p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><img src="/2021/05/30/git-fen-zhi/lr-branches-2.png" class title="趋于稳定分支的工作流（“silo”）视图。"><p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code> 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p><h4 id="7-2主题分支"><a href="#7-2主题分支" class="headerlink" title="7.2主题分支"></a>7.2主题分支</h4><p>主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（<code>VCS</code>）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p><p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 主题分支中看到过这种用法。 你在上一节用到的主题分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code> 分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code> 的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p><img src="/2021/05/30/git-fen-zhi/topic-branches-1.png" class title="拥有多个主题分支的提交历史。"><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案。 另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p><img src="/2021/05/30/git-fen-zhi/topic-branches-2.png" class title="合并了 &#96;dumbidea&#96; 和 &#96;iss91v2&#96; 分支之后的提交历史。"><p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。</p><h3 id="8-远程分支"><a href="#8-远程分支" class="headerlink" title="8.远程分支"></a>8.远程分支</h3><p>远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。</p><p>它们以 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的形式命名。 例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code> 分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支， 然而在服务器上的分支会以 <code>origin/iss53</code> 来表示。</p><p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p><img src="/2021/05/30/git-fen-zhi/remote-branches-1.png" class title="克隆之后的服务器与本地仓库。"><p>如果你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p><img src="/2021/05/30/git-fen-zhi/remote-branches-2.png" class title="本地与远程的工作可以分叉。"><p>Figure 31. 本地与远程的工作可以分叉</p><p>如果要与给定的远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（在本例中为 <code>git fetch origin</code>）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p><img src="/2021/05/30/git-fen-zhi/remote-branches-3.png" class title="&#96;git fetch&#96; 更新你的远程仓库引用。"><h4 id="8-1推送"><a href="#8-1推送" class="headerlink" title="8.1推送"></a>8.1推送</h4><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为 <code>serverfix</code> 的分支上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git push origin serverfixCounting objects: 24, done.Delta compression using up to 8 threads.Compressing objects: 100% (15&#x2F;15), done.Writing objects: 100% (24&#x2F;24), 1.91 KiB | 0 bytes&#x2F;s, done.Total 24 (delta 2), reused 0 (delta 0)To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit * [new branch]      serverfix -&gt; serverfix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>， 那意味着，“推送本地的 <code>serverfix</code> 分支来更新远程仓库上的 <code>serverfix</code> 分支。”<br>你也可以运行 <code>git push origin serverfix:serverfix</code>， 它会做同样的事——也就是说“推送本地的 <code>serverfix</code> 分支，将其作为远程仓库的 <code>serverfix</code> 分支”。 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git fetch originremote: Counting objects: 7, done.remote: Compressing objects: 100% (2&#x2F;2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3&#x2F;3), done.From https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit * [new branch]      serverfix    -&gt; origin&#x2F;serverfix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支——只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p><p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout -b serverfix origin&#x2F;serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch &#39;serverfix&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p><h4 id="8-2跟踪分支"><a href="#8-2跟踪分支" class="headerlink" title="8.2跟踪分支"></a>8.2跟踪分支</h4><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout --track origin&#x2F;serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch &#39;serverfix&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch &#39;serverfix&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout -b sf origin&#x2F;serverfixBranch sf set up to track remote branch serverfix from origin.Switched to a new branch &#39;sf&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch -u origin&#x2F;serverfixBranch serverfix set up to track remote branch serverfix from origin.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th>Note</th><th>上游快捷方式 当设置好跟踪分支后，可以通过简写 <code>@&#123;upstream&#125;</code> 或 <code>@&#123;u&#125;</code> 来引用它的上游分支。 所以在 <code>master</code> 分支时并且它正在跟踪 <code>origin/master</code> 时，如果愿意的话可以使用 <code>git merge @&#123;u&#125;</code> 来取代 <code>git merge origin/master</code>。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch -vv  iss53     7e424c3 [origin&#x2F;iss53: ahead 2] forgot the brackets  master    1ae2a45 [origin&#x2F;master] deploying index fix* serverfix f8674d9 [teamone&#x2F;server-fix-good: ahead 3, behind 1] this should do it  testing   5ea463a trying something new<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git fetch --all; git branch -vv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-3拉取"><a href="#8-3拉取" class="headerlink" title="8.3拉取"></a>8.3拉取</h4><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p><h4 id="8-4删除远程分支"><a href="#8-4删除远程分支" class="headerlink" title="8.4删除远程分支"></a>8.4删除远程分支</h4><p>假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git push origin --delete serverfixTo https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit - [deleted]         serverfix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> 分支 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 分支 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git起步及基础</title>
      <link href="2021/05/30/git-qi-bu-ji-ji-chu/"/>
      <url>2021/05/30/git-qi-bu-ji-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、git起步"><a href="#一、git起步" class="headerlink" title="一、git起步"></a>一、git起步</h2><p>git详细网址：<a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><h3 id="1-git是什么"><a href="#1-git是什么" class="headerlink" title="1.git是什么"></a>1.git是什么</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git 与常用的版本控制工具 CVS, Subversion(SVN) 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><h3 id="2-版本控制（VCS）"><a href="#2-版本控制（VCS）" class="headerlink" title="2.版本控制（VCS）"></a>2.版本控制（VCS）</h3><p>什么是“版本控制”？我为什么要关心它呢？ 版本控制是一种对一个或若干文件内容变化的记录，以便将来查阅特定版本修订情况的系统。     </p><p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。 但额外增加的工作量却微乎其微。</p><h4 id="2-1本地版本控制"><a href="#2-1本地版本控制" class="headerlink" title="2.1本地版本控制"></a>2.1本地版本控制</h4><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p><p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p><img src="/2021/05/30/git-qi-bu-ji-ji-chu/1.png" alt="本地版本控制图解" style="zoom:80%;"><p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 <a href="https://www.gnu.org/software/rcs/">RCS</a> 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p><h4 id="2-1集中化的版本控制"><a href="#2-1集中化的版本控制" class="headerlink" title="2.1集中化的版本控制"></a>2.1集中化的版本控制</h4><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。</p><img src="/2021/05/30/git-qi-bu-ji-ji-chu/2.png" alt="集中化的版本控制图解" style="zoom:80%;"><p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在<strong>一定程度</strong>上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><h4 id="2-3分布式版本控制系统"><a href="#2-3分布式版本控制系统" class="headerlink" title="2.3分布式版本控制系统"></a>2.3分布式版本控制系统</h4><p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><img src="/2021/05/30/git-qi-bu-ji-ji-chu/3.png" alt="分布式版本控制图解" style="zoom:80%;"><p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p><h4 id="2-4git和svn的区别"><a href="#2-4git和svn的区别" class="headerlink" title="2.4git和svn的区别"></a>2.4git和svn的区别</h4><blockquote><p><strong>1、Git 是分布式的，SVN 不是</strong>：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</p><p><strong>2、Git 把内容按元数据方式存储，而 SVN 是按文件：</strong>所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</p><p><strong>3、Git 分支和 SVN 的分支不同：</strong>分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</p><p><strong>4、Git 没有一个全局的版本号，而 SVN 有：</strong>目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</p><p><strong>5、Git 的内容完整性要优于 SVN：</strong>Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p></blockquote><h3 id="3-git简史"><a href="#3-git简史" class="headerlink" title="3.git简史"></a>3.git简史</h3><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统</p><h3 id="4-git的特性"><a href="#4-git的特性" class="headerlink" title="4.git的特性"></a>4.git的特性</h3><p>那么，简单地说，Git 究竟是怎样的一个系统呢？ 请注意接下来的内容非常重要，若你理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。 在学习 Git 时，请尽量理清你对其它版本管理系统已有的认识，如 CVS、Subversion 或 Perforce， 这样能帮助你使用工具时避免发生混淆。尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助于避免使用中的困惑。</p><h4 id="4-1直接记录快照，而非差异比较"><a href="#4-1直接记录快照，而非差异比较" class="headerlink" title="4.1直接记录快照，而非差异比较"></a>4.1直接记录快照，而非差异比较</h4><p>Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 <strong>基于差异（delta-based）</strong> 的版本控制）。</p><img src="/2021/05/30/git-qi-bu-ji-ji-chu/4.png" class title="存储每个文件与初始版本的差异。"><p>Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p><img src="/2021/05/30/git-qi-bu-ji-ji-chu/5.png" class title="Git 存储项目随时间改变的快照。"><p>这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。 Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 稍后我们在<a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a>讨论 Git 分支管理时，将探究这种方式对待数据所能获得的益处。</p><h4 id="4-2近乎所有操作都是本地执行"><a href="#4-2近乎所有操作都是本地执行" class="headerlink" title="4.2近乎所有操作都是本地执行"></a>4.2近乎所有操作都是本地执行</h4><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让你感到速度之神赐给了 Git 超凡的能量。 因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p><p>举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><p>这也意味着你在离线或者没有 VPN 时，几乎可以进行任何操作。 如你在飞机或火车上想做些工作，就能愉快地提交（到你的 <strong>本地</strong> 副本，还记得吗？）， 直到有网络连接时再上传。如你回家后 VPN 客户端不正常，那么也仍能工作。 使用其它系统的话，做到这些是不可能或很费力的。 比如，用 Perforce 的话，没有连接服务器时几乎不能做什么事；而用 Subversion 和 CVS 的话， 你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。 这样似乎问题不大，但是你可能会惊喜地发现它带来的巨大的不同。</p><h4 id="4-3Git-保证完整性"><a href="#4-3Git-保证完整性" class="headerlink" title="4.3Git 保证完整性"></a>4.3Git 保证完整性</h4><p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p><p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p><pre class="line-numbers language-none"><code class="language-none">24b9da6552252987aa493b52f8696cd6d3b00373<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p><h4 id="4-4Git-一般只添加数据"><a href="#4-4Git-一般只添加数据" class="headerlink" title="4.4Git 一般只添加数据"></a>4.4Git 一般只添加数据</h4><p>你执行的 Git 操作，几乎只往 Git 数据库中 <strong>添加</strong> 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容。但是一旦你提交快照到 Git 中， 就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><p>这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 更深度探讨 Git 如何保存数据及恢复丢失数据的话题，请参考<a href="https://git-scm.com/book/zh/v2/ch00/_undoing">撤消操作</a>。</p><h4 id="4-5三种状态"><a href="#4-5三种状态" class="headerlink" title="4.5三种状态"></a>4.5三种状态</h4><p>现在请注意，如果你希望后面的学习更顺利，请记住下面这些关于 Git 的概念。 Git 有三种状态，你的文件可能处于其中之一： <strong>已提交（committed）</strong>、<strong>已修改（modified）</strong> 和 <strong>已暂存（staged）</strong>。</p><ul><li>已修改表示修改了文件，但还没保存到数据库中。</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交表示数据已经安全地保存在本地数据库中。</li></ul><p>这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。</p><img src="/2021/05/30/git-qi-bu-ji-ji-chu/6.png" class title="工作区、暂存区以及 Git 目录。"><p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</p><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><p>如果 Git 目录中保存着特定版本的文件，就属于 <strong>已提交</strong> 状态。 如果文件已修改并放入暂存区，就属于 <strong>已暂存</strong> 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 <strong>已修改</strong> 状态。 </p><h2 id="二、git基础"><a href="#二、git基础" class="headerlink" title="二、git基础"></a>二、git基础</h2><p>本章涵盖了你在使用 Git 完成各种工作时将会用到的各种基本命令。 在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。 本章也将向你演示了如何配置 Git 来忽略指定的文件和文件模式(.ignoregit)、如何迅速而简单地撤销错误操作（reset或restore)、如何浏览你的项目的历史版本以及不同提交（commits）之间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。</p><h3 id="1-获取-Git-仓库"><a href="#1-获取-Git-仓库" class="headerlink" title="1.获取 Git 仓库"></a>1.获取 Git 仓库</h3><p>通常有两种获取 Git 项目仓库的方式：</p><ol><li>将尚未进行版本控制的本地目录转换为 Git 仓库；</li><li>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库。</li></ol><p>两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。</p><h4 id="1-1在已存在目录中初始化仓库"><a href="#1-1在已存在目录中初始化仓库" class="headerlink" title="1.1在已存在目录中初始化仓库"></a>1.1在已存在目录中初始化仓库</h4><p>如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中。 之后执行：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p><p>如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 <code>git add</code> 命令来指定所需的文件来进行追踪，然后执行 <code>git commit</code> ：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git add . #表示追踪所有文件并加到暂存区 stage$ git commit -m &#39;initial project version&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，你已经得到了一个存在被追踪文件与初始提交的 Git 仓库。</p><h4 id="1-2克隆现有的仓库"><a href="#1-2克隆现有的仓库" class="headerlink" title="1.2克隆现有的仓库"></a>1.2克隆现有的仓库</h4><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code> 命令。Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库 （虽然可能会丢失某些服务器端的钩子（hook）设置，但是所有版本的数据仍在）</p><p>克隆仓库的命令是 <code>git clone &lt;url&gt;</code> 。 比如，要克隆 Git 的链接库 <code>libgit2</code>，可以用下面的命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git clone https:&#x2F;&#x2F;github.com&#x2F;libgit2&#x2F;libgit2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 <code>libgit2</code> 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git clone https:&#x2F;&#x2F;github.com&#x2F;libgit2&#x2F;libgit2 mylibgit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会执行与上一条命令相同的操作，但目标目录名变为了 <code>mylibgit</code>。</p><h3 id="2-记录每次更新到仓库"><a href="#2-记录每次更新到仓库" class="headerlink" title="2.记录每次更新到仓库"></a>2.记录每次更新到仓库</h3><p>现在我们的机器上有了一个 <strong>真实项目</strong> 的 Git 仓库，并从这个仓库中检出了所有文件的 <strong>工作副本</strong>。 通常，你会对这些文件做些修改，每当完成了一个阶段的目标，想要将记录下它时，就将它提交到到仓库。</p><p>请记住，你工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。</p><p>工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 <strong>初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。</strong></p><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。</p><img src="/2021/05/30/git-qi-bu-ji-ji-chu/7.png" class title="Git 下文件生命周期图。"><h4 id="2-1检查当前文件状态"><a href="#2-1检查当前文件状态" class="headerlink" title="2.1检查当前文件状态"></a>2.1检查当前文件状态</h4><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.nothing to commit, working directory clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是“master”,这是默认的分支名。 我们在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 中会详细讨论分支和引用。</p><p>现在，让我们在项目下创建一个新的 <code>README</code> 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ echo &#39;My Project&#39; &gt; README$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Untracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)    READMEnothing added to commit but untracked files present (use &quot;git add&quot; to track)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在状态报告中可以看到新建的 <code>README</code> 文件出现在 <code>Untracked files</code> 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 <code>README</code> 这个文件。</p><h4 id="2-2跟踪新文件"><a href="#2-2跟踪新文件" class="headerlink" title="2.2跟踪新文件"></a>2.2跟踪新文件</h4><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 <code>README</code> 文件，运行：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git add README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时再运行 <code>git status</code> 命令，会看到 <code>README</code> 文件已被跟踪，并处于暂存状态：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)    new file:   README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 <code>git add</code> 时的版本将被留存在后续的历史记录中。 你可能会想起之前我们使用 <code>git init</code> 后就运行了 <code>git add &lt;files&gt;</code> 命令，开始跟踪当前目录下的文件。 <code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><h4 id="2-3暂存已修改的文件"><a href="#2-3暂存已修改的文件" class="headerlink" title="2.3暂存已修改的文件"></a>2.3暂存已修改的文件</h4><p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    new file:   READMEChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 <strong>这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</strong> 现在让我们运行 <code>git add</code> 将“CONTRIBUTING.md”放到暂存区，然后再看看 <code>git status</code> 的输出：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git add CONTRIBUTING.md$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    new file:   README    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ vim CONTRIBUTING.md$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    new file:   README    modified:   CONTRIBUTING.mdChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么回事？ 现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本。 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git add CONTRIBUTING.md$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    new file:   README    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4状态简览"><a href="#2-4状态简览" class="headerlink" title="2.4状态简览"></a>2.4状态简览</h4><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git status -s M READMEMM RakefileA  lib&#x2F;git.rbM  lib&#x2F;simplegit.rb?? LICENSE.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。 <code>Rakefile</code> 文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p><h4 id="2-5忽略文件"><a href="#2-5忽略文件" class="headerlink" title="2.5忽略文件"></a>2.5忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ cat .gitignore*.[oa]*~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。<br>第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。<br>此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>**</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p><p>我们再看一个 <code>.gitignore</code> 文件的例子：</p><pre class="line-numbers language-none"><code class="language-none"># 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir&#x2F;TODO&#x2F;TODO# 忽略任何目录下名为 build 的文件夹build&#x2F;# 忽略 doc&#x2F;notes.txt，但不忽略 doc&#x2F;server&#x2F;arch.txtdoc&#x2F;*.txt# 忽略 doc&#x2F; 目录及其所有子目录下的 .pdf 文件doc&#x2F;**&#x2F;*.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>Note</th><th>在最简单的情况下，一个仓库可能只根目录下有一个 <code>.gitignore</code> 文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的 <code>.gitignore</code> 文件。子目录中的 <code>.gitignore</code> 文件中的规则只作用于它所在的目录中。 （Linux 内核的源码库拥有 206 个 <code>.gitignore</code> 文件。）</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="2-6查看已暂存和未暂存的修改"><a href="#2-6查看已暂存和未暂存的修改" class="headerlink" title="2.6查看已暂存和未暂存的修改"></a>2.6查看已暂存和未暂存的修改</h4><p>如果 <code>git status</code> 命令的输出对于你来说过于简略，而你想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。  虽然 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，但 <code>git diff</code> 能通过文件补丁的格式更加具体地显示哪些行发生了改变。</p><p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code> 文件后先不暂存。</p><p>要查看<code>尚未暂存的文件</code>更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git diffdiff --git a&#x2F;CONTRIBUTING.md b&#x2F;CONTRIBUTING.mdindex 8ebb991..643e24f 100644--- a&#x2F;CONTRIBUTING.md+++ b&#x2F;CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a nice description of your changes when you submit your PR; if we have to read the whole diff to figure out why you&#39;re contributing in the first place, you&#39;re less likely to get feedback and have your change-merged in.+merged in. Also, split your changes into comprehensive chunks if your patch is+longer than a dozen lines. If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it&#39;s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若要查看<code>已暂存的文件</code>，可以用 <code>git diff --staged</code> 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git diff --stageddiff --git a&#x2F;README b&#x2F;READMEnew file mode 100644index 0000000..03902a1--- &#x2F;dev&#x2F;null+++ b&#x2F;README@@ -0,0 +1 @@+My Project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若要查看已经commit的两个版本的文件差异，可以通过git diff [文件号1] [文件号2]，文件号可以通过git log来查看</p><h4 id="2-7提交更新"><a href="#2-7提交更新" class="headerlink" title="2.7提交更新"></a>2.7提交更新</h4><p>现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有 <code>git add</code> 过， 否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git commit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样会启动你选择的文本编辑器来输入提交说明。</p><table><thead><tr><th>Note</th><th>启动的编辑器是通过 Shell 的环境变量 <code>EDITOR</code> 指定的，一般为 vim 或 emacs。 当然也可以按照 <a href="https://git-scm.com/book/zh/v2/ch00/ch01-getting-started">起步</a> 介绍的方式， 使用 <code>git config --global core.editor</code> 命令设置你喜欢的编辑器。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p><pre class="line-numbers language-none"><code class="language-none"># Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.# On branch master# Your branch is up-to-date with &#39;origin&#x2F;master&#39;.## Changes to be committed:#new file:   README#modified:   CONTRIBUTING.md#~~~&quot;.git&#x2F;COMMIT_EDITMSG&quot; 9L, 283C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。</p><table><thead><tr><th>Note</th><th>更详细的内容修改提示可以用 <code>-v</code> 选项查看，这会将你所作的更改的 diff 输出呈现在编辑器中，以便让你知道本次提交具体作出哪些修改。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>退出编辑器时，Git 会丢弃注释行，用你输入的提交说明生成一次提交。</p><p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;[master 463dc4f] Story 182: Fix benchmarks for speed 2 files changed, 2 insertions(+) create mode 100644 README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h4 id="2-8跳过使用暂存区域"><a href="#2-8跳过使用暂存区域" class="headerlink" title="2.8跳过使用暂存区域"></a>2.8跳过使用暂存区域</h4><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Changes not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   CONTRIBUTING.mdno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)$ git commit -a -m &#39;added new benchmarks&#39;[master 83e38c7] added new benchmarks 1 file changed, 5 insertions(+), 0 deletions(-)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到了吗？提交之前不再需要 <code>git add</code> 文件“CONTRIBUTING.md”了。 这是因为 <code>-a</code> 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。</p><h4 id="2-9移除文件"><a href="#2-9移除文件" class="headerlink" title="2.9移除文件"></a>2.9移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ rm PROJECTS.md$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Changes not staged for commit:  (use &quot;git add&#x2F;rm &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        deleted:    PROJECTS.mdno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git rm PROJECTS.mdrm &#39;PROJECTS.md&#39;$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    deleted:    PROJECTS.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git rm --cached README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。比如：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git rm log&#x2F;\*.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git rm \*~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令会删除所有名字以 <code>~</code> 结尾的文件。</p><h4 id="2-10移动文件"><a href="#2-10移动文件" class="headerlink" title="2.10移动文件"></a>2.10移动文件</h4><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p><p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git mv file_from file_to<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git mv README.md README$ git statusOn branch masterYour branch is up-to-date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    renamed:    README.md -&gt; README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ mv README.md README$ git rm README.md$ git add README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如此分开操作，Git 也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别是，<code>mv</code> 是一条命令而非三条命令，直接用 <code>git mv</code> 方便得多。 不过有时候用其他工具批处理重命名的话，要记得在提交前删除旧的文件名，再添加新的文件名。</p><h3 id="3-查看提交历史"><a href="#3-查看提交历史" class="headerlink" title="3.查看提交历史"></a>3.查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p><p>我们使用一个非常简单的 “simplegit” 项目作为示例。 运行下面的命令获取该项目：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git clone https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit-progit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当你在此项目中运行 <code>git log</code> 命令时，可以看到下面的输出：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git logcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date:   Mon Mar 17 21:52:11 2008 -0700    changed the version numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date:   Sat Mar 15 16:40:33 2008 -0700    removed unnecessary testcommit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date:   Sat Mar 15 10:31:28 2008 -0700    first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。</p><p>其中一个比较有用的选项是 <code>-p</code> 或 <code>--patch</code> ，它会显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 <code>-2</code> 选项来只显示最近的两次提交：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log -p -2commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date:   Mon Mar 17 21:52:11 2008 -0700    changed the version numberdiff --git a&#x2F;Rakefile b&#x2F;Rakefileindex a874b73..8f94139 100644--- a&#x2F;Rakefile+++ b&#x2F;Rakefile@@ -5,7 +5,7 @@ require &#39;rake&#x2F;gempackagetask&#39; spec &#x3D; Gem::Specification.new do |s|     s.platform  &#x3D;   Gem::Platform::RUBY     s.name      &#x3D;   &quot;simplegit&quot;-    s.version   &#x3D;   &quot;0.1.0&quot;+    s.version   &#x3D;   &quot;0.1.1&quot;     s.author    &#x3D;   &quot;Scott Chacon&quot;     s.email     &#x3D;   &quot;schacon@gee-mail.com&quot;     s.summary   &#x3D;   &quot;A simple gem for using Git in Ruby code.&quot;commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date:   Sat Mar 15 16:40:33 2008 -0700    removed unnecessary testdiff --git a&#x2F;lib&#x2F;simplegit.rb b&#x2F;lib&#x2F;simplegit.rbindex a0a60ae..47c6340 100644--- a&#x2F;lib&#x2F;simplegit.rb+++ b&#x2F;lib&#x2F;simplegit.rb@@ -18,8 +18,3 @@ class SimpleGit     end end--if $0 &#x3D;&#x3D; __FILE__-  git &#x3D; SimpleGit.new-  puts git.show-end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。 你也可以为 <code>git log</code> 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 <code>--stat</code> 选项：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log --statcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date:   Mon Mar 17 21:52:11 2008 -0700    changed the version number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date:   Sat Mar 15 16:40:33 2008 -0700    removed unnecessary test lib&#x2F;simplegit.rb | 5 ----- 1 file changed, 5 deletions(-)commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date:   Sat Mar 15 10:31:28 2008 -0700    first commit README           |  6 ++++++ Rakefile         | 23 +++++++++++++++++++++++ lib&#x2F;simplegit.rb | 25 +++++++++++++++++++++++++ 3 files changed, 54 insertions(+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如你所看到的，<code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><p>另一个非常有用的选项是 <code>--pretty</code>。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 <code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log --pretty&#x3D;onelineca82a6dff817ec66f44342007202690a93763949 changed the version number085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary testa11bef06a3f659402fe7563abf99ad00de2209e6 first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最有意思的是 <code>format</code> ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log --pretty&#x3D;format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://git-scm.com/book/zh/v2/ch00/pretty_format"><code>git log --pretty=format</code> 常用的选项</a> 列出了 <code>format</code> 接受的常用格式占位符的写法及其代表的意义。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>%H</code></td><td>提交的完整哈希值</td></tr><tr><td><code>%h</code></td><td>提交的简写哈希值</td></tr><tr><td><code>%T</code></td><td>树的完整哈希值</td></tr><tr><td><code>%t</code></td><td>树的简写哈希值</td></tr><tr><td><code>%P</code></td><td>父提交的完整哈希值</td></tr><tr><td><code>%p</code></td><td>父提交的简写哈希值</td></tr><tr><td><code>%an</code></td><td>作者名字</td></tr><tr><td><code>%ae</code></td><td>作者的电子邮件地址</td></tr><tr><td><code>%ad</code></td><td>作者修订日期（可以用 –date=选项 来定制格式）</td></tr><tr><td><code>%ar</code></td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td><code>%cn</code></td><td>提交者的名字</td></tr><tr><td><code>%ce</code></td><td>提交者的电子邮件地址</td></tr><tr><td><code>%cd</code></td><td>提交日期</td></tr><tr><td><code>%cr</code></td><td>提交日期（距今多长时间）</td></tr><tr><td><code>%s</code></td><td>提交说明</td></tr></tbody></table><p>你一定奇怪 <em>作者</em> 和 <em>提交者</em> 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch05-distributed-git">分布式 Git</a> 再详细介绍两者之间的细微差别。</p><p>当 <code>oneline</code> 或 <code>format</code> 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log --pretty&#x3D;format:&quot;%h %s&quot; --graph* 2d3acf9 ignore errors from SIGCHLD on trap*  5e3ee11 Merge branch &#39;master&#39; of git:&#x2F;&#x2F;github.com&#x2F;dustin&#x2F;grit|\| * 420eac9 Added a method for getting the current branch.* | 30e367c timeout code and tests* | 5a09431 add timeout protection to grit* | e1193f8 support for heads with slashes in them|&#x2F;* d6016bc require time for xmlschema*  11d191e Merge branch &#39;defunkt&#39; into local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。</p><p>以上只是简单介绍了一些 <code>git log</code> 命令支持的选项。 <a href="https://git-scm.com/book/zh/v2/ch00/log_options"><code>git log</code> 的常用选项</a> 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>按补丁格式显示每个提交引入的差异。</td></tr><tr><td><code>--stat</code></td><td>显示每次提交的文件修改统计信息。</td></tr><tr><td><code>--shortstat</code></td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td><code>--name-only</code></td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td><code>--name-status</code></td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td><code>--abbrev-commit</code></td><td>仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</td></tr><tr><td><code>--relative-date</code></td><td>使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。</td></tr><tr><td><code>--graph</code></td><td>在日志旁以 ASCII 图形显示分支与合并历史。</td></tr><tr><td><code>--pretty</code></td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。</td></tr><tr><td><code>--oneline</code></td><td><code>--pretty=oneline --abbrev-commit</code> 合用的简写。</td></tr></tbody></table><p><strong>限制输出长度</strong></p><p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出一部分的提交。 之前你已经看到过 <code>-2</code> 选项了，它只会显示最近的两条提交， 实际上，你可以使用类似 <code>-&lt;n&gt;</code> 的选项，其中的 <code>n</code> 可以是任何整数，表示仅显示最近的 <code>n</code> 条提交。 不过实践中这个选项不是很常用，因为 Git 默认会将所有的输出传送到分页程序中，所以你一次只会看到一页的内容。</p><p>但是，类似 <code>--since</code> 和 <code>--until</code> 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近两周的所有提交：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log --since&#x3D;2.weeks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令可用的格式十分丰富——可以是类似 <code>&quot;2008-01-15&quot;</code> 的具体的某一天，也可以是类似 <code>&quot;2 years 1 day 3 minutes ago&quot;</code> 的相对日期。</p><p>还可以过滤出匹配指定条件的提交。 用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。</p><table><thead><tr><th>Note</th><th>你可以指定多个 <code>--author</code> 和 <code>--grep</code> 搜索条件，这样会只输出 <strong>任意</strong> 匹配 <code>--author</code> 模式和 <code>--grep</code> 模式的提交。然而，如果你添加了 <code>--all-match</code> 选项， 则只会输出 <strong>所有</strong> 匹配 <code>--grep</code> 模式的提交。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>另一个非常有用的过滤器是 <code>-S</code>（俗称“pickaxe”选项，取“用鹤嘴锄在土里捡石头”之意）， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log -S function_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后一个很实用的 <code>git log</code> 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/limit_options">限制 <code>git log</code> 输出的选项</a> 中列出了常用的选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-&lt;n&gt;</code></td><td>仅显示最近的 n 条提交。</td></tr><tr><td><code>--since</code>, <code>--after</code></td><td>仅显示指定时间之后的提交。</td></tr><tr><td><code>--until</code>, <code>--before</code></td><td>仅显示指定时间之前的提交。</td></tr><tr><td><code>--author</code></td><td>仅显示作者匹配指定字符串的提交。</td></tr><tr><td><code>--committer</code></td><td>仅显示提交者匹配指定字符串的提交。</td></tr><tr><td><code>--grep</code></td><td>仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td><code>-S</code></td><td>仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table><p>来看一个实际的例子，如果要在 Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件，可以使用下面的命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git log --pretty&#x3D;&quot;%h - %s&quot; --author&#x3D;&#39;Junio C Hamano&#39; --since&#x3D;&quot;2008-10-01&quot; \   --before&#x3D;&quot;2008-11-01&quot; --no-merges -- t&#x2F;5610e3b - Fix testcase failure when extended attributes are in useacd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() APIf563754 - demonstrate breakage of detached checkout with symbolic link HEADd1a43f2 - reset --hard&#x2F;read-tree --reset -u: remove unmerged new paths51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEADb0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p><table><thead><tr><th>Tip</th><th>隐藏合并提交 按照你代码仓库的工作流程，记录中可能有为数不少的合并提交，它们所包含的信息通常并不多。 为了避免显示的合并提交弄乱历史记录，可以为 <code>log</code> 加上 <code>--no-merges</code> 选项。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="4-撤销操作"><a href="#4-撤销操作" class="headerlink" title="4.撤销操作"></a>4.撤销操作</h3><h4 id="4-1撤消操作"><a href="#4-1撤消操作" class="headerlink" title="4.1撤消操作"></a>4.1撤消操作</h4><p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git commit --amend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。</p><p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git commit -m &#39;initial commit&#39;$ git add forgotten_file$ git commit --amend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><table><thead><tr><th>Note</th><th>当你在修补最后的提交时，并不是通过用改进后的提交 <strong>原位替换</strong> 掉旧有提交的方式来修复的， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。  修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="4-2取消暂存的文件"><a href="#4-2取消暂存的文件" class="headerlink" title="4.2取消暂存的文件"></a>4.2取消暂存的文件</h4><p>接下来的两个小节演示如何操作暂存区和工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交， 但是却意外地输入 <code>git add *</code> 暂存了它们两个。如何只取消暂存两个中的一个呢？ <code>git status</code> 命令提示了你：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git add *$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    renamed:    README.md -&gt; README    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 “Changes to be committed” 文字正下方，提示使用 <code>git reset HEAD &lt;file&gt;...</code> 来取消暂存。 所以，我们可以这样来取消暂存 <code>CONTRIBUTING.md</code> 文件：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git reset HEAD CONTRIBUTING.mdUnstaged changes after reset:MCONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    renamed:    README.md -&gt; READMEChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个命令有点儿奇怪，但是起作用了。 <code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。</p><table><thead><tr><th>Note</th><th><code>git reset</code> 确实是个危险的命令，如果加上了 <code>--hard</code> 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>到目前为止这个神奇的调用就是你需要对 <code>git reset</code> 命令了解的全部。 我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/_git_reset">重置揭密</a> 中了解 <code>reset</code> 的更多细节以及如何掌握它做一些真正有趣的事。</p><h4 id="4-3撤消对文件的修改"><a href="#4-3撤消对文件的修改" class="headerlink" title="4.3撤消对文件的修改"></a>4.3撤消对文件的修改</h4><p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，<code>git status</code> 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">Changes not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   CONTRIBUTING.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git checkout -- CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    renamed:    README.md -&gt; README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到那些修改已经被撤消了。</p><table><thead><tr><th>Important</th><th>请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 介绍保存进度与分支，这通常是更好的做法。</p><p>记住，在 Git 中任何 <strong>已提交</strong> 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复 。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p><h3 id="5-远程仓库的使用"><a href="#5-远程仓库的使用" class="headerlink" title="5.远程仓库的使用"></a>5.远程仓库的使用</h3><h4 id="5-1远程仓库的使用"><a href="#5-1远程仓库的使用" class="headerlink" title="5.1远程仓库的使用"></a>5.1远程仓库的使用</h4><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。</p><table><thead><tr><th>Note</th><th>远程仓库可以在你的本地主机上 你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="5-2查看远程仓库"><a href="#5-2查看远程仓库" class="headerlink" title="5.2查看远程仓库"></a>5.2查看远程仓库</h4><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git clone https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgitCloning into &#39;ticgit&#39;...remote: Reusing existing pack: 1857, done.remote: Total 1857 (delta 0), reused 0 (delta 0)Receiving objects: 100% (1857&#x2F;1857), 374.35 KiB | 268.00 KiB&#x2F;s, done.Resolving deltas: 100% (772&#x2F;772), done.Checking connectivity... done.$ cd ticgit$ git remoteorigin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git remote -voriginhttps:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (fetch)originhttps:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ cd grit$ git remote -vbakkdoor  https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (fetch)bakkdoor  https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (push)cho45     https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (fetch)cho45     https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (push)defunkt   https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (fetch)defunkt   https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (push)koke      git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (fetch)koke      git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (push)origin    git@github.com:mojombo&#x2F;grit.git (fetch)origin    git@github.com:mojombo&#x2F;grit.git (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这表示我们能非常方便地拉取其它用户的贡献。我们还可以拥有向他们推送的权限，这里暂不详述。</p><p>注意这些远程仓库使用了不同的协议。我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/_getting_git_on_a_server">在服务器上搭建 Git</a> 中了解关于它们的更多信息。</p><h4 id="5-3添加远程仓库"><a href="#5-3添加远程仓库" class="headerlink" title="5.3添加远程仓库"></a>5.3添加远程仓库</h4><p>我们在之前的章节中已经提到并展示了 <code>git clone</code> 命令是如何自行添加远程仓库的， 不过这里将告诉你如何自己来添加它。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git remoteorigin$ git remote add pb https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit$ git remote -voriginhttps:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (fetch)originhttps:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (push)pbhttps:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (fetch)pbhttps:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git fetch pbremote: Counting objects: 43, done.remote: Compressing objects: 100% (36&#x2F;36), done.remote: Total 43 (delta 10), reused 31 (delta 5)Unpacking objects: 100% (43&#x2F;43), done.From https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit * [new branch]      master     -&gt; pb&#x2F;master * [new branch]      ticgit     -&gt; pb&#x2F;ticgit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到——你可以将它合并到自己的某个分支中， 或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p><h4 id="5-4从远程仓库中抓取与拉取"><a href="#5-4从远程仓库中抓取与拉取" class="headerlink" title="5.4从远程仓库中抓取与拉取"></a>5.4从远程仓库中抓取与拉取</h4><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git fetch &lt;remote&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><p>如果你的当前分支设置了跟踪远程分支（阅读下一节和 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 了解更多信息）， 那么可以用 <code>git pull</code> 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或其它名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h4 id="5-5推送到远程仓库"><a href="#5-5推送到远程仓库" class="headerlink" title="5.5推送到远程仓库"></a>5.5推送到远程仓库</h4><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push &lt;remote&gt; &lt;branch&gt;</code>。 当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 阅读 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 了解如何推送到远程仓库服务器的详细信息。</p><h4 id="5-6查看某个远程仓库"><a href="#5-6查看某个远程仓库" class="headerlink" title="5.6查看某个远程仓库"></a>5.6查看某个远程仓库</h4><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git remote show origin* remote origin  Fetch URL: https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit  Push  URL: https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit  HEAD branch: master  Remote branches:    master                               tracked    dev-branch                           tracked  Local branch configured for &#39;git pull&#39;:    master merges with remote master  Local ref configured for &#39;git push&#39;:    master pushes to master (up to date)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 <code>master</code> 分支，并且如果运行 <code>git pull</code>， 就会抓取所有的远程引用，然后将远程 <code>master</code> 分支合并到本地 <code>master</code> 分支。 它也会列出拉取到的所有远程引用。</p><p>这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 <code>git remote show</code> 看到更多的信息。</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git remote show origin* remote origin  URL: https:&#x2F;&#x2F;github.com&#x2F;my-org&#x2F;complex-project  Fetch URL: https:&#x2F;&#x2F;github.com&#x2F;my-org&#x2F;complex-project  Push  URL: https:&#x2F;&#x2F;github.com&#x2F;my-org&#x2F;complex-project  HEAD branch: master  Remote branches:    master                           tracked    dev-branch                       tracked    markdown-strip                   tracked    issue-43                         new (next fetch will store in remotes&#x2F;origin)    issue-45                         new (next fetch will store in remotes&#x2F;origin)    refs&#x2F;remotes&#x2F;origin&#x2F;issue-11     stale (use &#39;git remote prune&#39; to remove)  Local branches configured for &#39;git pull&#39;:    dev-branch merges with remote dev-branch    master     merges with remote master  Local refs configured for &#39;git push&#39;:    dev-branch                     pushes to dev-branch                     (up to date)    markdown-strip                 pushes to markdown-strip                 (up to date)    master                         pushes to master                         (up to date)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 <code>git pull</code> 时哪些本地分支可以与它跟踪的远程分支自动合并。</p><h4 id="5-7远程仓库的重命名与移除"><a href="#5-7远程仓库的重命名与移除" class="headerlink" title="5.7远程仓库的重命名与移除"></a>5.7远程仓库的重命名与移除</h4><p>你可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git remote rename pb paul$ git remoteoriginpaul<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git remote remove paul$ git remoteorigin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客之图片显示</title>
      <link href="2021/05/27/hexo-da-jian-bo-ke-zhi-tu-pian-xian-shi/"/>
      <url>2021/05/27/hexo-da-jian-bo-ke-zhi-tu-pian-xian-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo搭建博客之图片显示"><a href="#hexo搭建博客之图片显示" class="headerlink" title="hexo搭建博客之图片显示"></a>hexo搭建博客之图片显示</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在搭载好hexo(butterfly)+github博客后，新建博客无法图片问题，多方寻找网上的解决办法仍未解决;</p><p>网上主要有以下两种方法：</p><ul><li>安装hexo-asset-image插件 （不可行，图片的访问地址还是错误格式）</li><li>在引入图片时使用非md语法，不能使用md语法，如下：（可行，但是很麻烦）</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&#123;% asset_img 图片.jpg 图片描述 %&#125; //非md语法![](img/img.png) //md语法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>经上网查询后发现一位大佬的插件hexo-asset-img，它用代码实现了第二种方式，经过测试，有效！！！！！</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><h4 id="1-配置Typora偏好设置"><a href="#1-配置Typora偏好设置" class="headerlink" title="1. 配置Typora偏好设置"></a>1. 配置Typora偏好设置</h4><img src="/2021/05/27/hexo-da-jian-bo-ke-zhi-tu-pian-xian-shi/1.png" class title="偏好设置"><h4 id="2-修改-config-yml文件"><a href="#2-修改-config-yml文件" class="headerlink" title="2. 修改_config.yml文件"></a>2. 修改_config.yml文件</h4><img src="/2021/05/27/hexo-da-jian-bo-ke-zhi-tu-pian-xian-shi/2.png" class title="修改yml文件"><h4 id="3-安装插件"><a href="#3-安装插件" class="headerlink" title="3. 安装插件"></a>3. 安装插件</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install hexo-asset-img --savehexo clean &amp;&amp; hexo g &amp;&amp; hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>完美结束！</strong></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud之eureka对比zookeeper</title>
      <link href="2021/05/27/springcloud-zhi-eureka-dui-bi-zookeeper/"/>
      <url>2021/05/27/springcloud-zhi-eureka-dui-bi-zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="springcloud之eureka对比zookeeper"><a href="#springcloud之eureka对比zookeeper" class="headerlink" title="springcloud之eureka对比zookeeper"></a>springcloud之eureka对比zookeeper</h2><h3 id="1-eureka和zookeeper的cap理论"><a href="#1-eureka和zookeeper的cap理论" class="headerlink" title="1.eureka和zookeeper的cap理论"></a>1.eureka和zookeeper的cap理论</h3><p>有关CAP理论的相关分布式博客可以看我的博客：<a href="https://ciyaduxingxia.github.io/2021/05/21/fen-bu-shi-xi-tong/">分布式系统</a></p><blockquote><ul><li><p>一致性（Consistency）:所有节点访问同一份最新的数据副本</p></li><li><p>可用性（Availability）:非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）</p></li><li><p>分区容错性（网络分区）Partition tolerance:分布式系统出现网络分区的时候，仍然能够对外提供服务</p></li></ul></blockquote><p>一般来说，分区容错性P是前提，一定要保证，C和A就根据不同的需求来实现</p><blockquote><p>eureka是基于ap的。zookeeper是基于cp的。</p></blockquote><blockquote><p>Eureka:是基于REST（Representational State Transfer）服务，主要以AWS云服务为支撑，提供服务发现并实现负载均衡和故障转移。我们称此服务为Eureka服务。Eureka提供了Java客户端组件，Eureka Client，方便与服务端的交互。客户端内置了基于round-robin实现的简单负载均衡。在Netflix，为Eureka提供更为复杂的负载均衡方案进行封装，以实现高可用，它包括基于流量、资源利用率以及请求返回状态的加权负载均衡。</p><p>zookeeper:是一个高效的分布式协调服务，可以提供配置信息管理、命名、分布式同步、集群管理、数据库切换等服务。它不适合用来存储大量信息，可以用来存储一些配置、发布与订阅等少量信息。Hadoop、Storm、消息中间件、RPC服务框架、分布式数据库同步系统，这些都是Zookeeper的应用场景。</p></blockquote><h3 id="2-Eureka的实现"><a href="#2-Eureka的实现" class="headerlink" title="2.Eureka的实现"></a>2.Eureka的实现</h3><p>==eureka的架构实现图如下：==</p><img src="/2021/05/27/springcloud-zhi-eureka-dui-bi-zookeeper/1.png" class title="eureka架构图"><h3 id="3-eureka的基本原理"><a href="#3-eureka的基本原理" class="headerlink" title="3.eureka的基本原理"></a>3.eureka的基本原理</h3><p>上图是集群配置的eureka</p><ul><li>处于不同节点的eureka通过Replicate进行数据同步</li><li>Application Service为服务提供者</li><li>Application Client为服务消费者</li><li>Make Remote Call完成一次服务调用</li></ul><blockquote><p>服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka  Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。</p><p>当服务注册中心Eureka Server检测到服务提供者因为宕机、网络原因不可用时，则在服务注册中心将服务置为DOWN状态，并把当前服务提供者状态向订阅者发布，订阅过的服务消费者更新本地缓存。</p><p>服务提供者在启动后，周期性（默认30秒）向Eureka Server发送心跳，以证明当前服务是可用状态。Eureka Server在一定的时间（默认90秒）未收到客户端的心跳，则认为服务宕机，注销该实例。</p></blockquote><h3 id="4-eureka的自我保护机制"><a href="#4-eureka的自我保护机制" class="headerlink" title="4.eureka的自我保护机制"></a>4.eureka的自我保护机制</h3><p>在默认配置中，Eureka  Server在默认90s没有得到客户端的心跳，则注销该实例，但是往往因为微服务跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，但是因为网络分区故障时，Eureka Server注销服务实例则会让大部分微服务不可用，这很危险，因为服务明明没有问题。</p><p>为了解决这个问题，Eureka 有自我保护机制，通过在Eureka Server配置如下参数，可启动保护机制。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">eureka.server.enable-self-preservation</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它的原理是，当Eureka Server节点在短时间内丢失过多的客户端时（可能发送了网络故障），那么这个节点将进入自我保护模式，不再注销任何微服务，当网络故障恢复后，该节点会自动退出自我保护模式。</p><h3 id="5-eureka保证ap"><a href="#5-eureka保证ap" class="headerlink" title="5.eureka保证ap"></a>5.eureka保证ap</h3><blockquote><p>Eureka优先保证可用性。</p><p>在Eureka平台中，如果某台服务器宕机，Eureka不会有类似于ZooKeeper的选举leader的过程；客户端请求会自动切换到新Eureka节点；当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中；而对于它来说，所有要做的无非是同步一些新的服务注册信息而已。所以，再也不用担心有“掉队”的服务器恢复以后，会从Eureka服务器集群中剔除出去的风险了。</p><p>Eureka甚至被设计用来应付范围更广的网络分区故障，并实现“0”宕机维护需求。当网络分区故障发生时，每个Eureka节点，会持续的对外提供服务（注：ZooKeeper不会）：接收新的服务注册同时将它们提供给下游的服务发现请求。这样一来，就可以实现在同一个子网中（same side of  partition），新发布的服务仍然可以被发现与访问。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p></blockquote><p>除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p><ol><li><p>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</p></li><li><p>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</p></li><li><p>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</p><blockquote><p> Eureka还有客户端缓存功能（注：Eureka分为客户端程序与服务器端程序两个部分，客户端程序负责向外提供注册与发现服务接口）。所以即便Eureka集群中所有节点都失效，或者发生网络分割故障导致客户端不能访问任何一台Eureka服务器；Eureka服务的消费者仍然可以通过 Eureka客户端缓存来获取现有的服务注册信息。甚至最极端的环境下，所有正常的Eureka节点都不对请求产生响应，也没有更好的服务器解决方案来解决这种问题时；得益于Eureka的客户端缓存技术，消费者服务仍然可以通过Eureka客户端查询与获取注册服务信息。</p></blockquote></li></ol><h3 id="6-zookeeper保证cp"><a href="#6-zookeeper保证cp" class="headerlink" title="6.zookeeper保证cp"></a>6.zookeeper保证cp</h3><blockquote><p>Eureka优先保证数据的强一致性。</p><p>Zookeeper当master挂了，会在30-120s进行leader选举，这点类似于redis的哨兵机制，在选举期间Zookeeper是不可用的，这么长时间不能进行服务注册，是无法忍受的，别说30s，5s都不能忍受。这时Zookeeper集群会瘫痪，这也是Zookeeper的CP，保持节点的一致性，牺牲了A/高可用。而Eureka不会，即使Eureka有部分挂掉，还有其他节点可以使用的，他们保持平级的关系，只不过信息有可能不一致，这就是AP，牺牲了C/一致性。</p></blockquote><blockquote><p>作为一个分布式协同服务，ZooKeeper非常好，但是对于Service发现服务来说就不合适了；因为对于Service发现服务来说就算是 返回了包含不实的信息的结果也比什么都不返回要好；再者，对于Service发现服务而言，宁可返回某服务5分钟之前在哪几个服务器上可用的信息，也不能因为暂时的网络故障而找不到可用的服务器，而不返回任何结果。况且在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。所以说，用ZooKeeper来做Service发现服务是肯定错误的。</p></blockquote><h3 id="7-eureka和zookeeper的区别总结"><a href="#7-eureka和zookeeper的区别总结" class="headerlink" title="7.eureka和zookeeper的区别总结"></a>7.eureka和zookeeper的区别总结</h3><p>对于service发现服务来说，保证高可用性要比保证数据一致性的优先级高得多，而Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。这也是为什么springcloud使用eureka。Eureka作为单纯的服务注册中心来说要比zookeeper更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况。</p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
          <category> eureka </category>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> eureka </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud之feign用法及原理</title>
      <link href="2021/05/27/springcloud-zhi-feign/"/>
      <url>2021/05/27/springcloud-zhi-feign/</url>
      
        <content type="html"><![CDATA[<h2 id="springcloud之feign用法及原理"><a href="#springcloud之feign用法及原理" class="headerlink" title="springcloud之feign用法及原理"></a>springcloud之feign用法及原理</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><blockquote><p>Feign是声明式的web service客户端，它最核心的作用是为 HTTP 形式的 Rest API 提供了非常简洁高效的 RPC 调用方式，它让微服务之间的调用变得更简单了，类似controller调用service。重点注意Feign的主要目标是将Java Http 客户端变得简单，服务提供端不用Feign。Feign是spring cloud中服务消费端的调用框架,通常与ribbon,hystrix等组合使用。 如果说 Spring Cloud 其他成员解决的是系统级别的可用性，扩展性问题， 那么 OpenFeign 解决的则是与开发人员利益最为紧密的开发效率问题。</p></blockquote><h3 id="2-Feign的使用"><a href="#2-Feign的使用" class="headerlink" title="2.Feign的使用"></a>2.Feign的使用</h3><h4 id="2-1-服务提供端"><a href="#2-1-服务提供端" class="headerlink" title="2.1 服务提供端"></a>2.1 服务提供端</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//提供restful服务</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeptController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">DeptService</span> deptService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/dept/query/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Dept</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Dept</span> dept <span class="token operator">=</span> deptService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dept <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"错误id=>"</span><span class="token operator">+</span>id<span class="token operator">+</span><span class="token string">",部门信息不存在或输入id有误!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dept<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里 Feign 不需要发挥任何作用。</p><h4 id="2-2-服务消费端导入Feign依赖"><a href="#2-2-服务消费端导入Feign依赖" class="headerlink" title="2.2 服务消费端导入Feign依赖"></a>2.2 服务消费端导入Feign依赖</h4><p>项目中使用了maven作为依赖管理</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--feign--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-feign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--Ribbon--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--eureka client--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-eureka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.4.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为feign底层是使用了ribbon作为负载均衡的客户端，而ribbon的负载均衡也是依赖于eureka 获得各个服务的地址，所以要引入eureka-client。实际上服务消费端就需要引入eureka-client。</p><h4 id="2-3-服务消费端"><a href="#2-3-服务消费端" class="headerlink" title="2.3 服务消费端"></a>2.3 服务消费端</h4><p>SpringBootApplication启动类加上@EnableFeignClients的注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.itxxj.springcloud"</span><span class="token punctuation">)</span> <span class="token comment">//可以指定要扫描的包，会扫描包下所有带有@FeignClient的注解</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeptConsumer_feign</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">DeptConsumer_feign</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在application.yml中配置如下，也可以不配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">feign:  client: #feign的配置，连接超时及读取超时配置    config:      default:        connectTimeout: 5000        readTimeout: 5000        loggerLevel: basic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在接口内编写与要调用的服务相同的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"SPRINGCLOUD-PROVIDER-DEPT"</span><span class="token punctuation">)</span> <span class="token comment">//这里的value是服务提供方的名字</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DeptClientService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//这里的地址要和实现类，即服务provider那边的一样</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/dept/query/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token class-name">Dept</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再直接利用 spring 的自动注入功能， 就可以使用服务端的接口了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeptConsumerController</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//如何调用provider，SpringCloud使用rest的http而不是用RPC</span>    <span class="token comment">//RestTemplate 通过url调用</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">;</span><span class="token comment">//提供多种便捷访问远程http服务的方法，简单的restful服务模板</span>    <span class="token comment">//通过Feign，它是以接口的形式来调用远程方法</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">DeptClientService</span> service<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/consumer/dept/get/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Dept</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Feign原理分析"><a href="#3-Feign原理分析" class="headerlink" title="3.Feign原理分析"></a>3.Feign原理分析</h3><p>在展开讲解工作原理前， 首先捋一下上文中， 我们完成 Feign 调用前所进行的操作：</p><ol><li>添加了 Spring Cloud OpenFeign 的依赖</li><li>在 SpringBoot 启动类上添加了注解 <code>@EnableFeignClients</code></li><li>按照 Feign 的规则定义接口 <code>DeptClientService</code>， 添加<code>@FeignClient</code> 注解</li><li>在需要使用 Feign 接口 <code>DeptClientService</code>的地方， 直接利用<code>@Resource</code>进行注入</li><li>使用接口完成对服务端的调用</li></ol><p>可以根据上面使用 Feign 的步骤大致猜测出整体的工作流程：</p><ol><li>SpringBoot 应用启动时， 由针对 <code>@EnableFeignClient </code>这一注解的处理逻辑触发程序扫描 classPath或指定包下所有被@FeignClient 注解的类， 这里以 <code>DeptClientService</code>为例， 将这些类解析为 BeanDefinition 注册到 Spring 容器中</li><li>Sping 容器在为某些用的 Feign 接口的 Bean 注入<code> DeptClientService</code>时， Spring 会尝试从容器中查找 <code>DeptClientService</code>的实现类</li><li>由于我们从来没有编写过 <code>DeptClientService</code>的实现类， 上面步骤获取到的 DeptClientService的实现类必然是 feign 框架通过扩展 spring 的 Bean 处理逻辑， 为 <code>DeptClientService</code>创建一个==动态接口代理对象==， 这里我们将其称为 <code>DeptClientServiceProxy </code>注册到spring 容器中。</li><li>Spring 最终在使用到 <code>DeptClientService</code>的 Bean 中注入了 <code>DeptClientServiceProxy</code> 这一实例。</li><li>当业务请求真实发生时， 对于 <code>DeptClientService</code>的调用被统一转发到了由 Feign 框架实现的 <code>InvocationHandler</code>中， <code>InvocationHandler</code> 负责将接口中的入参转换为 HTTP 的形式， 发到服务端， 最后再解析 HTTP 响应， 将结果转换为 Java 对象， 予以返回。</li></ol><p>上面整个流程可以进一步简化理解为：</p><ol><li>我们定义的接口 <code>DeptClientService</code>由于添加了注解 <code>@FeignClient</code>, 最终产生了一个==虚假的实现类代理==</li><li>使用这个接口的地方， 最终拿到的都是一个假的代理实现类 <code>DeptClientServiceProxy</code></li><li>所有发生在 <code>DeptClientServiceProxy</code> 上的调用， 都被转交给 Feign 框架， 翻译成 HTTP 的形式发送出去， 并得到返回结果， 再翻译回接口定义的返回值形式。</li></ol><p>所以说从这个流程可以看出Feign确实是对SpringCloud的Http形式的调用进行了封装。而Feign 的核心实现原理就是java 原生支持的基于接口的动态代理</p><h3 id="4-Feign源码分析"><a href="#4-Feign源码分析" class="headerlink" title="4.Feign源码分析"></a>4.Feign源码分析</h3><p>FeignClient 的扫描与注册是基于 Spring 框架的 Bean 管理机制实现的。这里简单叙述 SpringBoot 应用中的扫描触发流程：</p><blockquote><p>SpringApplication.run() –&gt;<br>SpringApplication.refresh() –&gt;<br>AbstractApplicationContext.refresh() –&gt;<br>AbstractApplicationContext.invokeBeanFactoryPostProcessors() –&gt;<br>AbstractApplicationContext.invokeBeanDefinitionRegistryPostProcessors() –&gt;<br><code>补充知识点： 上面的 invokeBeanFactoryPostProcessors() 能触发invokeBeanDefinitionRegistryPostProcessors() 是因为 Spring 设计中，BeanDeifinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 的继承</code><br>PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors()–&gt;<br>ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()–&gt;<br>ConfigurationClassPostProcessor.processConfigBeanDefinitions()–&gt;<br>ConfigurationClassBeanDefinitionReader.loadBeanDefinitions()–&gt;<br>ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsFromRegistrars –&gt;<br>FeignClientsRegistrar.registerBeanDefinitions()</p></blockquote><p>到这里， 我们进入了 Feign 框架的逻辑 <code>FeignClientsRegistrar.registerBeanDefinitions()</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// registerDefaultConfiguration 方法内部从 SpringBoot 启动类上检查是否有 @EnableFeignClients, </span>    <span class="token comment">// 有该注解的话， 则完成 Feign 框架相关的一些配置内容注册</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerDefaultConfiguration</span><span class="token punctuation">(</span>metadata<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// registerFeignClients 方法内部从 classpath 中， 扫描获得 @FeignClient 修饰的类，将类的内容解析为 BeanDefinition , </span>    <span class="token comment">// 最终通过调用 Spring 框架中的 BeanDefinitionReaderUtils.resgisterBeanDefinition 将解析处理过的 FeignClient BeanDeifinition 添加到 spring 容器中</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerFeignClients</span><span class="token punctuation">(</span>metadata<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里值得进一步关注的是， <code>registerFeignClients</code> 方法内部， 调用了一个 <code>registerFeignClient</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">registerFeignClient</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">,</span>                                 <span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> attributes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> className <span class="token operator">=</span> annotationMetadata<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BeanDefinitionBuilder</span> definition <span class="token operator">=</span> <span class="token class-name">BeanDefinitionBuilder</span><span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">FeignClientFactoryBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>此处省一部分代码    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>此处省一部分代码    <span class="token class-name">BeanDefinitionHolder</span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">(</span>beanDefinition<span class="token punctuation">,</span> className<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> alias <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">BeanDefinitionReaderUtils</span><span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>holder<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BeanDefinitionBuilder</span> <span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> beanClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">BeanDefinitionBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionBuilder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GenericBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span>beanDefinition<span class="token punctuation">.</span><span class="token function">setBeanClass</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> builder<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意！ 该方法的第二行通过调用<code>genericBeanDefinition</code>方法为 FeignClient 生成了一个 BeanDeifinition, 而该方法的入参是 <code>FeignClientFactoryBean.class</code></p><p>查看 <code>genericBeanDefinition</code> 的逻辑， 发现此处将 FeignClient 的 BeanDefinition 的 beanClass 设置成了<code>FeignClientFactoryBean.class</code> ， 也就是说 FeignClient 被注册成了一个工厂 bean(Factory Bean)。</p><p>这里简单说明下， 工厂 Bean 是一种特殊的 Bean, 对于 Bean 的消费者来说， 他逻辑上是感知不到这个 Bean 是普通的 Bean 还是工厂 Bean, 只是按照正常的获取 Bean 方式去调用， 但工厂bean 最后返回的实例不是工厂Bean 本身， 而是执行工厂 Bean 的 getObject 逻辑返回的示例。</p><p>查看一下 <code>FeignClientFactoryBean</code> 的 <code>getObject</code> 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">FeignContext</span> context <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">FeignContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Feign<span class="token punctuation">.</span>Builder</span> builder <span class="token operator">=</span> <span class="token function">feign</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略代码        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token function">loadBalance</span><span class="token punctuation">(</span>builder<span class="token punctuation">,</span> context<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HardCodedTarget</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略代码    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> targeter<span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> builder<span class="token punctuation">,</span> context<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HardCodedTarget</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看上面两个 return 所调用的方法， 最后发现都会统一使用到 <code>Targeter.target()</code> 方法， 该方法最终调用到 <code>Feign.target</code> 方法, 并进一步触发 <code>RefleactiveFeign.newInstance</code> 的执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">target</span><span class="token punctuation">(</span><span class="token class-name">FeignClientFactoryBean</span> factory<span class="token punctuation">,</span> <span class="token class-name">Builder</span> feign<span class="token punctuation">,</span> <span class="token class-name">FeignContext</span> context<span class="token punctuation">,</span> <span class="token class-name">HardCodedTarget</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> feign<span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">target</span><span class="token punctuation">(</span><span class="token class-name">Target</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">Target</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略代码    <span class="token class-name">InvocationHandler</span> handler <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> methodToHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">T</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略代码<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此， 我们找到了对于 Java 原生的动态代理的使用， 整个 feign 的核心工作原理就基本清晰了， 后续就只是 handler 如何把基于 Proxy 方法的调用转换为 HTTP 请求发出以及翻译回来的 HTTP 响应了， 属于按部就班的工作。这个后续待看。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>Spring Cloud OpenFeign 的核心工作原理经上文探究可以非常简单的总结为：</p><ol><li>通过 @EnableFeignCleints 触发 Spring 应用程序对 classpath 中 @FeignClient 修饰类的扫描</li><li>解析到 @FeignClient 修饰类后， Feign 框架通过扩展 Spring Bean Deifinition 的注册逻辑， 最终注册一个 FeignClientFacotoryBean 进入 Spring 容器</li><li>Spring 容器在初始化其他用到 @FeignClient 接口的类时， 获得的是 FeignClientFacotryBean 产生的一个代理对象 Proxy.</li><li>基于 java 原生的动态代理机制， 针对 Proxy 的调用， 都会被统一转发给 Feign 框架所定义的一个 InvocationHandler ， 由该 Handler 完成后续的 HTTP 转换， 发送， 接收， 翻译HTTP响应的工作</li></ol><img src="/2021/05/27/springcloud-zhi-feign/1.png" class title="Feign原理流程图">]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
          <category> feign </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud之hystrix</title>
      <link href="2021/05/27/springcloud-zhi-hystrix/"/>
      <url>2021/05/27/springcloud-zhi-hystrix/</url>
      
        <content type="html"><![CDATA[<h2 id="springcloud之hystrix"><a href="#springcloud之hystrix" class="headerlink" title="springcloud之hystrix"></a>springcloud之hystrix</h2><p>注：这是hystrix的文档翻译</p><h3 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h3><h4 id="1-1什么是Hystrix"><a href="#1-1什么是Hystrix" class="headerlink" title="1.1什么是Hystrix"></a>1.1什么是Hystrix</h4><p>在分布式环境中，不可避免地会遇到所依赖的服务挂掉的情况，Hystrix 可以通过增加 <strong>延迟容忍度</strong> 与 <strong>错误容忍度</strong>，来控制这些分布式系统的交互。Hystrix 在服务与服务之间建立了一个中间层，防止服务之间出现故障，并提供了失败时的 <strong>fallback</strong> 策略，来增加你系统的整体可靠性和弹性。</p><h4 id="1-2Hystrix-做了那些事情"><a href="#1-2Hystrix-做了那些事情" class="headerlink" title="1.2Hystrix 做了那些事情"></a>1.2Hystrix 做了那些事情</h4><p>Hystrix 提供了以下服务</p><ul><li>引入第三方的 client 类库，通过延迟与失败的检测，来保护服务与服务之间的调用（网络间调用最为典型）</li><li>阻止复杂的分布式系统中出现级联故障</li><li>快速失败与快速恢复机制</li><li>提供兜底方案（fallback）并在适当的时机进行服务降级</li><li>提供实时监控、报警与操作控制</li></ul><h4 id="1-3Hystrix-解决了什么问题"><a href="#1-3Hystrix-解决了什么问题" class="headerlink" title="1.3Hystrix 解决了什么问题"></a>1.3Hystrix 解决了什么问题</h4><p>在复杂的分布式架构中，服务之间都是相互依赖的，任何一个节点都不可避免会宕机。如果主节点不能从这些宕机节点中独立出来，那主节点将会面临被这些宕机的节点拖垮的风险。举个例子，如果一个应用依赖了 30 个服务，每个服务保证 99.99% 的时间是正常的，那可以计算出</p><blockquote><p>99.9930 = 99.7% uptime<br>0.3% of 1 billion requests = 3,000,000 failures<br>2+ hours downtime/month even if all dependencies have excellent uptime.</p></blockquote><p>完好情况下，请求流如下：</p><img src="/2021/05/27/springcloud-zhi-hystrix/1.png" class title="分布式架构请求图"><p>当一个依赖的节点坏掉时，将阻塞整个的用户请求：</p><img src="/2021/05/27/springcloud-zhi-hystrix/2.png" class title="微服务节点down掉"><p>流量高峰时，一个单节点的宕机或延迟，会迅速导致所有服务负载达到饱和。应用中任何一个可能通过网络访问其他服务的节点，都有可能成为造成潜在故障的来源。更严重的是，还可能导致服务之间的延迟增加，占用队列、线程等系统资源，从而导致多系统之间的级联故障（雪崩）。</p><img src="/2021/05/27/springcloud-zhi-hystrix/3.png" class title="雪崩"><p>更严重的是，当网络请求是通过第三方的一个黑盒客户端来发起时，实现细节都被隐藏起来了，而且还可能频繁变动，这样发生问题时就很难监控和改动。如果这个第三方还是通过传递依赖的，主应用程序中根本没有显示地写出调用的代码，那就更难了。</p><p>网络连接失败或者有延迟，服务将会产生故障或者响应变慢，最终反应成为一个 bug。</p><p>所有上述表现出来的故障或延迟，都需要一套管理机制，将节点变得相对独立，这样任何一个单节点故障，都至少不会拖垮整个系统的可用性。</p><h4 id="1-4Hystrix-的设计原则是什么"><a href="#1-4Hystrix-的设计原则是什么" class="headerlink" title="1.4Hystrix 的设计原则是什么"></a>1.4Hystrix 的设计原则是什么</h4><p>Hystrix 通过以下设计原则来运作:</p><ul><li>防止单个服务的故障，耗尽整个系统服务的容器（比如tomcat）的线程资源。</li><li>通过快速失败，取代放在队列中等待</li><li>提供在故障时的应急方法（fallback）</li><li>使用隔离技术 (如 bulkhead, swimlane, 和 circuit breaker patterns) 来限制任何一个依赖项的影响面</li><li>提供实时监控、报警等手段</li><li>提供低延迟的配置变更</li><li>防止客户端执行失败，不仅仅是执行网络请求的客户端</li></ul><h4 id="1-5Hystrix-是怎么实现它的设计目标的"><a href="#1-5Hystrix-是怎么实现它的设计目标的" class="headerlink" title="1.5Hystrix 是怎么实现它的设计目标的"></a>1.5Hystrix 是怎么实现它的设计目标的</h4><p>如下：</p><ul><li>将远程请求或简单的方法调用包装成 <code>HystrixCommand</code> 或者 <code>HystrixObservableCommand</code> 对象，启动一个单独的线程来运行。</li><li>你可以为服务调用定义一个超时时间，可以为默认值，或者你自定义设置该属性，使得99.5%的请求时间都在该时间以下。</li><li>为每一个依赖的服务都分配一个线程池，当该线程池满了之后，直接拒绝，这样就防止某一个依赖的服务出问题阻塞了整个系统的其他服务</li><li>记录成功数、失败数、超时数以及拒绝数等指标</li><li>设置一个熔断器，将所有请求在一段时间内打到这个熔断器提供的方法上，触发条件可以是手动的，也可以根据失败率自动调整。</li><li>实时监控配置与属性的变更</li></ul><p>当你启用 Hystrix 封装了原有的远程调用请求后，整个流程图变为下图所示。</p><img src="/2021/05/27/springcloud-zhi-hystrix/4.png" class title="Hystrix封装"><h4 id="1-6Hystrix是怎么工作的"><a href="#1-6Hystrix是怎么工作的" class="headerlink" title="1.6Hystrix是怎么工作的"></a>1.6Hystrix是怎么工作的</h4><p>下图显示通过Hystrix向服务依赖关系发出请求时会发生什么：</p><img src="/2021/05/27/springcloud-zhi-hystrix/1" class title="Hystrix工作流程"><p>具体将从以下几个方面进行描述：</p><h5 id="1-构建一个HystrixCommand或者HystrixObservableCommand-对象。"><a href="#1-构建一个HystrixCommand或者HystrixObservableCommand-对象。" class="headerlink" title="1.构建一个HystrixCommand或者HystrixObservableCommand 对象。"></a>1.构建一个HystrixCommand或者HystrixObservableCommand 对象。</h5><p>第一步是构建一个<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象来表示你对依赖关系的请求。 其中构造函数需要和请求时的参数一致。</p><p>构造<code>HystrixCommand</code>对象，如果依赖关系预期返回单个响应。 可以这样写：</p><pre><code>HystrixCommand command = new HystrixCommand(arg1, arg2);</code></pre><p>同理，可以构建<code>HystrixObservableCommand</code> ：</p><pre><code>HystrixObservableCommand command = new HystrixObservableCommand(arg1, arg2);</code></pre><h5 id="2-执行Command"><a href="#2-执行Command" class="headerlink" title="2.执行Command"></a>2.执行Command</h5><p>通过使用Hystrix命令对象的以下四种方法之一，可以执行该命令有四种方法（前两种方法仅适用于简单的<code>HystrixCommand</code>对象，并不适用于<code>HystrixObservableCommand</code>）：</p><ul><li><p>execute()–阻塞，，然后返回从依赖关系接收到的单个响应（或者在发生错误时抛出异常）</p></li><li><p>queue()–返回一个可以从依赖关系获得单个响应的future 对象</p></li><li><p>observe()–订阅Observable代表依赖关系的响应，并返回一个Observable，该Observable会复制该来源Observable</p></li><li><p>toObservable() –返回一个Observable，当您订阅它时，将执行Hystrix命令并发出其响应</p><p>  K             value   = command.execute();<br>  Future<K>     fValue  = command.queue();<br>  Observable<K> ohValue = command.observe();       //hot observable<br>  Observable<K> ocValue = command.toObservable();  //cold observable</K></K></K></p></li></ul><p>实际上，同步方法 execute() 底层逻辑是调用 queue().get()，然后 queue() 实际上是调用了  toObservable().toBlocking().toFuture()，也就是说所有 HystrixCommand 的逻辑都是走  Observable 实现</p><h5 id="3-是否请求缓存"><a href="#3-是否请求缓存" class="headerlink" title="3.是否请求缓存"></a>3.是否请求缓存</h5><p>如果为该命令启用请求缓存，并且如果缓存中对该请求的响应可用，则此缓存响应将立即以“可观察”的形式返回。</p><h5 id="4-是否开启熔断"><a href="#4-是否开启熔断" class="headerlink" title="4.是否开启熔断"></a>4.是否开启熔断</h5><p>当执行 command 时，Hystrix 会判断熔断是否开启，如果是开启状态则走 (8) 进行 Fallback 降级策略，如果未开启则走 (5) ，继续下一步判断是否可以执行 command。</p><h5 id="5-线程池-队列-信号量是否已经满负载"><a href="#5-线程池-队列-信号量是否已经满负载" class="headerlink" title="5.线程池/队列/信号量是否已经满负载"></a>5.线程池/队列/信号量是否已经满负载</h5><p>如果上述三者已达到阈值，Hystrix 就会直接走 (8) 进行 Fallback 降级策略</p><h5 id="6-HystrixObservableCommand-construct-或者-HystrixCommand-run"><a href="#6-HystrixObservableCommand-construct-或者-HystrixCommand-run" class="headerlink" title="6.HystrixObservableCommand.construct() 或者 HystrixCommand.run()"></a>6.HystrixObservableCommand.construct() 或者 HystrixCommand.run()</h5><p>在这里，Hystrix通过您为此目的编写的方法调用对依赖关系的请求，其中之一是：</p><ul><li><p>HystrixCommand.run（） - 返回单个响应或者引发异常</p></li><li><p>HystrixObservableCommand.construct（） - 返回一个发出响应的Observable或者发送一个onError通知</p></li></ul><p>如果run（）或construct（）方法超出了命令的超时值，则该线程将抛出一个TimeoutException（或者如果命令本身没有在自己的线程中运行，则会产生单独的计时器线程）。 在这种情况下，Hystrix将直接走 (8)获取Fallback，如果该方法不取消/中断，它会丢弃最终返回值run（）或construct（）方法。</p><p>如果该命令没有引发任何异常并返回响应，则Hystrix在执行某些日志记录和度量报告后返回此响应。 在run（）的情况下，Hystrix返回一个Observable，发出单个响应，然后进行一个onCompleted通知; 在construct（）的情况下，Hystrix返回由construct（）返回的相同的Observable。</p><h5 id="7-计算Circuit-的健康"><a href="#7-计算Circuit-的健康" class="headerlink" title="7.计算Circuit 的健康"></a>7.计算Circuit 的健康</h5><p>Hystrix向断路器报告成功，失败，拒绝和超时，该断路器维护了一系列的计算统计数据组。</p><p>它使用这些统计信息来确定电路何时“跳闸”，此时短路任何后续请求直到恢复时间过去，在首次检查某些健康检查之后，它再次关闭电路。</p><h5 id="8-获取Fallback"><a href="#8-获取Fallback" class="headerlink" title="8.获取Fallback"></a>8.获取Fallback</h5><p>当命令执行失败时，Hystrix试图恢复到你的回退：当construct（）或run（）（6）抛出异常时，当命令由于电路断开而短路时（4），当 命令的线程池和队列或信号量处于容量（5.），或者当命令超过其超时长度时。</p><p>编写Fallback ,它不一依赖于任何的网络依赖，从内存中获取获取通过其他的静态逻辑。如果你非要通过网络去获取Fallback,你可能需要些在获取服务的接口的逻辑上写一个HystrixCommand。</p><h5 id="9-返回成功的响应"><a href="#9-返回成功的响应" class="headerlink" title="9.返回成功的响应"></a>9.返回成功的响应</h5><p>如果 Hystrix command成功，如果Hystrix命令成功，它将以Observable的形式返回对呼叫者的响应。 根据在上述步骤2中调用命令的方式，此Observable可能会在返回给您之前进行转换：</p><img src="/2021/05/27/springcloud-zhi-hystrix/2" class title="返回成功响应"><ul><li>execute（） - 以与.queue（）相同的方式获取Future，然后在此Future上调用get（）来获取Observable发出的单个值</li><li>queue（） - 将Observable转换为BlockingObservable，以便将其转换为Future，然后返回此未来</li><li>observe（） - 立即订阅Observable并启动执行命令的流程; 返回一个Observable，当您订阅它时，重播排放和通知</li><li>toObservable（） - 返回Observable不变; 您必须订阅它才能实际开始导致命令执行的流程</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
          <category> hystrix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发</title>
      <link href="2021/05/26/bing-fa/"/>
      <url>2021/05/26/bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><ul><li><p><strong>线程数量和程序执行速度的关系</strong></p><p>并发编程的目的是为了让程序运行得更快，但是并不是启动得线程越多就能让程序最大限度地并发执行。在并发编程时，如果希望通过多线程执行任务让程序运行得更快会面临很多挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题。</p></li><li><p><strong>多线程并发的实现</strong></p><p>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短（一般是几十毫秒），所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。</p></li><li><p><strong>上下文切换的概念</strong></p><p>CPU是通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是在切换前会保存上一个任务的状态，以便下次再切换回这个任务时可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p></li><li><p><strong>减少上下文切换的方法</strong></p><ul><li><p>无锁并发编程：多线程竞争锁时会引起上下文切换，所以多线程处理数据时，可以通过一些方法来避免使用锁，例如将数据的id按照hash算法取模分段，不同的线程处理不同数据段的数据。</p></li><li><p>CAS算法：Java的atomic包使用CAS算法来更新数据而不需要加锁。</p></li><li><p>使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</p></li><li><p>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p></li></ul></li><li><p><strong>多线程避免死锁的方法</strong></p><ul><li>避免一个线程同时获得多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的问题。</li></ul></li></ul><hr><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>JMM的设计是为了屏蔽各种硬件和操作系统的内存方法差异，以实现Java程序在各种平台下都能达到一直的内存访问效果。在此之前的主流程序语言，例如C、C++等直接使用物理硬件和操作系统的内存模型，因此不同平台上内存模型的差异可能导致程序在一套平台上并发正常运行，而在另一套平台经常出错。</p><p>JMM必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但又必须定义得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性来获取更好的执行执行速度。直到JDK5，即实现了JSR-133之后，Java内存模型才算成熟完善了起来。</p><hr><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a><strong>主内存与工作内存</strong></h3><p>Java内存模型的主要目的是<strong>定义程序中各种变量的访问规则</strong>，即关注在<em><strong>虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</strong></em>。<code>此处的变量和Java语言中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数</code>，因为局部变量和方法参数是线程私有的，不会被共享，也就自然不存在竞争问题。为了获得更好的执行效率，Java内存模型1. <strong>没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互</strong>，也2. <strong>没有限制即时编译器是否要进行调整代码执行顺序</strong>这类优化措施。</p><p>Java内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><ul><li><p><strong>内存间的交互操作</strong></p><p>关于主内存与工作内存之间的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型定义了以下8种操作来完成。Java虚拟机实现时必须保证这些操作是原子性的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台有例外）。</p><ul><li><strong>lock（锁定）：</strong>作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li><strong>unlock（解锁）：</strong>作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。</li><li><strong>read（读取）：</strong>作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load操作使用。</li><li><strong>load（载入）：</strong>作用于工作内存的变量，它把read操作从主存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）：</strong>作用于工作内存的变量，它<strong>把工作内存中一个变量的值传递给执行引擎</strong>，每当虚拟机遇到一个需要使用变量的值的字节码执行时会执行这个操作。</li><li><strong>assign（赋值）：</strong>作用于工作内存的变量，它<strong>把一个从执行引擎接收的值赋给工作内存的变量</strong>，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）：</strong>作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li><strong>write（写入）：</strong>作用于主内存的变量，它把store操作从工作内存取到的变量值放入主内存的变量中。</li></ul><blockquote><p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意Java内存模型只要求这两种操作必须按顺序执行，但不要求是连续执行，也就是说read与load之间、store和write之间是可插入其他指令的，如对主内存的变量a、b进行访问时，一种可能的顺序是read a、read b、load b、load a。</p></blockquote><p>除了这8种操作外，Java内存模型还规定了必须满足的一些规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主存读取出来了但工作内存不接受，或者工作内存发起了回写但主内存不接受的情况。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li><strong>不允许一个线程在没有发生过任何assign操作的情况下把数据从线程的工作内存同步回主内存。</strong></li><li>一个新的变量只能在主内存中诞生，但不允许在工作内存中直接使用一个未被初始化（load和assign）的变量，即对一个变量实施use或store操作之前，必须先执行assign和load。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定就不允许对其执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。</li></ul><p>这8种内存访问的操作和这些规则，加上针对volatile的一些特殊规定，就能准确地描述出Java程序中哪些内存访问操作在并发下才是安全的。这种定义十分严谨但是过于复杂，之后Java将内存操作简化为lock、unlock、read和write四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变。</p></li></ul><hr><h3 id="针对volatile的特殊规则"><a href="#针对volatile的特殊规则" class="headerlink" title="针对volatile的特殊规则"></a>针对volatile的特殊规则</h3><ul><li><p><strong>作用：</strong></p><p>关键字volatile是Java虚拟机提供的最轻量级的同步机制，Java内存模型为volatile定义了一些特殊的访问规则。当一个变量被定义为volatile之后，它具备两种特性：</p><ul><li><p><strong>保证此变量对所有线程的可见性</strong></p><p>可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是立即可以得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。</p><p>volatile变量在各个线程的工作内存中不存在一致性问题（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但是由于每次使用前都要刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java中的运算操作符并非原子操作，这导致volatile变量的运算在并发下仍是不安全的。</p><ul><li><p><strong>静态变量i执行多线程i++的不安全问题</strong></p><p>通过反编译会发现一个自增语句是由4条字节码指令构成的，按顺序依次为getstatic、iconst_1、iadd、putstatic，当getstatic把i的值取到操作栈顶时，volatile关键字保证了i的值在此刻是正确的，但是在执行iconst_1、iadd这些指令时，其他线程可能已经改变了i的值，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的i值同步回了主内存之中。 </p></li></ul><p>注意：即使编译出来只有一条字节码指令也不能意味着这条指令就是一个原子操作，一条字节码指令在解释执行时，解释器要运行很多行代码才能实现它的语义。如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令。</p><p>​    由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然需要使用锁（synchronized、juc中的锁或原子类）来保证原子性：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他状态变量共同参与不变约束。</li></ul></li><li><p><strong>禁止指令重排序优化</strong></p></li></ul><blockquote><ol><li><p>什么是指令重排？</p><p>   在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列，一般而言，这个指令序列是会输出确定的结果；以确保每一次的执行都有确定的结果。但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化，在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序，在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。</p></li><li><p>数据依赖性</p><p> 主要指不同的程序指令之间的顺序是不允许进行交互的，即可称这些程序指令之间存在数据依赖性。</p><p> 主要的例子如下：</p><p> 名称     代码示例     说明<br> 写后读     a = 1;b = a;     写一个变量之后，再读这个位置。<br> 写后写     a = 1;a = 2;     写一个变量之后，再写这个变量。<br> 读后写     a = b;b = 1;     读一个变量之后，再写这个变量。</p><p> 经过分析，发现这里每组指令中都有写操作，这个写操作的位置是不允许变化的，否则将带来不一样的执行结果。编译器将不会对存在数据依赖性的程序指令进行重排，这里的依赖性仅仅指单线程情况下的数据依赖性；多线程并发情况下，此规则将失效。</p></li><li><p>控制依赖性</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 1</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>  <span class="token comment">// 2</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 例如指令1和指令2不存在数据依赖性但是存在控制依赖性即指令1控制指令2。如果操作3和操作4交换执行顺序，就会使结果出错。但是控制依赖性又会导致并行度降低。</p><p> 编译器和处理器为了提高并行度，使用<strong>猜测执行</strong>来克制控制依赖性对并发度的影响。以处理器猜测执行为例，该线程的处理器可以提前读取a，并且计算a*a的值，然后把结果放到<strong>重排序缓冲</strong>中。当操作3的条件判断为真，就把结果写入到变量i中。</p><p> <strong>但是在多线程程序中，对存在控制依赖关系的操作重排序，可能会改变程序的执行结果</strong></p></li><li><p>as-if-serial语义</p><p> as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p></li></ol></blockquote><p>​        普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p><p>​        使用volatile的变量进行写操作，汇编指令操作是带有lock前缀的，这个操作的作用相当于一个内存屏障，后面的指令不能重排到内存屏障之前的位置。<strong>只有一个处理器时不需要使用内存屏障</strong>，但如果有两个或更多的处理器访问同一块内存，且其中有一个在观测另一个，就需要使用内存屏障来保证一致性了。</p></li></ul><p>​        使用lock前缀的指令在多核处理器中会引发两件事：</p><ul><li><p>将当前处理器缓存行的数据写回到系统内存</p></li><li><p>这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效。</p><p>这种操作相当于对缓存中的变量做了一次store和write操作，可以让volatile变量的修改对其他处理器立即可见。</p></li><li><p><strong>volatile的内存语义</strong></p><p>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。从内存语义的角度来说，volatile的写-读与锁的释放-获取具有相同的内存效果。</p><ul><li><p><strong>volatile写的内存语义：</strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></li><li><p><strong>volatile读的内存语义：</strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p></li></ul><p>线程A写一个volatile变量，实质上是线程A向接下来要读这个volatile变量的某个线程发出了（其对共享变量所修改的）消息。线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。线程A写一个volatile变量，线程B读一个volatile变量，实质上是线程A通过主内存向线程B发送消息。</p></li><li><p><strong>volatile指令重排序的特点</strong></p><ul><li>当第二个操作是volatile写时，不管第一个操作是什么都不能重排序，这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li></ul></li><li><p>当第一个操作是volatile读时，不管第二个操作是什么都不能重排序，这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p></li><li><p>当第一个操作是volatile写，第二个操作是volatile读时不能重排序。</p></li><li><p><strong>volatile的内存屏障插入策略</strong></p><ul><li><p>在每个volatile写操作之前插入一个Store Store屏障,禁止之前的普通写和之后的volatile写重排序。</p></li><li><p>在每个volatile写操作之后插入一个Store Load屏障，防止之前的volatile写与之后可能有的volatile读/写重排序，也可以在每个volatile变量读之前插入该屏障，考虑到一般是读多于写所以选择用这种方式提升执行效率，也可以看出JMM在实现上的一个特点：首先确保正确性，然后再去追求效率。</p></li><li><p>在每个volatile读操作之后插入一个Load Load屏障，禁止之后的普通读操作和之前的volatile读重排序。</p></li><li><p>在每个volatile读操作之后插入一个Load Store屏障，禁止之后的普通写操作和之前的volatile读重排序。</p></li></ul></li><li><p><strong>关于volatile的优化</strong></p><p>可以通过追加字节的方式优化性能，例如JDK7中的队列集合类LinkedTransferQueue就是使用了追加字节的方式来优化队列出队和入队的性能。由于一些处理器的高速缓存行是64个字节宽，不支持部分填充缓存行，如果队列的头节点和尾节点都不足64字节，当一个处理器试图修改头节点时就会将整个缓存行锁定，那么在缓存一致性的作用下会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队又会频繁修改头节点和尾节点，因此多处理器情况下会严重影响队列的入队和出队效率。追加到64字节后就可以填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使它们的操作不会互相锁定。    </p><p>但以下两种场景不应该使用这种方式：①缓存行非64字节宽的处理器。②共享变量不会被频繁地写，因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定性能消耗。如果共享变量不被频繁写，锁的几率很小没有必要避免互相锁定。不过这种追加字节的方式在Java7可能不生效，因为Java7可以淘汰或重新排列无用字段，需要使用其他追加字节的方式。</p></li><li><p><strong>JSR-133增强volatile语义的原因</strong></p><p>在旧的内存模型中，虽然不允许volatile变量之间重排序，但允许volatile变量与普通变量重排序，可能导致内存不可见问题。在旧的内存模型中volatile的写-读没有锁的释放-获取所具有的内存语义，为了提供一种比锁更轻量级的线程通信机制，严格限制了编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p></li><li><p>关于指令重排序的补充</p><ul><li><p><strong>指令重排序的概念</strong></p><p>重排序指从源代码到指令序列的重排序，在执行程序时为了提高性能，编译器和处理器通常会对指令进行重排序，重排序分为三种类型：</p><ul><li><p>编译器优化的重排序：编译器在不改变单线程程序语义的前提下可以重新安排语句的执行顺序。</p></li><li><p>指令级并行的重排序：现代处理器才以来指令级并行技术ILP来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作操作看上去可能是乱序执行。</p></li></ul></li><li><p><strong>指令重排序的问题</strong></p><p>从Java源代码到最终实际执行的指令序列，会分别经历编译器优化重排序、指令级并行重排序和内存系统重排序，这些重排序可能会导致多线程程序出现内存可见性问题。</p><ul><li>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令（一组用于实现对内存操作顺序限制的处理器指令），通过内存屏障指令来禁止特定类型的处理器重排序。</li></ul><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的可见性内存保证。</p></li></ul></li></ul><hr><h3 id="针对long和double类型变量的特殊规则"><a href="#针对long和double类型变量的特殊规则" class="headerlink" title="针对long和double类型变量的特殊规则"></a>针对long和double类型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write这八种操作都具有原子性，但是对于64位的数据类型（long和double），在模型中定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write四个操作的原子性，这就是”long和double的非原子性协定“。</p><p>如果有多个线程共享一个未声明为volatile的long或double类型变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了”半个变量“的数值。这种情况很罕见，但带对于一些32位的Java虚拟机确实存在非原子性访问的风险。</p><hr><h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><ul><li><p><strong>原子性</strong></p><p>由Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，基本数据类型的访问读写都是具备原子性的（例外就是long和double的非原子性协定）。</p><p>如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足需求，尽管虚拟机还没有把lock和unlock开放给用户使用，但却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块synchronized关键字，因此synchronized具有原子性。</p><ul><li><p><strong>原子操作</strong></p><p>原子操作即不可被中断的一个或一系列操作，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><ul><li><p>通过总线锁定保证原子性：如果多个处理器同时对共享变量进行读改写操作（例如i++），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子性的，操作完之后共享变量的值会和期望的不一样。例如i=1，进行两次i++操作，但是结果可能为2。这是因为多个处理器同时从各自的缓存读取变量i，分别进行加1操作，然后分别写入系统内存中。如果想要保证读改写操作的原子性，就必须保证CPU1读改写共享变量时CPU2不能操作缓存了该共享变量内存地址的缓存。处理器使用总线锁来解决这个问题，总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞，该处理器就可以独占共享内存。（总线锁太消耗资源和影响效率，使用MESI）</p></li><li><p>通过缓存锁定来保证原子性：同一时刻只需要保存对某个内存地址的访问是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间其他处理器不能操作其他内存地址的数据，开销比较大，目前的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。频繁使用的内存会缓存在处理器的高速缓存里，原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁。缓存锁定是指内存区域如果被缓存在处理器的缓存行中并且在Lock操作期间被锁定，那么当它执行锁操作回写内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作原子性，因为缓存一致性会阻止同时修改由两个以上处理器缓存的内存区域，当其他处理器回写已被锁定的缓存行数据时会使缓存行无效。</p></li></ul></li><li><p><strong>Java中的原子操作实现</strong></p><p>Java中可以通过锁和循环CAS的方式来实现原子操作。</p><ul><li><p>锁机制保证了只有获得锁的线程才能操作锁定的内存区域，JVM内部实现了很多锁，除了偏向锁JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步代码块时使用循环CAS方式获取锁，退出时使用循环CAS释放锁。</p></li><li><p>JVM中的CAS操作利用了处理器提供的交换指令CMPXCHG实现，自旋CAS的基本思路就是循环进行CAS操作直到成功为止。从Java1.5开始JDK的并发包里提供了一些类来支持原子操作，例如AtomicBoolean（用原子方式更新的boolean值），AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值），这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p></li></ul></li></ul></li><li><p><strong>可见性</strong></p><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，因此volatile保证了多线程操作时变量的可见性。</p><p>除了volatile之外，Java还有两个关键字能实现可见性，分别是synchronized和final。</p><ul><li><p><strong>synchronized：</strong>同步块的可见性是指”对一个变量执行unlock之前，必须先把此变量同步回主内存中（执行store、write操作）。</p></li><li><p><strong>final：</strong>final的可见性是指被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去（this引用逃逸是一件很危险的事，其他线程有可能通过这个引用访问到初始化了一般的对象），那么在其他线程中就能看见final字段的值。</p><ul><li><p><strong>final域的重排序规则</strong></p><p>对于final域，编译器和处理器要遵守两个重排序规则：①在构造方法内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。②初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 </p></li><li><p><strong>写final域重排序的实现原理</strong></p><p>写final域的重排序规则禁止把final域的写重排序到构造方法之外，这个规则的实现包含以下两方面：①JMM禁止编译器把final域的写重排序到构造方法之外。②编译器会在final域的写之后，构造方法的return之前，插入一个Store Store屏障，这个屏障禁止把final域的写重排序到构造方法之外。</p><p>写final域的重排序可以确保在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p></li><li><p><strong>读final域重排序的实现原理</strong></p><p>读final域的重排序规则是，在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（仅针对处理器）。编译器会在读final域操作的前面插入一个Load Load屏障。</p><p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（例如alpha处理器），因此该规则就是专门针对这种处理器的。</p><p>读final域的重排序规则可以确保在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p></li><li><p><strong>final域为引用对象时重排序的特点</strong></p><p>对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造方法内对一个final引用的对象的成员域的写入，与随后在构造方法外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 </p></li><li><p><strong>final语义在X86处理器的实现原理</strong></p><p>写final域的重排序规则是要求编译器在final域的写之后，构造方法return之前插入一个Store Store屏障，读final域的重排序规则是要求编译器在读final域的操作前插入一个Load Load屏障。</p><p>由于X86处理器不会对写-写操作重排序，所以写final域需要的Store Store屏障会被省略。同样，由于X86处理器不会对存在间接依赖关系的操作做重排序，所以在X86处理器中读final域需要的Load Load屏障也会被省略掉。也就是说，X86处理器不会对final域的读/写插入任何内存屏障。</p></li><li><p><strong>JSR133增强final语义的原因</strong></p><p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如一个线程看到一个int类型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值会发现值变为1（被某个线程初始化之后的值）。最常见的例子就是旧的Java内存模型中String的值可能会改变。</p><p>为了修复该漏洞，JSR-133通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造方法中没有逸出），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造方法中被初始化之后的值。</p></li></ul></li></ul></li><li><p><strong>有序性</strong></p><p>Java内存模型的有序性可以总结为：在本线程内观察所有操作是有序的，在一个线程内观察另一个线程，所有操作都是无序的。前半句是指”线程内的as-if-serial语义“，后半句是指“指令重排序”和”工作内存与主内存同步延迟“现象。</p><p>Java提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一个时刻只允许一条线程对其进行lock操作“这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p></li></ul><hr><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><ul><li><p><strong>数据依赖性</strong></p><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时两个操作之间就存在数据依赖性。数据依赖分为以下三种类型：①写后读，写一个变量之后再读这个位置。②读后写，读一个变了之后再写这个变量。③写后写，写一个变量之后再写这个变量。</p><p>上述三种情况只要重排序两个操作的执行顺序，程序的执行结果就会被改变。编译器和处理器为了性能优化可能会对操作重排序，在重排序时会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序。这里说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p></li><li><p><strong>as- if-serial</strong></p><p>as-if-serial指不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵循该语义。为了遵循该语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但如果操作之间不存在数据依赖关系，这些操作就可能被重排序。</p><p>as-if-serial语义将单线程保护了起来，遵循as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按照程序的顺序执行的。as-if-serial使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><p>as-if-serial实例：例如计算一个圆的面积，A操作给半径赋值，B操作给圆周率赋值，C操作计算圆的面积。由于C依赖于A和B因此不会被重排到A和B的前面，但A和B之间没有数据依赖关系，所以程序的执行顺序可以是ABC或BAC，结果是一样的。</p></li><li><p><strong>控制依赖关系对指令重排序的影响</strong></p><p>当代码中存在控制依赖性时（例如A操作判断某标志位，B操作根据A的结果执行对应逻辑），会影响指令序列执行的并行度。为此编译器和处理会采用猜测执行来克服控制相关性对并行度的影响，可以提前计算出值保存到名为重排序缓冲的硬件缓存中，如果之前的控制条件满足就执行对应操作。</p><p>在单线程程序中，对存在控制依赖的操作重排序并不会改变程序的执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）。但在多线程程序中，对存在控制依赖的操作从排序可能会改变程序的执行结果。</p></li></ul><hr><h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h3><p>如果Java内存模型中所有有序性都依靠volatile和synchronized来完成，许多操作会变得过于繁杂，Java语言中有一个先行发生原则（happens-before），这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，可以通过几条简单规则解决并发环境下两个操作之间可能存在冲突的所有问题。</p><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改内存中共享变量的值、发送了消息、调用了方法等。</p><p>Java内存模型存在一些天然的happens-before关系，这些happens-before关系无需任何同步器协助，可以在编码中直接使用。如果两个操作的关系不在此列，并且无法从这些规则推导出来，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。</p><ul><li><strong>程序次序规则</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。</li><li><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。</li><li><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。</li><li><strong>线程启动规则</strong>：线程对象的start方法先行发生于此线程的每一个动作。</li><li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检测，可以通过join方法是否结束或isAlive方法的返回值等手段检测线程是否已经终止执行。</li><li><strong>线程中断规则</strong>：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interruptted方法检测是否有中断发生。</li><li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于它的finalize方法的开始。</li><li><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以得出操作A先行发生于操作C的结论。</li></ul><p><strong>happens-before的重排序策略：</strong></p><p>JMM将happens-before要求禁止的重排序分为了下面两类：会改变程序执行结果的重排序和不会改变程序执行结果的重排序。JMM对这两种不同性质的重排序采取了不同的策略，对于会改变程序执行结果的重排序JMM要求编译器和处理器必须禁止这种重排序；对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。</p><p>JMM向程序员提供happens-before规则能满足程序员的需求，其规则不但简单易懂而且也向程序员提供了足够强的内存可见性保证（有些内存保证性不一定真实存在，例如不改变执行结果的指令重排序对程序员是透明的）。</p><p>JMM对编译器和处理器的束缚已经尽可能地少，JMM遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。例如编译器分析某个锁只会单线程访问就消除该锁，某个volatile变量只会单线程访问就把它当作普通变量。</p><p><strong>happens-before的具体含义：</strong></p><p>①如果一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。这是JMM对程序员的承诺。</p><p>②两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序执行，如果重排序之后的执行结果与按照happens-before关系的执行结果一致，那么这种重排序是可以允许的。这是JMM对编译器和处理器的约束规则，JMM遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。JMM这么做的原因是程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行的语义不能被改变（即执行结果不能被改变）。因此happens-before关系的本质和as-if-serial一样。</p><p><strong>happens-before和as-if-serial的区别：</strong></p><p>as-if-serial语义保证单线程程序的执行结果不被改变，happens-before保证正确同步的多线程程序的执行结果不被改变。</p><p>as-if-serial语义给编写单线程程序的程序员创造了一种单线程程序是顺序执行的幻觉，happens-before关系给编写正确同步的多线程程序员创造了一种多线程程序是按照happens-before指定顺序执行的幻觉。</p><p>这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行的并行度。</p><hr><h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><ul><li><p><strong>JMM内存屏障分类</strong></p><ul><li>Load Load，确保Load1的数据装载先于Load2及所有后续装载指令的装载。</li><li>Store Store，确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储指令的存储。</li><li>Load Store，确保Load1数据装载先于Store2及所有后续存储指令刷新到内存。</li><li>Store Load，确保Store1数据对其他处理器变得可见（刷新到内存）先于Load2及所有后续装载指令的装载。</li></ul><p>Store Load会使该屏障之间的所有内存访问指令（存储和装载指令）完成之后才执行该屏障之后的内存访问指令。该指令是一个“全能型”屏障，同时具备其他三个屏障的效果，现代的多处理器大多支持该屏障，执行该屏障的开销很昂贵，因为当前处理器通常要把写缓冲区的数据全部刷新到内存中。</p></li><li><p><strong>数据竞争和顺序一致性</strong></p><p>当程序未正确同步时就可能存在数据竞争。JMM规范对数据竞争的定义如下：在一个线程中写一个变量，在另一个线程中读同一个变量，而且写和读没有通过同步来排序。当代码中包含数据竞争时程序的执行往往产生违反直觉的结果，如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p><p>JMM对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。这里的同步是指广义上的同步，包括对常用同步用语（synchronized、volatile和final）的正确使用。</p><ul><li><p><strong>顺序一致性内存模型的特点</strong></p><p>顺序一致性内存模型是一个理想化的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：①一个线程中的所有操作必须按照程序的顺序来执行。②不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序，在顺序一致性的内存模型中，每个操作都必须原子执行并且立即对所有线程可见。</p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。在任意时间点最多只能有一个线程可以连接到内存，当多个线程并发执行时，开关装置能把线程的所有内存读/写操作串行化（即在顺序一致性模型中所有操作之间具有全序关系）</p></li></ul></li><li><p><strong>未同步程序</strong></p><ul><li><p><strong>未同步程序的问题</strong></p><p>未同步程序在顺序一致性模型中虽然整体执行顺序无序但是所有线程都能看到一个一致的整体执行顺序。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><p>JMM中没有这个保证，未同步程序在JMM中不但整体的执行顺序无序，并且所有线程看到的操作执行顺序也可能不一致。比如当前线程把写过的数据缓存到本地内存，在没有刷新到主内存前，这个写操作仅对当前线程可见。从其他线程的角度会认为这个写操作并没有执行，只有当前线程把本地内存中写过的数据刷新回主内存之后这个写操作才对其他线程可见，这种情况下当前线程和其他线程看到的操作执行顺序不一致。</p></li><li><p><strong>未同步程序的执行特性</strong></p><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值要么是之前某个线程写入的值，要么是默认值，JMM保证线程读操作读取到的值不会无中生有。为了实现最小安全性，JVM在堆上分配对象时首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部同步这两个操作）。因此在已清零的内存空间分配对象时，域的默认初始化已经完成了。</p><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型的执行结果一致，因为如果想要保证一致需要禁止大量的处理器和编译器优化，这对程序执行性能会有很大影响。而且未同步程序在顺序一致性模型中执行时整体是无序的，结果无法预知，因此保证未同步执行程序在两个模型的执行结果一致没什么意义。</p></li><li><p><strong>未同步程序在JMM和顺序一致性模型的执行区别</strong></p><ul><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li><li>JMM不保证对64位的long类型和double类型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li></ul></li></ul></li><li><p><strong>总线的工作机制和好处</strong></p><p>在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称为总线事务。总线事务包括读事务和写事务。读事务从内存中传输数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中的一个或多个物理上连续的字，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和IO设备执行内存的读/写。</p><p>总线的工作机制可以把所有处理器对内存的访问以串行化的方式来执行，在任意时间点最多只能有一个处理器访问内存，这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p></li><li><p><strong>处理器内存模型的分类以及JMM对不同处理器的处理</strong></p><ul><li><p><strong>处理器分类</strong></p><ul><li>放松程序中写-读操作的顺序，由此产生了TSO内存模型。</li><li>在TSO的基础上继续放松程序中写-写操作的顺序，由此产生了PSO内存模型。</li><li>在TSO和PSO的基础上，继续放松程序中读-写（以两个操作之间不存在数据依赖性为前提）和读-读操作的顺序，由此产生了RMO和PowerPC内存模型。</li></ul></li><li><p><strong>JMM对不同处理器模型的处理</strong></p><p>不同的处理器模型，性能越好，内存模型的设计越弱，因为处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p></li></ul></li><li><p><strong>Java程序内存可见性保证的分类</strong></p><ul><li><p>单线程程序：单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在一致性模型中的执行结果相同。</p></li><li><p>正确同步的多线程程序：正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在一致性模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p></li><li><p>未同步/未正确同步的多线程程序：JMM为它们提供了最小安全性保证，线程执行读取到的值要么是之前某个线程写入的值，要么是默认值，但不保证该值是正确的。</p></li></ul></li><li><p><strong>JSR-133对旧内存模型的修补</strong></p><ul><li>增强volatile的内存语义，旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</li><li>增强final的内存语义，旧内存模型中多次读取同一个final变量的值可能会不相同，为此JSR-133为final增加了两个重排序规则。在保证final引用不会从构造方法逸出的情况下，final具有了初始化安全性。</li></ul></li></ul><h2 id="Java和线程"><a href="#Java和线程" class="headerlink" title="Java和线程"></a>Java和线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件IO等），又可以独立调度。目前线程是Java中进行处理器资源调度的最基本单位。</p><p>主流的操作系统都提供了线程实现，Java则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经调用过start方法且还未结束的java.lang.Thread类的实例就代表着一个线程。Thread类的所有关键方法都被声明为native，一个native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（也有可能是为了执行效率而使用native方法，通常最高效率的手段都是平台相关的手段）。</p><p>实现线程主要有三种方式：</p><ul><li><p><strong>使用内核线程实现（1:1实现）</strong></p><p>使用内核线程实现的方式也被称为1:1实现，内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为一个内核的分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核。</p><p>程序一般不会直接使用内核线程，而是使用内核线程的另一种高级接口即轻量级进程（Light Weight Process，LWP），轻量级进程就是通常所说的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程，这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。</p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程已经在系统调用中被阻塞了，也不会影响整个进程继续工作。轻量级进程也具有它的局限性：首先由于是基于内核线程实现的，所以各种线程操作，如创建、析构和同步等，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</p></li><li><p><strong>使用用户线程实现（1:N实现）</strong></p><p>使用用户线程实现的方式被称为1:N实现，从广义上说，一个线程只要不是内核线程就可以认为是用户线程（User Thread，UT）的一种，因此从该定义上来说轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用因此效率会受到限制，并不具备通常意义上的用户线程的优点。</p><p>狭义上的用户线程是指完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持更大规模的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1:N的关系称为一对多的线程模型。</p><p>用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核支援，所有的线程操作都需要用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”等问题变得难以解决。因为基于用户线程的实现的程序一般比较复杂，除了有明确的需求外一般的应用程序都不倾向使用用户线程，Java曾经使用过但最终又放弃了它。今年来许多新的以高并发为卖点的编程语言又普遍支持了用户线程，如Golang、Erlang等，使用户线程的使用率有所回升。</p></li><li><p><strong>使用用户线程加轻量级进程混合实现（N:M实现）</strong></p><p>线程除了依赖内核线程实现和用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为N:M实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然消耗低并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程和轻量级进程的数量比是不定的，是N:M的关系。</p><p>许多UNIX系列的操作系统都提供了这种混合的线程模型实现。</p></li></ul><hr><h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>Java线程如何实现并不受Java虚拟机规范的约束 ，这是一个与具体虚拟机相关的问题。Java线程早期在Classic虚拟机（JDK1.2之前）上是基于一种被称为绿色线程的用户线程实现的，但从JDK1.3开始，主流平台上的主流商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现。即采用1:1的线程模型。</p><p>以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己不会去干涉线程调度（可以设置线程优先级供操作系统调度参考），全权交给底层的操作系统处理。所以何时冻结或唤醒线程、该给线程分配多少CPU时间片、该把线程安排给哪个CPU核心去执行等都是由操作系统完成的，也都是由操作系统全权决定的。</p><p>还有一些例外的情况，例如用于JavaME的CLDC虚拟机，它同时支持两种线程模型，默认使用1:N的用户线程实现的线程模型，所有Java线程都映射到一个内核线程上；但它也可以使用另一种特殊的混合模型，Java线程依旧全部映射到一个内核线程上但是当Java线程要执行一个阻塞调用时，CLDC会为该调用单独开一个内核线程并且调度执行其他Java线程，等到那个阻塞调用完成之后再重新调度之前的Java线程继续执行。</p><p>另外一个例子时Solaris平台上的HotSpot虚拟机，由于操作系统的现场特性本来就可以同时支持1:1和N:M的线程模型，因此该平台上的虚拟机也对应提供了两个平台专有的虚拟机参数来明确指定虚拟机使用哪种线程模型。</p><p>操作系统支持怎样的线程模型，在很大程度上会影响上面的Java虚拟机的线程的是怎样映射的，这一点在不同平台上很难达成一致，因此《Java虚拟机规范》中没有限定Java线程实现的线程模型，线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编程和运行过程来说这些差异都是完全透明的。</p><hr><h3 id="Java线程的调度"><a href="#Java线程的调度" class="headerlink" title="Java线程的调度"></a>Java线程的调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，调度方式主要有两种，分别是协同式线程调度和抢占式线程调度。</p><p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完成之后，要主动通知系统切换到另一个线程上去。协同式多线程最大的好处就是实现简单，由于线程要把自己的事情干完之后才会进行线程切换，切换操作对线程自身是可知的，所以一般没有线程同步问题。它的缺点也很明显：线程执行的时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞。</p><p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程切换不由线程本身来决定。例如Java中的yield方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程自身是没有什么办法的。这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。Java使用的线程调度方式就是抢占式调度。</p><p>虽然Java线程调度是系统自动完成的，但我们依旧可以通过setPriority方法为线程设置优先级来为系统提供建议，为某些线程多分配一些时间，其他的一些线程可以少分配一些时间。Java中一共设置了10个级别的线程优先级，在两个线程同时处于可运行状态时优先级高的线程容易被操作系统选择执行。</p><p>不过线程优先级并不是一项稳定的调节手段，因为主流虚拟机上的Java线程是被映射到系统的原生线程上来实现的，所以线程调度最终的决定权还是在操作系统。尽管现代操作系统基本都提供了线程优先级的概念，但是并不见得能和Java线程的优先级一一对应，如Solaris中线程有2147483648种线程优先级，而Windows系统中就只有7种。如果操作系统的线程优先级比Java线程优先级更多，问题还比较容易处理，但如果比Java的优先级少，就不得不出现几个线程优先级对应一个操作系统优先级的情况了，在Windows种设置线程优先级1和2、3和4、6和7、8和9的效果是完全一样的。</p><hr><h3 id="Java线程的通信"><a href="#Java线程的通信" class="headerlink" title="Java线程的通信"></a>Java线程的通信</h3><p>通信是指线程之间以何种机制来交换信息，在命令式编程中线程之间的通信机制有两种，共享内存和消息传递。在共享内存的并发模型里线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里线程之间没有公共状态，线程之间必须通过发送消息来显示通信。</p><p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制，在共享内存的并发模型里同步是显示进行的，程序员必须显示指定某个方法或代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在接受之前，同步是隐式进行的。</p><p>Java并发采用共享内存模型，线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><hr><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul><li><p><strong>NEW：</strong>初始状态，创建后还没有启动的线程处于这种状态，此时还没有调用start()方法。</p></li><li><p><strong>RUNNABLE：</strong>运行状态，Java线程将操作系统中的就绪（Ready）和运行（Running）两种状态统称为运行中，此时线程有可能正在等待操作系统分配CPU时间片，也有可能正在执行。</p></li><li><p><strong>BLOCKED：</strong>阻塞状态，阻塞状态与等待状态的区别是阻塞状态在等待一个排它锁，在程序等待进入同步区域时线程将进入这种状态。</p></li><li><p><strong>WAITING：</strong>等待状态，表示线程进入等待状态，处于该状态的线程不会被分配CPU时间片，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>会导致线程陷入等待状态的方法：</p><ul><li>没有设置timeout参数的wait方法。</li><li>没有设置timeout参数的join方法。</li><li>LockSupport的park方法。</li></ul></li><li><p><strong>TIME_WAITING：</strong>限期等待状态，该状态不同于WAITING，可以在指定时间内自行返回。</p><p>会导致线程陷入限期等待状态的方法：</p><ul><li>设置了timeout参数的wait方法。</li><li>设置了timeout参数的join方法。</li><li>LockSupport的parkNanos方法。</li><li>LockSupport的parkUntil方法。</li></ul></li><li><p><strong>TERMINATED：</strong>终止状态，表示当前线程已经执行完毕。</p></li></ul><hr><h2 id="线程安全与锁"><a href="#线程安全与锁" class="headerlink" title="线程安全与锁"></a>线程安全与锁</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><blockquote><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。</p><p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>不过在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p></blockquote><h4 id="双重检验锁方式实现单例模式"><a href="#双重检验锁方式实现单例模式" class="headerlink" title="双重检验锁方式实现单例模式"></a>双重检验锁方式实现单例模式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//先判断对象有没有实例化过</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p>使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p></blockquote><p><strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p><em>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</em></p><h4 id="源码探析"><a href="#源码探析" class="headerlink" title="源码探析"></a>源码探析</h4><blockquote><ul><li><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p></li></ul><blockquote><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMoniter实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p><p>另外，**<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。**</p></blockquote><ul><li><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</li></ul></blockquote><h4 id="sychronized底层优化"><a href="#sychronized底层优化" class="headerlink" title="sychronized底层优化"></a>sychronized底层优化</h4><p>JDK1.6 对锁的实现引入了大量的<code>优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化</code>等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁</strong>状态，他们会随着竞争的激烈而逐渐升级。注意锁<em>可以升级不可降级</em>，这种策略是为了提高获得锁和释放锁的效率。具体可见:<a href="https://www.cnblogs.com/wuqinglong/p/9945618.html">Java6 及以上版本对 synchronized 的优化</a></p><h4 id="sychronized与ReentrantLock的区别"><a href="#sychronized与ReentrantLock的区别" class="headerlink" title="sychronized与ReentrantLock的区别"></a>sychronized与ReentrantLock的区别</h4><ul><li><h4 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h4></li><li><h4 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4></li><li><h4 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h4><ul><li><strong>等待可中断</strong></li><li><strong>可实现公平锁</strong> </li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong></li></ul></li></ul><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h4 id="Volatile和锁的内存语义"><a href="#Volatile和锁的内存语义" class="headerlink" title="Volatile和锁的内存语义"></a>Volatile和锁的内存语义</h4><blockquote><p>理解了volatile的内存语义，锁的内存语义就会好理解了。</p><pre><code>当线程获取锁时，JMM会把线程对应的本地内存置为无效，然后临界区的代码从主存中读入共享变量到工作内存。当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</code></pre><p>看完上面锁的内存语义，是不是感觉和volatile的内存语义很相像。对比锁和volatile的内存语义：</p><pre><code>锁的获取和volatile的读有相同的内存语义锁的释放和volatile的写有相同的内存语义</code></pre></blockquote><h4 id="前戏：CPU-缓存模型"><a href="#前戏：CPU-缓存模型" class="headerlink" title="前戏：CPU 缓存模型"></a>前戏：CPU 缓存模型</h4><blockquote><p><strong>为什么要弄一个 CPU 高速缓存呢？</strong></p><p>类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 <strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p><p>我们甚至可以把 <strong>内存可以看作外存的高速缓存</strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。</p><p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p></blockquote><h4 id="前戏：-JMM-Java-内存模型"><a href="#前戏：-JMM-Java-内存模型" class="headerlink" title="前戏： JMM(Java 内存模型)"></a>前戏： JMM(Java 内存模型)</h4><blockquote><p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p></blockquote><img src="/2021/05/26/bing-fa/1" class title="线程读取主内存数据"><p>要解决这个问题，就需要把变量声明为**<code>volatile</code>**，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>所以，**<code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**</p><h4 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h4><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h4 id="synchronized-关键字和-volatile-关键字的区别"><a href="#synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="synchronized 关键字和 volatile 关键字的区别"></a>synchronized 关键字和 volatile 关键字的区别</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ol><li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以**<code>volatile </code>性能肯定比<code>synchronized</code>关键字要好<strong>。但是</strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块**。</li><li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li><li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ol><blockquote><ul><li>当对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存</li><li>写操作会导致其他线程中的缓存无效</li><li>其他线程使用缓存时，发现本地工作内存中此变量无效，便从主内存中获取，这样获取到的变量便是最新的值，实现了线程的可见性。</li></ul><p><code>volatile</code>是通过编译器在生成字节码时，在指令序列中添加“<strong>内存屏障</strong>”来禁止指令重排序的。</p><p><code>volatile</code>在字节码层面，就是使用访问标志：<strong>ACC_VOLATILE</strong>来表示，供后续操作此变量时判断访问标志是否为ACC_VOLATILE，来决定是否遵循volatile的语义处理。</p></blockquote><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><blockquote><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p><p>再举个简单的例子：</p><p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p></blockquote><h3 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h3><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外地同步，或者在调用方进行任何其他地协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><p>这个定义要求线程安全的代码都必须具备一个共同特征：代码本身封装了所有必要的正确性保障手段，令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。</p><p>在Java中，按照线程安全的“安全程度”由强到弱，可以把Java中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><ul><li><p><strong>不可变</strong></p><p>在Java中，不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全的保障措施。只要一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。</p><p>在Java中，如果多线程共享的数据是一个基本类型数据，那么只要定义时使用final关键字修饰就可以保证它是不可变的。如果共享的数据是一个对象，需要保证对象自身的行为不会对其状态产生任何影响，才能保证这个对象的不可变性，例如可以将对象中带有状态的变量都声明为final类型，这样在构造器执行结束后它就是不可变的，例如Integer类将自己的成员变量使用fianl修饰保证不可变性。</p><p>不可变类型还有String、常用的枚举类型以及Long、Double等包装器类型、BigInterger和BigDecimal大数据类型，但不包括AtomicInteger和AtomicLong类型。</p></li><li><p><strong>绝对线程安全</strong></p><p>绝对线程安全的定义很严格，大部分Java API中标注自己是线程安全的类都不是绝对线程安全的，例如Vector容器，虽然它的方法都被synchronized修饰，保证了原子性、可见性和有序性、但是并不意味着调用它时就永远不需要同步手段了，例如多线程同时执行对Vector对象的get和remove操作，如果一个线程恰好在错误的时间删除了一个元素，导致get操作中遍历的索引不可用，那么get操作就会抛出索引越界异常。</p></li><li><p><strong>相对线程安全</strong></p><p>相对线程安全就是通常意义上讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用时不需要进行额外地保障措施，但是对于一些特定顺序地连续调用，就可能需要在调用端使用额外地同步手段来保证调用的正确性。</p><p>在Java中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Colletcions的synchronizedCollection()方法包装的集合等。</p></li><li><p><strong>线程兼容</strong></p><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们常说的一个类不是线程安全的通常就是这种情况，Java类库API中大部分的类都是线程兼容的，例如ArrayList和HashMap等。</p></li><li><p><strong>线程对立</strong></p><p>线程对立是指不管调用端是否采取了同步措施都无法在多线程环境中并发使用代码。由于Java语言天生支持多线程特性，线程对立这种排斥多线程的代码很少出现，而且通常都是有害的，应当尽量避免。</p><p>一个线程对立的例子就是Thread类的suspend和resume方法，如果有两个线程同时持有一个线程对象，一个尝试去中断，另一个尝试去恢复，在并发进行的情况下无论调用时是否进行了同步，目标线程都存在死锁风险：假如suspend中断的线程就是即将要执行resume的那个线程，那肯定就会产生死锁。因此这两个方法都已经被废弃了，常见线程对立的操作还有System.setIn()、System.setOut()等方法。</p></li></ul><hr><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li><p><strong>互斥同步</strong></p><p>互斥同步是一种最常见的也是最主要的并发正确性保障手段。同步是指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。互斥是方法，同步是目的。</p><p>在Java中最基本的互斥同步手段就是synchronized关键字，它是一种块结构的同步语法。synchronized关键字经过Javac编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象，如果代码中指定了对象参数，那么就以该对象作为锁定对象，如果没有明确指定，那么根据synchronized修饰的是方法类型（实例方法或类方法）来决定锁对象是实例对象还是类型对应的Class对象。</p><p>根据《Java虚拟机规范》的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经持有了那个对象的锁，那么就把锁的计数器的值增加1，而在执行monitorexit指令时会将锁计数器的值减1。一旦计数器的值为0，锁随即就被释放了。如果获取锁对象失败，那当前线程就应该被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p><p>根据《Java虚拟机规范》对monitorenter和monitorexit的行为描述，可以得出两个关于synchronized的直接推论：</p><ul><li>被synchronized修饰的同步块对一条线程来说是可重入的，这意味同一条线程反复进入同步块也不会出现将自己锁死的情况。</li><li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库的锁那样强制已获得锁的线程释放锁，也无法强制正在等待锁的线程中断等待或超时退出。</li></ul><p>从执行成本的角度看，持有锁是一个重量级的操作。在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免陷入用户态到核心态的转换中，进行这些状态转换需要耗费很多的处理器时间。尤其是对于代码很简单的同步块，例如被synchronized修饰的getter和setter方法，状态转换消耗的时间甚至比用户代码本身执行的时间还要长。因此才说synchronized是Java中的一个重量级操作，不过Java之后也进行了相关的锁优化措施。</p><p>除了synchronized关键字之外，自JDK5起Java类库新提供了juc包，其中的Lock接口成为了另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面上去实现同步。</p><p>重入锁ReentrantLock是Lock接口最常见的一种实现，它与synchronized一样是可重入的，在基本用法上与synchronized也很相似，不过它增加了一些高级功能，主要包括以下三项：</p><ul><li><strong>等待可中断：</strong>是指持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待而处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li><li><strong>公平锁：</strong>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带有布尔值的构造器要求使用公平锁。不过一旦使用了公平锁，将会导致性能急剧下降，明显影响吞吐量。</li><li><strong>锁绑定多个条件：</strong>是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联时就不得不额外添加一个锁，而ReentrantLock无须这样做，可以多次调用newCondition()方法。</li></ul><p>在JDK5时ReentrantLock比synchronized性能有显著优势，而在JDK6中进行锁优化之后，二者的性能基本能够持平。</p><p>当synchronized和ReentrantLock都可以满足要求时可以优先考虑使用synchronized：</p><ul><li>synchronized是Java语法层面的同步，足够清晰也足够简单。</li><li>Lock应该确保在finally中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话可以由Java虚拟机来确保即使出现异常锁也能被正常释放。</li><li>尽管在JDK5时ReentrantLock的性能领先于synchronized，但从长远来看Java虚拟机更容易针对synchronized进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用Lock的话，Java虚拟机很难得知具体哪些锁对象是由特定线程持有的。</li></ul></li><li><p><strong>非阻塞同步</strong></p><p>互斥同步面临的主要问题是进行线程阻塞和唤醒带来的性能开销，因此这种同步也被称为阻塞同步。从解决方式来看，互斥同步属于一种悲观的并发策略，其总是认为只要不去做正确的同步措施那就肯定会出现问题，无论共享的数据是否真的会发生竞争，它都会进行加锁，这会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。</p><p>随着硬件指令集的发展，我们已经有了其他选择：基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进性操作，如果没有其他线程竞争共享数据操作就直接成功了；如果共享数据的确存在竞争，那再进行其他措施，例如不断重试直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步，使用这种措施的代码也被称为无锁编程。</p><p>之所以说乐观并发策略需要“硬件指令集的发展”，是因为我们必须要求操作和冲突检测这两个步骤具备原子性。如果在使用互斥同步来保证原子性就完全失去意义了，因此只能考硬件来实现这件事，硬件保证某些从语义上看起来需要多次操作的行为可以通过一条处理器指令就能完成，这类指令常用的有：测试并设置、获取并增加、交换、比较并交换（CAS）、加载链接/条件存储（LL/SC）。</p><p>其中测试并设置、获取并增加、交换这三条是20世纪就已经存在于大多数指令集中的处理器指令，后面两条是现代处理器新增的，而且这两条指令的目的和功能也是类似的。Java中最终暴露出来的是CAS操作。</p><ul><li><p><strong>CAS</strong></p><p>CAS指令需要有三个操作数，分别是内存位置（在Java中可以理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是不管是否更新了V的值都会返回V的旧值，上述的处理过程是原子操作，执行期间不会被其他线程打断。</p></li></ul><p>在JDK5之后，Java类库中才开始使用CAS操作，该操作由sun.misc.Unsafe类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供。HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件地内联进去了。不过由于Unsafe类设计时就不是给用户程序调用的类（Unsafe的getUnsafe方法限制了只有启动类加载器加载的Class才能访问它），因此在JDK9之前只有Java类库可以使用CAS，譬如juc包里的AtomicInteger类，其中的<code>compareAndSet()</code>和<code>getAndIncrement()</code>等方法都使用了Unsafe类的CAS操作来实现。如果用户程序也有使用CAS操作的需求，要么就采用反射手段突破Unsafe的访问限制，要么只能通过Java类库API来间接使用它。直到JDK9之后，Java类库才在VarHandle类中开放了面向用户程序使用的CAS操作。</p><p>AtomicIntegr的<code>incrementAndGet()</code>方法在一个无限循环中，不断尝试将一个比当前值大1的新值赋值给自己，如果失败了就说明执行CAS操作的时候旧值已经发生了变化，于是再次循环进行下一次操作直到成功为止。</p><p>尽管CAS既简单又高效，但这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，它存在一个逻辑漏洞：如果一个变量V初次读取的时候是A，并且在准备赋值的时候检查到它的值仍为A，这依旧不能说明它的值没有被其他线程更改过，因为这段时间内假设它的值先改为了B又改回了A，那么CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的ABA问题，juc包为了解决这个问题提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值得版本来保证CAS的正确性。不过目前这个类并不常用，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p></li><li><p><strong>无同步方案</strong></p><p>要保证线程安全，也并非一定要进行阻塞同步或非阻塞同步，同步与线程安全没有必然联系。同步只是保障存在共享数据竞争时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此有一些代码天生就是线程安全的。</p><ul><li><p><strong>可重入代码：</strong>这种代码又称纯代码，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里，可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，可重入性是更为基础的特性，它可以保证代码线程安全，即所有可重入的代码都是线程安全的，但并非所有线程安全的代码都是可重入的。</p><p>可重入代码有一些共同特征，例如不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入，不调用非可重入方法等。如果一个方法的返回结果是可预测的，只要输入了相同的数据就都能返回同样的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p></li><li><p><strong>线程本地存储：</strong>如果一段代码中所需要的数据必须与其他代码共享，那就判断这些共享数据的代码能否保证在同一线程中执行，如果可以就把共享数据的可见性限制在一个同一线程之内，这样无须同步也能保证线程之间不出现数据竞争的问题。</p><p>符合这种特定的应用并不少见，大部分使用消费队列的架构模式（如生产者-消费者模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是Web交互模型中的“一个请求对应一个服务器线程”的处理方式，这种处理方式的广泛使用使很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>在Java中可以使用ThreadLocal类来实现线程本地存储的功能，每个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以<code>ThreadLocal.threadLocalHashCode</code>为键，本地线程变量为值的K-V键值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的<code>threadLocalHashCode</code>值，使用这个值就可以在线程K-V键值对中找到对应的本地线程变量。</p></li></ul></li></ul><hr><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li><p><strong>锁的内存语义和实现</strong></p><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p><p>锁的释放与volatile写具有相同的内存语义，锁获取与volatile读具有相同的内存语义。线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。线程A释放这个锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p><p>公平锁和非公平锁释放时，最后都要写一个volatile变量state。公平锁获取锁时，首先会去读volatile变量，非公平锁获取锁时，首先会用CAS更新volatile变量的值，这个操作同时具有volatile读和volatile写的内存语义。因此锁的释放-获取内存语义的实现方式为：①利用volatile变量的写-读具有的内存语义。②利用CAS所附带的volatile读和volatile写的内存语义。</p></li></ul><p>高效并发是从JDK5升级到JDK6后的一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量资源去实现各种锁优化技术，如适应性自旋、锁消除、锁膨胀、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序地执行效率。</p><ul><li><p><strong>自旋锁与自适应自旋</strong></p><p>互斥同步对性能最大地影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。同时虚拟机开发团队也注意到了在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂机和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多核心处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>自旋锁在JDK1.4.2中就已经引入，只不过默认是关闭的，可以使用<code>-XX:+UseSpinning</code>参数来开启，在JDK6中就已经改为默认开启了。自旋等待不能代替阻塞，不说对处理器数量的要求，自选等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自选等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认次数是十次，用户可以使用<code>-XX:PreBlockSpin</code>来指定。</p><p>不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。在JDK6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能之间省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长以及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准。</p></li><li><p><strong>锁消除</strong></p><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上的数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p></li><li><p><strong>锁粗化</strong></p><p>原则上我们在编写代码时，总是推荐将同步块的作用范围限制得尽量小，只在共享数据得实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁得线程也能尽可能快拿到锁。</p><p>大多数情况下这种原则是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，那么即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能消耗。</p><p>如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p></li><li><p><strong>轻量级锁</strong></p><p>轻量级锁是JDK6时加入的新型锁机制，它名字中的“轻量级”是相对于操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。不过需要强调的是，轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>要理解轻量级锁以及偏向锁的原理和运作过程，就必须要对HotSpot虚拟机对象的内存布局（尤其是对象头部分）有所了解。HotSpot虚拟机的对象头分为两部分，第一部分是用于存储对象自身的运行时数据的，如哈希码、GC分代年龄等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称为”Mark Word“。这部分是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象数据类型的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。</p><p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间。对象除了未被锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记、可偏向等几种不同的状态。</p><ul><li><p><strong>轻量级锁的工作过程</strong></p><p>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为01状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝。</p><p>然后虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向锁记录的指针，如果这个更新操作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位将转变为”00“，表示此对象处于轻量级锁定状态。</p><p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程以及拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态变为”10”，此时Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也必须进入阻塞状态。</p></li><li><p><strong>轻量级锁的解锁过程</strong></p><p>它的解锁操作也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程复制的Mark Word替换回来。假如能够替换成功，那整个同步过程就顺利完成了，如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时唤醒被挂起的线程。</p></li></ul><p>轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的“这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销，但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p></li><li><p><strong>偏向锁</strong></p><p>偏向锁也是JDK6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都去掉，连CAS操作都不去做了。</p><p>偏向锁的意思就是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>假设当前虚拟机启用了偏向锁（启用参数<code>-XX:UseBiasedLocking</code>，这是自JDK6起HotSpot虚拟机的默认值），那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为”01“，把偏向模式设置为”1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</p><p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式马上就宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁那样去执行。</p><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的，有时使用参数<code>-XX:UseBiasedLocking</code>来禁止偏向锁优化反而能提升性能。</p></li><li><p><strong>锁优化问题总结</strong></p><ul><li><p><strong>锁优化</strong></p><p>JDK1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，在JDK1.6中，锁一共有4个状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，如果偏向锁升级成轻量级锁后就不能降级成偏向锁，这种只能升级不能降级的锁策略是为了提高获得锁和释放锁的效率。</p></li><li><p><strong>偏向锁的获得原理</strong></p><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步代码块并获取锁时，会在对象头和帧栈中的锁记录里存储锁偏向的线程ID，以后该线程再进入和退出同步代码块不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头（synchronized用的锁存在Java的对象头里）的Mark Word里是否存储着指向当前线程的偏向锁。</p><p>如果测试成功表示线程已经获得了锁，如果测试失败则需要再测试一下Mark Word（主要存储锁状态、对象的hashCode、对象的分代年龄、是否是偏向锁、锁标志位）中偏向锁的标识是否设置成了1（表示当前是偏向锁），如果设置了就尝试使用CAS将对象头的偏向锁指向当前线程，否则使用CAS竞争锁。 </p></li><li><p><strong>偏向锁的撤销原理</strong></p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（该时间点上没有正在执行的字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态则将对象头设为无锁状态；如果线程还活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 </p></li><li><p><strong>偏向锁的打开和关闭</strong></p><p>偏向锁在Java6和Java7中默认是开启的，但是它在应用程序启动几秒后才激活，如果有必要可以使用JVM参数来关闭延迟：-XX：BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况处于竞争状态，可以通过JVM参数来关闭偏向锁：-XX：UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p></li><li><p><strong>轻量级锁的加锁原理</strong></p><p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果成功那么当前线程获得锁，如果失败表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 </p></li><li><p><strong>轻量级锁的解锁原理</strong></p><p>轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功则表示没有竞争发生。如果失败则表示当前存在锁竞争，锁就会膨胀为重量级锁。</p><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞了），一旦锁升级为重量级锁，就不会再恢复到轻量级锁的状态。在这种情况下，其他线程视图获取锁时都会被阻塞，当持有锁的线程释放锁后才会唤醒这些线程，被唤醒的线程就会对锁资源进行新一轮的争夺。</p></li><li><p><strong>偏向锁、轻量级锁和重量级锁的区别</strong></p><p>①偏向锁的优点是加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距，缺点是如果线程间存在锁竞争会带来额外锁撤销的消耗，适用于只有一个线程访问同步代码块的场景。</p><p>②轻量级锁的优点是竞争的线程不会阻塞，提高了程序的响应速度，缺点是如果线程始终得不到锁会自旋消耗CPU，适用于追求响应时间和同步代码块执行非常快的场景。</p><p>③重量级锁的优点是线程竞争不使用自旋不会消耗CPU，缺点是线程会被阻塞，响应时间很慢，适应于追求吞吐量，同步代码块执行较慢的场景。</p></li></ul></li></ul><hr><h3 id="AQS相关问题"><a href="#AQS相关问题" class="headerlink" title="AQS相关问题"></a>AQS相关问题</h3><ul><li><p><strong>概念</strong></p><p>AQS是抽象队列同步器Abstract Queued Synchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者期望它成为实现大部分同步需求的基础。</p></li><li><p><strong>AQS的主要实现方式</strong></p><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState、setState和compareAndSetState）来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型地同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLacth等）。</p></li><li><p><strong>基于AQS实现的同步器有什么共同点</strong></p><p>①至少有一个acquire操作，这个操作阻塞调用线程，直到AQS的状态允许这个线程继续执行。FutureTask中的acquire操作为get方法调用。②至少有一个release操作，这个操作改变AQS的状态，改变后的状态可允许一个多多个阻塞线程解除阻塞。FutureTask中的release操作包括run方法和cancel方法。</p></li><li><p><strong>同步器和锁的联系</strong></p><p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面对的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所关注的领域。</p></li><li><p><strong>AQS的实现包括哪些方面</strong></p><p>队列同步器的从实现角度分为多方面，主要包括同步队列、独占式同步状态的获取与释放、共享式同步状态的获取与释放，以及超时获取同步状态等同步器的核心数据与模板方法。</p></li><li><p><strong>同步队列的原理</strong></p><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等构造成一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p></li><li><p><strong>同步队列的节点保存哪些信息</strong></p><p>同步队列中的节点用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。</p></li><li><p><strong>同步队列节点的等待状态有哪些类型</strong></p><p>①CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断需要从同步队列中取消等待，节点进入该状态将不会变化。②SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行。③CONDITION，值为-2，节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal方法后该节点将会从等待队列转移到同步队列中，加入到对同步状态的获取中。④PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件地被传播下去。⑤INITIAL，值为0，初始状态。</p></li><li><p><strong>独占式同步状态的获取和释放流程</strong></p><p>在获取同步状态时，同步器调用acquire方法，维护一个同步队列，使用tryAcquire方法安全地获取线程同步状态，获取状态失败的线程会构造同步节点并通过addWaiter方法被加入到同步队列的尾部，并在队列中进行自旋。之后会调用acquireQueued方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞节点被中断实现，移出队列或停止自旋的条件是前驱节点是头结点并且成功获取了同步状态。</p><p>在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后调用unparkSuccessor方法（该方法使用LockSupport唤醒处于等待状态的线程）唤醒头节点的后继节点，进而使后继节点重新尝试获取同步状态。</p></li><li><p><strong>为什么只有当前驱节点是头节点时才能够尝试获取同步状态</strong></p><p>头节点是成功获取到同步状态的节点，而头节点的线程释放同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</p><p>维护同步队列的FIFO原则，节点和节点在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节点，这样就使得节点的释放规则符合FIFO，并且也便于对过早通知的处理（过早通知是指前驱节点不是头结点的线程由于中断而被唤醒）。</p></li><li><p><strong>共享式同步状态的获取和释放流程</strong></p><p>在获取同步状态时，同步器调用acquireShared方法，该方法调用tryAcquireShared方法尝试获取同步状态，返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此在共享式获取锁的自旋过程中，成功获取到同步状态并退出自旋的条件就是该方法的返回值大于等于0。</p><p>释放同步状态时，调用releaseShared方法，释放同步状态之后将会唤醒后续处于等待状态的节点。对于能够支持多线程同时访问的并发组件，它和独占式的主要区别在于tryReleaseShared方法必须确保同步状态（或资源数）线程安全释放，一般通过循环和CAS来保证，因为释放同步状态的操作会同时来自多个线程。</p></li><li><p><strong>独占式超时获取同步状态的流程</strong></p><p>通过调用同步器的doAcquireNanos方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则返回false。该方法提供了传统Java同步操作（例如synchronized关键字）所不具备的特性。</p></li><li><p><strong>响应中断的同步状态获取过程</strong></p><p>在JDK1.5之前当一个线程获取不到锁而被阻塞到synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧阻塞在synchronized上等待着获取锁。在JDK1.5中，同步器提供了acquireInterruptibly方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立即返回并抛出InterruptedException。</p></li><li><p><strong>独占式超时获取同步状态的原理</strong></p><p>超时获取同步状态的过程可以被视为响应中断获取同步状态过程的“增强版”，doAcquireNanos方法在支持响应中断的基础上增加了超时获取的特性，针对超时获取，主要需要计算出需要睡眠的时间间隔nanosTimeout，为了防止过早通知，nanosTimeout的计算公式为nanosTimeout-=now-lastTime，其中now为当前唤醒时间，lastTime为上次唤醒时间，如果nanosTimeout大于0则表示超时时间未到，需要继续睡眠nanosTimeout纳秒，否则表示已经超时。</p></li><li><p><strong>独占式超时获取同步状态和独占式获取同步状态的区别</strong></p><p>在独占式超时获取同步状态的过程的doAcquireNanos中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。</p><p>如果当前线程获取同步状态失败，独占式超时获取同步状态中会判断是否超时，如果没有超时就重新计算超时间隔，然后使当前线程等待该间隔时间，如果在该时间内没有获取到同步状态就会从等待逻辑中自动返回。而独占式获取同步状态的过程中如果没有获取到同步状态就会使当前线程一直处于等待状态。</p></li><li><p><strong>超时时间过小时对超时等待的影响</strong></p><p>nanosTimeout过小时（小于等于1000纳秒），将不会使线程进行超时等待，而是进入快速自旋过程。因为非常短的超市等待无法做到精确，如果这时再进行超时等待相反会让nanosTimeout的超时从整体上表现得反而不精确，因此在超市非常短的情况下同步器会进入无条件的快速自旋。</p></li></ul><hr><h3 id="Lock相关问题"><a href="#Lock相关问题" class="headerlink" title="Lock相关问题"></a>Lock相关问题</h3><ul><li><p><strong>可重入锁</strong></p><p>重入锁就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁，除此之外该锁还支持获取锁的公平和非公平性选择。synchronized关键字隐式地支持重进入，ReentrantLock虽然不能像synchronized关键字一样支持隐式的重进入，但是在调用lock方法时已经获取到锁的线程能够再次调用lock方法获取锁而不被阻塞。</p></li><li><p><strong>锁的公平性</strong></p><p>如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反正就是不公平的。公平的获取锁也就是等待时间最长的线程优先获取锁，也可以说锁的获取是顺序的，ReentrantLock的构造方法中可以通过设置参数控制锁的公平性。</p><p>公平锁机制往往没有非公平锁的效率高，非公平锁地吞吐量更大，但是公平锁能够减少饥饿发生的概率，保证了锁地获取按照FIFO顺序，等待越久的请求越是能优先得到满足。</p></li><li><p><strong>重进入</strong></p><p>重进入指的是任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决两个问题：①线程再次获取锁，锁需要去识别获取锁的线程是否为当前占有锁的线程，如果是则再次获取成功。②锁的最终释放，线程重复n次获取了锁，随后在第n次释放该锁后，其他现场能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而被锁释放时，技术自减，当计数为0时表示锁已经成功释放。</p></li><li><p><strong>ReentrantLock的可重入的实现</strong></p><p>以非公平锁为例，通过nonfairTryAcquire方法获取锁，该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求则将同步状态值进行增加并返回true，表示获取同步状态成功。</p><p>成功获取锁的线程再次获取锁，只是增加了同步状态值，这就要求ReentrantLock在释放同步状态时减少同步状态值。如果该锁被获取了n次，那么前（n-1）次tryRelease方法必须都返回fasle，只有同步状态完全释放了才能返回true，可以看到该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p><p>对于非公平锁只要CAS设置同步状态成功则表示当前线程获取了锁，而公平锁则不同。公平锁使用tryAcquire方法，该方法与nonfairTryAcquire的唯一区别就是判断条件中多了对同步队列中当前节点是否有前驱节点的判断，如果该方法返回true表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。 </p></li><li><p><strong>读写锁</strong></p><p>像Mutex和ReentrantLock都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读写锁使得并发性相比一般的排他锁有了很大提升。</p></li><li><p><strong>读写锁的特点</strong></p><p>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。只需要在读操作时获取读锁，写操作时获取写锁即可，当写锁被获取时后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后所有操作继续执行，编程方式相对于使用等待/通知机制的实现方式而言变得简单明了。</p></li><li><p><strong>读写锁ReentrantReadWriteLock的特性</strong></p><ul><li>公平性选择：支持非公平（默认）和公平的锁获取方式吞吐量还是非公平性优于公平。</li><li>重进入：该锁支持重进入，以读写线程为例：读线程在获取了读锁之后能够再次获得读锁。而写线程在获取了写锁之后能再次获得写锁，同时也可以获取读锁。</li><li>锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁。</li></ul></li><li><p><strong>读写锁的状态的设计</strong></p><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整形变量）上维护多个读线程和一个写线程的状态。如果在一个int型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p><p>假设同步状态值为S，写状态等于S&amp;0x0000FFFF（将高17位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号右移16位），当写状态增加1时，等于S+1，当读状态增加1时，等于S+（1&lt;&lt;16）。根据状态的划分能得出一个推论：S不等于0时，当写状态等于0时，则读状态大于0，即读锁已被获取。</p></li><li><p><strong>写锁的获取和释放过程</strong></p><p>写锁是一个支持重进入的排他锁，如果当前线程已经获得了写锁则增加写状态，如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获得写锁的线程则当前线程进入等待状态。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p></li><li><p><strong>为什么存在读锁时写锁会阻塞</strong></p><p>读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取则其他读写线程的后续访问均被阻塞。</p></li><li><p><strong>读锁的获取和释放过程</strong></p><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写线程为0）时，读锁总会被成功地获取，而所做的只是线程安全地增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取则进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p><p>读锁的每次释放均会减少读状态，减少的值是（1&lt;&lt;16），读锁的每次释放是线程安全的，可能有多个读线程同时释放读锁。</p></li><li><p><strong>JDK1.6对读锁的改动</strong></p><p>获取读锁的实现从JDK1.5到JDK1.6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。</p></li><li><p><strong>锁降级</strong></p><p>锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级指的是把持住（当前拥有的）写锁，再获取到读锁，随后释放先前拥有的写锁的过程。</p></li><li><p><strong>锁降级中读锁的获取是否有必要</strong></p><p>是必要的，主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程A获取了写锁修改了数据，那么当前线程是无法感知线程A的数据更新的。如果当前线程获取读锁，即遵循锁降级的步骤，线程A将会被阻塞，直到当前线程使用数据并释放读锁之后，线程A才能获取写锁并进行数据更新。</p></li></ul><hr><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><ul><li><p><strong>Condition的作用</strong></p><p>Condition接口提供了类似Object监视器方法，与Lock配合可以实现等待/通知模式。Condition对象是由Lock对象创建出来的，因此Condition是依赖Lock对象的。一般会将Condition对象作为成员变量，当调用await方法后当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal方法，通知当前线程后，当前线程才从await方法返回并且在返回前已经获取了锁。</p></li><li><p><strong>Condition的实现</strong></p><p>ConditionObject是同步器AQS的内部类，因为Condition的操作需要获取相关的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个等待队列，该等待队列是Condition对象实现等待/通知功能的关键。Condition的实现主要包括了等待队列、等待和通知。</p></li><li><p><strong>等待队列的原理</strong></p><p>等待队列是一个FIFO队列，在队列中的每个节点都包含了一个线程引用，该线程就是在ConditionObject对象上等待的线程，如果一个线程调用了await方法，那么该线程会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步其中节点的定义，也就是说同步队列和等待队列中的节点类型都是同步器的静态内部类Node。</p><p>一个ConditionObject包含一个等待队列，ConditionObject拥有首节点和尾节点。Object拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。节点引用更新的过程并没有用CAS保证，因为调用await方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p></li><li><p><strong>await方法的原理</strong></p><p>如果从队列的角度看await方法，当调用await方法时相当于同步队列的首节点（获取了锁的节点）移动到Condition对象的等待队列中，首节点不会直接加入等待队列，而是通过addConditionWaiter方法把当前线程构造成一个新的节点并将其加入等待队列中。加入等待队列后，释放同步状态，唤醒同步队列中的后继节点然后进入等待状态。如果不是通过其他线程调用signal方法唤醒而是对await线程进行中断，会抛出InterruptedException。</p></li><li><p><strong>signal方法的原理</strong></p><p>该方法会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。调用该方法的前置条件是当前线程必须获取了锁，signal方法进行了检查，判断当前线程是否是获取了锁的线程，接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。被唤醒后的线程将从await方法中的while循环退出，进而调用同步器的acquireQueued方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）后，被唤醒的线程将从先前调用的await方法返回，此时该线程已成功获取了锁。signalAll方法相当于对等待队列中的每个节点执行一次signal方法，效果就是将等待队列中的节点全部移到到同步队列中并唤醒每个节点的线程。</p></li><li><p><strong>阻塞队列</strong></p><p>阻塞队列是一个支持两个附加操作的队列，这两个附加的操作支持阻塞的插入和移除方法。当队列满时，队列会阻塞插入元素的线程，直到队列不满。当队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者向队列里添加元素，消费者从队列中获取元素，阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p><ul><li><p><strong>Java中的阻塞队列</strong></p><ul><li><p>ArrayBlockingQueue，一个由数组结构组成的有界阻塞队列，按照FIFO的原则对元素排序，默认情况下不保证线程公平地访问队列，有可能先阻塞地线程最后才访问队列。</p></li><li><p>LinkedBlockingQueue，一个由链表结构组成的有界阻塞队列，队列的默认和最大长度为Integer的最大值，按照FIFO原则排序。</p></li><li><p>PriorityBlockingQueue，一个支持优先级排序的无界阻塞队列，默认情况下元素按照顺序升序排序。也可以自定义compareTo方法指定元素排序规则，或者初始化时指定构造方法的参数Comparator对元素排序，不能保证同优先级元素的顺序。</p></li><li><p>DelayQueue，一个支持延时获取元素的无界阻塞队列，使用优先级队列实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有延时期满时才能从队列中获取元素。适用于以下场景：①缓存系统的设计，一旦能从延迟队列获取元素说明缓存有效期到了。②定时任务调度，保存当天将要执行的任务和执行时间，一旦获取到任务就立刻开始执行。</p></li><li><p>SynchronousQueue，一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素。默认使用非公平策略，也支持公平策略，适用于传递性场景，吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。</p></li><li><p>LinkedTransferQueue，一个由链表结构组成的无界阻塞队列，相对于其他阻塞队列多了tryTransfer和transfer方法。transfe方法：如果当前有消费者正在等待接收元素，transfer方法可以把生产者传入的元素立刻传输给消费者，如果没有，会将元素放在队列的尾节点等到该元素被消费者消费了才返回。tryTransfer方法：用来试探生产者传入的元素能否直接传给消费者，如果没有消费者等待接收元素返回false，和transfer的区别时无论消费者是否接受都会立即返回，transfer是等到消费者消费了才返回。</p></li><li><p>LinkedBlockingDeque，一个由链表结构组成的双向阻塞队列，可以从队列的两端插入和移除元素，多了一个操作队列的入口，在多线程同时入队时就少了一半竞争。</p></li></ul></li><li><p><strong>阻塞队列的实现原理</strong></p><p>使用通知模式实现，所谓通知模式就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。JDK中使用了Condition条件对象来实现。当往队列里插入一个元素，如果队列不可用，那么阻塞生产者主要通过LockSupport.park(this)实现。</p></li></ul></li></ul><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h3><ol><li>什么是Fork/Join</li></ol><img src="/2021/05/26/bing-fa/1.png" class title="Fork&#x2F;Join"><ol start="2"><li>Fork/Join的运行流程</li></ol><img src="/2021/05/26/bing-fa/2.png" class title="Fork&#x2F;Join的运行流程图"><img src="/2021/05/26/bing-fa/3.png" class title="伪代码"><ol start="3"><li>工作窃取算法</li></ol><p>工作窃取算法指的是在多线程执行不同任务队列的过程，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。</p><p>工作窃取流程如下图所示：</p><img src="/2021/05/26/bing-fa/4.png" class title="工作窃取流程"><p>值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间竞争，我们通常使用<strong>双端队列</strong>来存储任务。被窃取的任务线程都从双端队列的头部拿任务执行，而窃取其他任务的线程从双端队列的尾部执行任务。</p><p>另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入阻塞状态以等待再次工作。</p><ol start="4"><li>Fork/Join的具体实现</li></ol><p>前面我们说Fork/Join框架简单来讲就是对任务的分割与子任务的合并，所以要实现这个框架，先要有任务。在Fork/Join框架里提供了抽象类ForkJoinTask来实现任务。</p><p>ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量的多。</p><p><strong>fork()方法：</strong>使用线程池中的空闲线程异步提交任务</p><img src="/2021/05/26/bing-fa/5.png" class title="fork()方法"><p>其实fork()只做了一件事，那就是把任务推入当前工作线程的工作队列里。</p><p><strong>join()方法：</strong>等待处理任务的线程处理完毕，获取返回值。</p><img src="/2021/05/26/bing-fa/6.png" class title="join()方法"><img src="/2021/05/26/bing-fa/7.png" class title="doJoin()方法"><blockquote><p>Thread.join()会使线程阻塞，而ForkJoinPool.join()会使线程免于阻塞，下面是ForkJoinPool.join()的流程图</p></blockquote><img src="/2021/05/26/bing-fa/8.png" alt="image-20210330220126169" style="zoom:125%;"><p>4.1. RecursiveAction和 RecursiveTask</p><p>通常情况下，在创建任务时我们一般不直接继承ForkJoinTask，而是继承它的继承类RecursiveAction和RecursiveTask。</p><blockquote><p>RecursiveAcion:无返回值</p><p>RecursiveTask:有返回值</p></blockquote><p>两个子类都有执行主要计算的方法Compute()</p><p>4.2. ForkJoinPool</p><p>ForkJoinPool是用于ForkJoinTask任务执行的线程池。ForkJoinPool管理着执行池中的线程和任务队列，此外，执行池是否还接受任务，显示线程的运行状态也是在这里处理。</p><img src="/2021/05/26/bing-fa/9.png" class title="ForkJoinPool"><p>4.3. WorkQueue</p><p>双端队列，ForkJoinTask存放在这里。</p><p>ForkJoinPool与传统线程池最显著的区别就是它维护了一个工作队列数组（volatile WorkQueue[] workQueues，ForkJoinPool中每个工作线程都维护着一个工作队列）。</p><p>4.4. runState</p><p>ForkJoinPool的运行状态。SHUTDOWN状态用负数表示，其他的用2次幂表示。</p><hr><h3 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h3><ul><li><p><strong>CountDownLatch</strong></p><p>允许一个或多个线程等待其他线程完成操作，构造方法接收一个int类型的参数作为计数器，如果要等待n个点就传入n。每次调用countDown方法时n就会减1，await方法会阻塞当前线程直到n变为0，由于countDown方法可用在任何地方，所以n个点既可以是n个线程也可以是1个线程里的n个执行步骤。用在多线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p></li><li><p><strong>CyclicBarrier</strong></p><p>CyclicBarrier是同步屏障，它的作用是让一组线程到达一个屏障（或同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被拦截的线程才会继续运行。构造方法中的参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier自己已到达屏障，然后当前线程被阻塞。还支持在构造方法中传入一个Runable类型的任务，当线程到达屏障时会优先执行该任务。适用于多线程计算数据，最后合并计算结果的应用场景。</p><ul><li><p><strong>CountDownLacth和CyclicBarrier的区别</strong></p><p>CountDownLacth的计数器只能用一次，而CyclicBarrier的计数器可使用reset方法重置，所以CyclicBarrier能处理更为复杂的业务场景，例如计算错误时可用重置计数器重新计算。CyclicBarrier还提供了其他有用的方法，例如getNumberWaiting可以获取CyclicBarrier阻塞的线程数量，isBroken方法用来了解阻塞的线程是否被中断。</p></li></ul></li><li><p><strong>Semaphore</strong></p><p>Semaphore是信号量，用来控制同时访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。信号量可以用于流量控制，特别是公共资源有限的应用场景，比如数据库连接。Semaphore的构造方法参数接收一个int型数字，表示可用的许可证数量，即最大并发数。使用acquire获得一个许可证，使用release方法归还许可证，还可以用tryAcquire尝试获得许可证。</p></li><li><p><strong>Exchanger</strong></p><p>Exchanger交换者是用于线程间协作的工具类，用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时这两个线程就可以交换数据，将本线程生产出的数据传递给对方。应用场景包括遗传算法、校对工作等。</p></li></ul><hr><h2 id="线程池和Executor框架"><a href="#线程池和Executor框架" class="headerlink" title="线程池和Executor框架"></a>线程池和Executor框架</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p><strong>线程池的好处</strong></p><ul><li>降低资源消耗，通过重复利用已创建的线程降低线程创建和消耗的开销。</li><li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就可以立即执行。</li><li>提高线程的可管理性，线程是稀缺资源，如果无限制地创建不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ul></li><li><p><strong>线程池的工作流程</strong></p><ul><li>线程池判断核心线程池是否已满，如果不是则创建一个新的工作线程来执行任务（工作线程数&lt;corePoolSize，这一步需要获取全局锁）。</li><li>如何核心线程池已经满了，判断工作队列是否已满，如果没有就将任务存储在工作队列中（工作线程数&gt;=corePoolSize）。</li><li>如果工作队列满了，判断线程池是否已满，如果没有就还是创建一个新的工作线程来执行任务（工作线程数&lt;maximumPoolSize）。</li><li>如果线程池已满，就按照线程池的拒绝执行策略来处理无法执行的任务（工作线程数&gt;maximumPoolSize）。</li></ul><p>线程池采取这种设计思路是为了在执行execute方法时尽可能地避免获取全局锁，在线程池完成预热之后，即当前工作线程数&gt;=corePoolSzie时，几乎所有的execute方法都是执行步骤2，不需要获取全局锁。</p></li><li><p><strong>工作线程的任务</strong></p><p>线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务之后，还会循环获取工作队列中的任务来执行。线程池中的线程执行任务分为两种情况：①在execute方法中创建一个线程时会让这个线程执行当前任务。②这个线程执行完任务之后，就会反复从阻塞工作队列中获取任务并执行。</p></li><li><p><strong>ThreadPoolExecutor创建参数</strong></p><ul><li>corePoolSize：线程池的基本大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池的基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有的基本线程。</li><li>workQueue：工作队列，用于保存等待执行任务的阻塞队列，可以选择以下的阻塞队列：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockQueue等。</li><li>maximumPoolSize：线程池允许的最大线程数，如果工作队列已满，并且创建的线程数小于最大线程数，则线程池还会创建新的线程执行任务，如果使用的时无界阻塞队列该参数是无意义的。</li><li>threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li><li>handler：拒绝策略，当队列和线程池都满了说明线程池处于饱和状态，那么必须采取一种拒绝策略处理新提交的任务，默认情况下使用AbortPolicy直接抛出异常，CallerRunsPolicy表示重新尝试提交该任务，DiscardOldestPolicy表示抛弃队列里最近的一个任务并执行当前任务，DiscardPolicy表示直接抛弃当前任务不处理。也可以自定义该策略。</li><li>keepAliveTime：线程活动的保持时间，线程池工作线程空闲后保持存活的时间，所以如果任务很多，且每个任务的执行时间较短，可以调大时间提高线程的利用率。</li><li>unit：线程活动保持时间的单位，有天、小时、分钟、毫秒、微秒、纳秒。</li></ul></li><li><p><strong>如何像线程池提交任务</strong></p><p>可以使用execute和submit方法向线程池提交任务。execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功了。submit方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过该对象可以判断任务是否执行成功，并且可以通过该对象的get方法获取返回值，get方法会阻塞当前线程直到任务完成，带超时参数的get方法会在指定时间内返回，这时任务可能还没有完成。</p></li><li><p><strong>关闭线程池的原理</strong></p><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。区别是shutdownNow首先将线程池的状态设为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设为SHUTDOWN，然后中断所有没有正在执行任务的线程。</p><p>只要调用了这两个方法中的一个，isShutdown方法就会返回true，当所有任务都已关闭后才表示线程池关闭成功，这时调用isTerminated方法会返回true。通常调用shutdown方法来关闭线程池，如果任务不一定要执行完则可以调用shutdownNow方法。</p></li><li><p><strong>合理设置线程池</strong></p><p>首先可以从以下角度分析：①任务的性质：CPU密集型任务、IO密集型任务和混合型任务。②任务的优先级：高、中和低。③任务的执行时间：长、中和短。④任务的依赖性：是否以来其他系统资源，如数据库连接。</p><p>性质不同的任务可以用不同规模的线程池分开处理，CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型任务如果可以拆分将其拆分为一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大那么分解后的吞吐量将高于串行执行的吞吐量，如果相差太大则没必要分解。</p><p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue处理。</p><p>执行时间不同的任务可以交给不同规模的线程池处理，或者使用优先级队列。</p><p>以来数据库连接池的任务，由于线程提交SQL后需要等待数据库返回的结果，等待的时间越长CPU空闲的时间就越长，因此线程数应该尽可能地设置大一些提高CPU的利用率。</p><p>建议使用有界队列，能增加系统的稳定性和预警能力，可以根据需要设置的稍微大一些。</p></li><li><p>线程池的监控</p><ul><li>taskCount，线程池需要执行的任务数量。</li><li>completedTaskCount，线程池在运行过程中已经完成的任务数量，小于或等于taskCount。</li><li>largestPoolSize，线程池里曾经创建过的最大线程数量，通过这个数据可以知道线程池是否曾经满过，如果该数值等于线程池的最大大小表示线程池曾经满过。</li><li>getPoolSize，获取线程池的线程数量，如果线程池不销毁的化线程池里的线程不会自动销毁，所以这个数值只增不减。</li><li>getActiveCount，获取活动的线程数。</li></ul><p>通过扩展线程池进行监控，可以继承线程池来自定义，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前来执行一些代码进行监控，例如监控任务的平均执行时间、最大执行时间和最小执行时间。</p></li><li><p><strong>使用无界阻塞队列对线程池的影响</strong></p><p>①当线程池中的线程数达到corePoolSize之后新任务将在无界队列中等待，因此线程池中的数量不会超过corePoolSize。②因此使用无界队列时maximumPoolSize和keepAliveTime均是无效参数。③由于使用无界队列，线程池不会拒绝任务。</p></li></ul><hr><h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><ul><li><p><strong>Executor框架的调度模型</strong></p><p>在HotSpot VM的线程模型中，Java线程被一对一映射为本地操作系统线程，Java线程启动时会创建一个本地操作系统线程，当该Java线程终止时，这个操作系统线程也会被回收，操作系统会调度所有线程并将它们分配给可用的CPU。</p><p>Executor框架的调度模型是一种两级调度模型。在上层，Java多线程程序通常把应用分解为若干任务，然后使用用户级的调度器即Executor框架将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p></li><li><p><strong>Executor框架的结构</strong></p><p>主要由以下三部分组成：</p><p>①任务，包括被执行任务需要实现的接口，Runnable或Callable接口。</p><p>②任务的执行，包括任务执行机制的核心接口Executor（Executor框架的基础，将任务的提交和执行分离开来），以及继承自Executor的ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）。</p><p>③异步计算的结果，包括接口Future和实现Future接口的FutureTask类。当我们把Runnable接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。</p></li><li><p><strong>ThreadPoolExecutor</strong></p><p>ThreadPoolExecutor是Executor框架最核心的类，是线程池的实现类，主要有三种。</p><p>①FixedThreadPool，可重用固定线程数的线程池，corePoolSize和maximumPoolSize都被设置为创建时的指定参数nThreads，当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止，这里将其设置为0L表示多余空闲线程将被立即终止。该线程池使用的工作队列是无界阻塞队列LinkedBlockingQueue（队列容量为Integer的最大值）。适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，适用于负载比较重的服务器。</p><p>②SingleThreadExecutor，使用单个线程的线程池，corePoolSize和maximumPoolSize都被设置为1，其他参数和FiexedThreadPool相同。适用于需要保证顺序执行各个任务，并且在任意时间点不会有多个线程是活动的的应用场景。</p><p>③CachedThreadPool，一个根据需要创建线程的线程池，corePoolSize被设置为0，maximumPoolSize被设置为Integer的最大值，将keepAliveTime设为60L，意味着空闲线程等待时间最长为1分钟。该线程池使用的工作队列是没有容量的SynchronousQueue，但是maximumPoolSize设为Integer最大值，如果主线程提交任务的速度高于线程处理的速度，线程池会不断创建新线程，极端情况下会创建过多线程而耗尽CPU和内存资源。适用于执行很多短期异步任务的小程序，或者负载较轻的服务器。</p></li><li><p><strong>ScheduledThreadPoolExecutor</strong></p><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，主要用来在给定的延迟之后运行任务，或者定期执行任务。其功能与Timer类似，但是功能更加强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造方法中指定多个后台线程数。为了实现周期性的执行任务，使用DelayQueue作为工作队列，获取任务和执行周期任务后的处理都不同，主要有两种。</p><p>①ScheduledThreadPool：包含若干线程的ScheduledThreadPoolExecutor，创建固定线程个数的线程池。适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程数量的应用场景。</p><p>②SingleThreadScheduledExecutor：只包含一个线程的ScheduledThreadPoolExecutor，适用于单个后台线程执行周期任务，同时需要保证顺序执行各个任务的应用场景。</p><ul><li><p><strong>ScheduledThreadPoolExecutor的原理</strong></p><p>将待调度任务放入一个DelayQueue中，调度任务主要有三个参数，long类型的time表示这个任务将要被执行的具体时间，long类型的sequenceNumber表示这个任务被添加到线程池的序号，long类型的period表示任务执行时间间隔。DelayQueue封装了一个PriorityQueue，队列按照time进行排序，如果time相同则比较sequenceNumber，越小的排在前面，即如果两个任务的执行时间相同，先提交的任务先被执行。</p></li></ul></li><li><p><strong>Runnable接口和Callable接口的区别</strong></p><p>两个接口的相同点是Runnable接口和Callable接口的实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行，不同点是Runnable不会返回结果，Callable可以返回结构。除了可以自己创建Callable接口的对象外，还可以使用工厂类Executors将一个Runnable对象包装为一个Callable对象。</p></li><li><p><strong>FutureTask</strong></p><p>FutureTask除了实现了Future接口之外，还实现了Runnable接口。因此FutureTask可以交给Executor执行，也可以由调用线程直接执行即调用FutureTask对象的run方法，根据run方法被执行的时机，FutureTask可以处于三种状态：①未启动，当FutureTask对象被创建，且没有执行run方法之前的状态。②已启动，当run方法处于被执行过程中，FutureTask对象处于已启动状态。③已完成，当run方法执行后正常完成或执行run方法中抛出异常或调用cancel方法取消时，FutureTask对象处于已完成状态。</p><p>当处于未启动或已启动状态时，get方法将阻塞线程，当处于已完成状态时会立即返回结果或抛出异常。当处于未启动状态时，cancel方法会导致此任务永远不会执行，当处于已启动状态时，执行cancel(true)方法，将以中断执行此任务的方式来试图停止该任务，执行cancel(false)方法，将不会对正在执行此任务的线程产生应用，当处于已完成状态时，cancel方法返回false。</p><ul><li><p><strong>FutureTask的实现原理</strong></p><p>FutureTask的实现基于AQS，基于合成复用的设计原则，FutureTask声明了一个内部私有的继承于AQS的子类Sync，对Future的所有公有方法的调用都会委托给这个内部的子类。AQS被作为模板方法模式的基础类提供给FutureTask的内部子类Sync，这个内部的子类只需要实现状态检查和更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared和tryReleaseShared方法来检查和更新同步状态。</p></li><li><p><strong>FutureTask的get方法原理</strong></p><p>①调用AQS的acquireSharedInterruptibly方法，首先回调在子类Sync中实现的tryAcquireShared方法来判断acquire操作是否可以成功。acquire操作成功的条件为：state为执行完成状态或取消状态，且runner不为null。②如果成功get方法立即返回，如果失败则到线程等待队列中去等待其他线程执行release操作。③当其他线程执行release操作唤醒当前线程后，当前线程再次执行tryAcquireShared将返回1，当前线程将理课线程等待队列并唤醒它的后继线程。④返回最终结果或抛出异常。</p></li><li><p><strong>FutureTask的run方法原理</strong></p><p>①执行在构造方法中的指定任务。②以原子方式更新同步状态，如果操作成功就设置代表计算结果的变量result的值为Callable的call方法的返回值，然后调用AQS的releaseShared方法。③AQS的releaseShared方法首先回调子类Sync中实现的tryReleaseShared来执行release操作（设置运行任务的线程runner为null，然后返回true），然后唤醒线程等待队列的第一个线程。④调用FutureTask的done方法。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JMM </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud概述</title>
      <link href="2021/05/23/springcloud-gai-shu/"/>
      <url>2021/05/23/springcloud-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringCloud概述"><a href="#SpringCloud概述" class="headerlink" title="SpringCloud概述"></a>SpringCloud概述</h2><h3 id="1-微服务技术栈"><a href="#1-微服务技术栈" class="headerlink" title="1.微服务技术栈"></a>1.微服务技术栈</h3><table><thead><tr><th>微服务条目</th><th>落地技术</th></tr></thead><tbody><tr><td>服务开发</td><td>SpringBoot,Spring,SpringMV</td></tr><tr><td>服务配置与管理</td><td>NetFlix公司的Archaius、阿里的Diamond</td></tr><tr><td>服务注册与发现</td><td>Eureka、Consul、Zookeeper</td></tr><tr><td>服务调用</td><td>Rest、RPC、gRPC</td></tr><tr><td>服务熔断器</td><td>Hystrix、Envoy等</td></tr><tr><td>负载均衡</td><td>Ribbon、Nginx等</td></tr><tr><td>服务接口调用（客户端调用服务的简化工具）</td><td>Feign等</td></tr><tr><td>消息队列</td><td>Kafka、RabbitMQ、ActiveMQ</td></tr><tr><td>服务配置中心管理</td><td>SpringCloudConfig、Chef等</td></tr><tr><td>服务路由（API网关）</td><td>Zuul</td></tr><tr><td>服务监控</td><td>Zabbix、Nagios、Metrics、Specatator</td></tr><tr><td>全链路追踪</td><td>Zipkin、Brave、Dapper</td></tr><tr><td>服务部署</td><td>Docker、OpenStack、Kubernetes等</td></tr><tr><td>数据流操作开发包</td><td>SpringCloud Stream（封装与Redis，Rabbit，Kafka等发送接收消息）</td></tr><tr><td>时间消息总线</td><td>SpringCloud Bus</td></tr></tbody></table><h3 id="2-SpringCloud入门"><a href="#2-SpringCloud入门" class="headerlink" title="2.SpringCloud入门"></a>2.SpringCloud入门</h3><h4 id="2-1-什么是SpringCloud"><a href="#2-1-什么是SpringCloud" class="headerlink" title="2.1 什么是SpringCloud"></a>2.1 什么是SpringCloud</h4><blockquote><p>官方说法：<br>构建分布式系统不需要复杂和容易出错。Spring Cloud  为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。Spring Cloud 构建于  Spring Boot 之上，使得开发者很容易入手并快速应用于生产中。</p></blockquote><p>简单来说：<code>Spring Cloud</code> 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 <strong>服务发现注册</strong> 、<strong>配置中心</strong> 、<strong>消息总线</strong> 、<strong>负载均衡</strong> 、<strong>断路器</strong> 、<strong>数据监控</strong> 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p><h4 id="2-2-SpringCloud的版本"><a href="#2-2-SpringCloud的版本" class="headerlink" title="2.2 SpringCloud的版本"></a>2.2 SpringCloud的版本</h4><p><code>Spring Cloud</code> 的版本号并不是我们通常见的数字版本号，而是一些很奇怪的单词。这些单词均为英国伦敦地铁站的站名。同时根据字母表的顺序来对应版本时间顺序，比如：最早 的 <code>Release</code> 版本 <code>Angel</code>，第二个 <code>Release</code> 版本 <code>Brixton</code>（英国地名），然后是 <code>Camden</code>、 <code>Dalston</code>、<code>Edgware</code>、<code>Finchley</code>、<code>Greenwich</code>、<code>Hoxton</code>。</p><h4 id="2-3-为什么选择SpringCloud"><a href="#2-3-为什么选择SpringCloud" class="headerlink" title="2.3 为什么选择SpringCloud"></a>2.3 为什么选择SpringCloud</h4><p><strong>选型依据</strong></p><ul><li>整体式解决方案，成熟的框架</li><li>高热度社区</li><li>可维护性强</li></ul><p><strong>大公司的微服务架构</strong></p><ul><li>阿里：dubbo + HFS</li><li>京东：JSF</li><li>新浪：Motan</li><li>当当网：DubboX</li><li>…</li></ul><p><strong>框架对比</strong></p><table><thead><tr><th>功能</th><th align="center">Netflix/SpringCloud</th><th>Motan</th><th>gRPC</th><th>Thrift</th><th>Dubbo/DubboX</th></tr></thead><tbody><tr><td>功能定位</td><td align="center">完整的微服务框架</td><td>RPC框架，但是整合了ZK或Consul，实现了集群环境的基本服务注册/发现</td><td>RPC框架</td><td>RPC框架</td><td>服务框架</td></tr><tr><td>支持Rest</td><td align="center">是，Ribbon支持多种可插拔的序列化选择</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>支持RPC</td><td align="center">否</td><td>是（Hession2）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>支持多语言</td><td align="center">是（Rest形式）</td><td>否</td><td>是</td><td>是</td><td>否</td></tr><tr><td>负载均衡</td><td align="center">是（服务端zuul+客户端Ribbon），zuul服务，动态路由，云端负载均衡Eureka（针对中间层服务器）</td><td>是（客户端）</td><td>否</td><td>否</td><td>是（客户端）</td></tr><tr><td>配置服务</td><td align="center">Netflix Archaius，SpringCloud Config Server集中配置</td><td>是（Zookeeper提供）</td><td>否</td><td>否</td><td>否</td></tr><tr><td>服务调用链监控</td><td align="center">是（zuul），zuul提供边缘服务，API网关</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>高可用/容错</td><td align="center">是（服务端Hystrix+客户端Ribbon）</td><td>是（客户端）</td><td>否</td><td>否</td><td>是（客户端）</td></tr><tr><td>典型应用案例</td><td align="center">Netflix</td><td>Sina</td><td>Google</td><td>Facebook</td><td></td></tr></tbody></table><h4 id="2-4-SpringCloud官方链接"><a href="#2-4-SpringCloud官方链接" class="headerlink" title="2.4 SpringCloud官方链接"></a>2.4 SpringCloud官方链接</h4><p><a href="https://spring.io/projects/spring-cloud/#learn">SpringCloud官方</a></p><p><a href="https://www.springcloud.cc/spring-cloud-netflix.html">SpringCloud Netflix</a></p><p><a href="https://www.springcloud.cc/spring-cloud-dalston.html">SpringCloud中文API文档</a></p><p><a href="http://www.springcloud.cn/">SpringCloud中文社区</a></p><p><a href="https://www.springcloud.cc/">SpringCloud技术栈</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统</title>
      <link href="2021/05/21/fen-bu-shi-xi-tong/"/>
      <url>2021/05/21/fen-bu-shi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h2 id="1-相关理论"><a href="#1-相关理论" class="headerlink" title="1. 相关理论"></a>1. 相关理论</h2><h3 id="A-CAP理论"><a href="#A-CAP理论" class="headerlink" title="A. CAP理论"></a>A. CAP理论</h3><blockquote><ul><li>一致性（Consistency）:所有节点访问同一份最新的数据副本</li><li>可用性（Availability）:非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）</li><li>分区容错性（网络分区）Partition tolerance:分布式系统出现网络分区的时候，仍然能够对外提供服务</li></ul></blockquote><p>​    <strong>什么是网络分区？</strong></p><blockquote><p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p></blockquote><img src="/2021/05/21/fen-bu-shi-xi-tong/1" class title="CAP理论图示"><p><code>CAP的三选二的原理:</code></p><blockquote><p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p><p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p></blockquote><blockquote><p>AP(放弃C)：放弃强一致性，用最终一致性来保证。</p><p>CP(放弃A)：一旦系统遇见故障，受到影响的服务器需要等待一段时间，在恢复期间无法对外提供服务。</p></blockquote><blockquote><p><strong>为啥无同时保证 CA 呢？</strong></p><p>举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p><p><strong>选择的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p></blockquote><p><strong>分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独 立，通过网络进行沟通和协调。XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件 用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。</strong></p><h3 id="B-2P理论-二段提交"><a href="#B-2P理论-二段提交" class="headerlink" title="B. 2P理论(二段提交)"></a>B. 2P理论(二段提交)</h3><p><strong><code>二阶段提交(Two-phase Commit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统 架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。</code></strong></p><p>二段提交（RDBMS(传统关系型数据库)经常就这种机制，<em><strong>保证强一致性</strong></em>）</p><blockquote><p>提交步骤：</p><p>阶段1：提交事务请求（投票阶段，任何一个结点失败，不能继续进行提交）</p><img src="/2021/05/21/fen-bu-shi-xi-tong/2" class title="二阶段提交之第一阶段"><p>阶段2：执行事务提交（commit、rollback。任何一个结点失败 rollback）</p><img src="/2021/05/21/fen-bu-shi-xi-tong/3" class title="二阶段提交之第二阶段"></blockquote><ul><li><p>缺点：</p><blockquote><p><strong>同步阻塞问题</strong></p><p>​         1、执行过程中，所有参与节点都是事务阻塞型的</p><p>**单点故障 **</p><p>​        2、由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。</p><p>​                解决：<strong>协调者故障，通过选举得到新协调者</strong>（弊端：假如协调者和第一个参与者都挂了；<strong>每个参与者自身的状态只有自己和协调者知道</strong>，因此新协调者无法通过在场的参与者的状态推断出挂了的参与者是什么情况。）                </p><p><strong>数据不一致（脑裂问题）</strong></p><p>​         3、在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异 常或者在发送 commit 请求过程中协调者发生了故障，导致只有一部分参与者接受到了 commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。</p><p><strong>二阶段无法解决的问题（数据状态不确定）</strong></p><p>​         4、协调者再发出 commit 消息之后宕机，<code>而唯一接收到这条消息的参与者同时也宕机了</code>。那 么即使协调者通过选举协议产生了新的协调者，<code>这条事务的状态也是不确定的，没人知道 事务是否被已经提交</code>。</p></blockquote></li></ul><p><strong>解决方案：</strong></p><blockquote><p><strong>1.XA三阶段提交</strong></p><p>XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。</p><p><strong>2.MQ事务</strong></p><p>利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。</p><p><strong>3.TCC事务</strong></p><p>TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于XA两阶段提交，但是实现方式是在代码层面来人为实现。</p></blockquote><h3 id="C-3P理论-三段提交-一般不用"><a href="#C-3P理论-三段提交-一般不用" class="headerlink" title="C. 3P理论(三段提交)(一般不用)"></a>C. 3P理论(三段提交)(一般不用)</h3><p><strong>与两阶段提交不同的是，三阶段提交有两个改动点。</strong> </p><p>​        1、引入超时机制。同时在协调者和参与者中都引入超时机制。 </p><p>​        2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是 一致的。首先<strong>准备阶段的变更成不会直接执行事务</strong>，而是会先去询问此时的参与者是否有条件接这个事务，因此<strong>不会一来就干活直接锁资源</strong>，使得在某些资源不可用的情况下所有参与者都阻塞着。而<strong>预提交阶段的引入起到了一个统一状态的作用</strong>，它像一道栅栏，表明在预提交阶段前所有参与者其实还未都回应，在预处理阶段表明所有参与者都已经回应了。</p><blockquote><p>阶段1：是否可以进行事务提交</p><img src="/2021/05/21/fen-bu-shi-xi-tong/4" class title="三阶段提交之第一阶段"><p>阶段2： 提交事务请求</p><img src="/2021/05/21/fen-bu-shi-xi-tong/5" class title="三阶段提交之第二阶段"><p>阶段3：执行事务提交</p><img src="/2021/05/21/fen-bu-shi-xi-tong/6" class title="三阶段提交之第三阶段"></blockquote><h3 id="D-BASE理论"><a href="#D-BASE理论" class="headerlink" title="D. BASE理论"></a>D. BASE理论</h3><p><strong>BASE 理论，它是在 CAP 理论的基 础之上的延伸。</strong>包括 :</p><blockquote><p>基本可用（Basically Available）:在分布式系统出现，允许损失部分可用性（服务降级、页面降级）v</p><p>柔性状态（Soft State）:允许分布式系统出现中间状态。而且中间状态不影响系统的可用性。</p><p>最终一致性 （Eventual Consistency）:data replications经过一段时间达到一致性。</p></blockquote><h2 id="2-一致性算法"><a href="#2-一致性算法" class="headerlink" title="2. 一致性算法"></a>2. 一致性算法</h2><h3 id="A-paxos一致性算法"><a href="#A-paxos一致性算法" class="headerlink" title="A. paxos一致性算法"></a>A. paxos一致性算法</h3><p>​        paxos算法是莱斯利·兰伯特于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法。Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是paxos，其它的算法都是残次品。</p><p><strong><code>基于拜占庭将军问题解析：</code></strong></p><p>分为以下两种角色：</p><ul><li>proposer：参谋1，参谋2（提交者）</li><li>acceptor： 将军1，将军2，将军3（决策者）</li></ul><blockquote><p><strong>1、先后提议的场景</strong></p><img src="/2021/05/21/fen-bu-shi-xi-tong/7" class title="先后提议的场景"><ul><li>参谋1发起提议，派通信兵带信给3个将军，内容为（编号1）</li><li>3个将军收到参谋1的提议，由于之前还没有保存任何编号，因此把（编号1）保存下来，避免遗忘；同时让通信兵带信回去，内容为（ok）</li><li>参谋1收到至少2个将军的回复，再次派通信兵带信给3个将军，内容为（编号1，进攻时间1）</li><li>3个将军收到参谋1的时间，把（编号1，进攻时间1）保存下来，避免遗忘；同时让通信兵带信回去，内容为（Accepted）</li><li>参谋1收到至少2个将军的（Accepted）内容，确认进攻时间已经被大家接收；</li><li>参谋2发起提议，派通信兵带信给3个将军，内容为（编号2）</li><li>3个将军收到参谋2的提议，由于（编号2）比（编号1）大，因此把（编号2）保存下来，避免遗忘；又由于之前已经接受参谋1的提议，因此让通信兵带信回去，内容为（编号1，进攻时间1）</li><li>参谋2收到至少2个将军的回复，由于回复中带来了已接受的参谋1的提议内容，参谋2因此不再提出新的进攻时间，接受参谋1提出的时间</li></ul><p><strong>2、交叉提交场景</strong></p><img src="/2021/05/21/fen-bu-shi-xi-tong/8" class title="交叉提交的场景"><ul><li>参谋1发起提议，派通信兵带信给3个将军，内容为（编号1）；</li><li>3个将军的情况如下:<ul><li>将军1和将军2收到参谋1的提议，将军1和将军2把（编号1）记录下来，如果有其他参谋提出更小的编号，将被拒绝；同时让通信兵带信回去，内容为（ok）</li><li>负责通知将军3的通信兵被抓，因此将军3没收到参谋1的提议</li></ul></li><li>参谋2在同一时间也发起了提议，派通信兵带信给3个将军，内容为（编号2）</li><li>3个将军的情况如下<ul><li>将军2和将军3收到参谋2的提议，将军2和将军3把（编号2）记录下来，如果有其他参谋提出更小的编号，将被拒绝；同时让通信兵带信回去，内容为（ok）</li><li>负责通知将军1的通信兵被抓，因此将军1没收到参谋2的提议</li></ul></li><li>参谋1收到至少2个将军的回复，再次派通信兵带信给有答复的2个将军，内容为（编号1，进攻时间1）</li><li>2个将军的情况如下<ul><li>将军1收到了（编号1，进攻时间1），和自己保存的编号相同，因此把（编号1，进攻时间1）保存下来；同时让通信兵带信回去，内容为（Accepted）</li><li>将军2收到了（编号1，进攻时间1），由于（编号1）小于已经保存的（编号2），因此让通信兵带信回去，内容为（Rejected，编号2）</li></ul></li><li>参谋2收到至少2个将军的回复，再次派通信兵带信给有答复的2个将军，内容为（编号2，进攻时间2）</li><li>将军2和将军3收到了（编号2，进攻时间2），和自己保存的编号相同，因此把（编号2，进攻时间2）保存下来，同时让通信兵带信回去，内容为（Accepted）</li><li>参谋2收到至少2个将军的（Accepted）内容，确认进攻时间已经被多数派接受</li><li>参谋1只收到了1个将军的（Accepted）内容，同时收到一个（Rejected，编号2）;参谋1重新发起提议，派通信兵带信给3个将军，内容为（编号3）</li><li>3个将军的情况如下<ul><li>将军1收到参谋1的提议，由于（编号3）大于之前保存的（编号1），因此把（编号3）保存下来；由于将军1已经接受参谋1前一次的提议，因此让通信兵带信回去，内容为（编号1，进攻时间1）</li><li>将军2收到参谋1的提议，由于（编号3）大于之前保存的（编号2），因此把（编号3）保存下来；由于将军2已经接受参谋2的提议，因此让通信兵带信回去，内容为（编号2，进攻时间2）</li><li>负责通知将军3的通信兵被抓，因此将军3没收到参谋1的提议</li></ul></li><li>参谋1收到了至少2个将军的回复，比较两个回复的编号大小，选择大编号对应的进攻时间作为最新的提议；参谋1再次派通信兵带信给有答复的2个将军，内容为（编号3，进攻时间2）</li><li>将军1和将军2收到了（编号3，进攻时间2），和自己保存的编号相同，因此保存（编号3，进攻时间2），同时让通信兵带信回去，内容为（Accepted）</li><li>参谋1收到了至少2个将军的（accepted）内容，确认进攻时间已经被多数派接受。</li></ul></blockquote><p><strong>看完以上两幅图有一个大概的图的印象后，建议看维基的推导过程，这样加深印象，理解更深。</strong></p><p><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95">https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95</a></p><p>算法整体流程–&gt;决议的提出和批准：</p><blockquote><p>通过一个决议分为两个阶段：</p><ol><li>prepare阶段：<ol><li>proposer选择一个提案编号n并将prepare请求发送给acceptors中的一个多数派；</li><li>acceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息(回复消息表示接受accept)，则acceptor将自己上次接受的提案回复给proposer，并承诺不再回复小于n的提案；</li></ol></li><li>批准阶段：<ol><li>当一个proposer收到了多数acceptors对prepare的回复后，就进入批准阶段。它要向回复prepare请求的acceptors发送accept请求，包括编号n和根据P2c决定的value（如果根据P2c没有已经接受的value，那么它可以自由决定value）。</li><li>在不违背自己向其他proposer的承诺的前提下，acceptor收到accept请求后即批准这个请求。</li></ol></li></ol><p>这个过程在任何时候中断都可以保证正确性。例如如果一个proposer发现已经有其他proposers提出了编号更高的提案，则有必要中断这个过程。因此为了优化，在上述prepare过程中，如果一个acceptor发现存在一个更高编号的提案，则需要通知proposer，提醒其中断这次提案。</p></blockquote><p>Learner学习（获取）被选定的value有如下三种方案：</p><img src="/2021/05/21/fen-bu-shi-xi-tong/0.png" class title="Learner学习（获取）的三种方案"><p>保证算法活性progress：</p><img src="/2021/05/21/fen-bu-shi-xi-tong/00.png" class title="保证算法活性progress"><p>“活锁”的根本原因在于两个proposer交替提案，避免“活锁”的方式为，如果一个proposer通过accpter返回的消息知道此时有更高编号的提案被提出时，该proposer静默一段时间，而不是马上提出更高的方案，静默期长短为一个提案从提出到被接受的大概时间长度即可，静默期过后，proposer重新提案。系统中之所以要有主proposer的原因在于，如果每次数据更改都用paxos，那实在是太慢了，还是通过主节点下发请求这样来的快，因为省去了不必要的paxos时间。所以选择主proposer用paxos算法，因为选主的频率要比更改数据频率低太多。但是主proposer挂了咋整，整个集群就一直处于不可用状态，所以一般都用租约的方式，如果proposer挂了，则租约会过期，其它proposer就可以再重新选主，如果不挂，则主proposer自己续租。</p><h3 id="B-raft一致性算法"><a href="#B-raft一致性算法" class="headerlink" title="B. raft一致性算法"></a>B. raft一致性算法</h3><h2 id="3-一致性Hash算法"><a href="#3-一致性Hash算法" class="headerlink" title="3. 一致性Hash算法"></a>3. 一致性Hash算法</h2><p><em><strong>参考：</strong></em><a href="https://zhuanlan.zhihu.com/p/98030096">一致性hash算法详解</a></p><h3 id="A-普通Hash算法在分布式应用中的不足"><a href="#A-普通Hash算法在分布式应用中的不足" class="headerlink" title="A. 普通Hash算法在分布式应用中的不足"></a>A. 普通Hash算法在分布式应用中的不足</h3><blockquote><p>比如，在分布式的存储系统中，要将数据存储到具体的节点上，如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。</p></blockquote><h3 id="B-一致性Hash算法"><a href="#B-一致性Hash算法" class="headerlink" title="B. 一致性Hash算法"></a>B. 一致性Hash算法</h3><blockquote><p>一致性哈希提出了在动态变化的Cache环境中，哈希算法应该满足的4个适应条件(from 百度百科)：</p><p>A:均衡性(Balance)</p><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p><p>B:单调性(Monotonicity)</p><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。（这段翻译信息有负面价值的，当缓冲区大小变化时一致性哈希(Consistent hashing)尽量保护已分配的内容不会被重新映射到新缓冲区。）</p><p>C:分散性(Spread)</p><p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p><p>D:负载(Load)</p><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p></blockquote><h5 id="B-1-环形hash空间"><a href="#B-1-环形hash空间" class="headerlink" title="B.1 环形hash空间"></a>B.1 环形hash空间</h5><p>​        <em>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。</em>整个hash环我们可以用TreeMap来实现，因为treeMap是排序的，我们刚好可以利用上。</p><img src="/2021/05/21/fen-bu-shi-xi-tong/1.jpg" class title="环形节点"><h5 id="B-2-映射服务器节点"><a href="#B-2-映射服务器节点" class="headerlink" title="B.2 映射服务器节点"></a>B.2 映射服务器节点</h5><p>​        <em>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假设我们将四台服务器使用ip地址哈希后在环空间的位置如下：</em></p><img src="/2021/05/21/fen-bu-shi-xi-tong/2.jpg" class title="映射服务器节点"><h5 id="B-3-映射数据"><a href="#B-3-映射数据" class="headerlink" title="B.3 映射数据"></a>B.3 映射数据</h5><p>​        <em>现在我们将objectA、objectB、objectC、objectD四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</em></p><img src="/2021/05/21/fen-bu-shi-xi-tong/3.jpg" class title="映射数据"><h5 id="B-4-服务器的删除与添加"><a href="#B-4-服务器的删除与添加" class="headerlink" title="B.4 服务器的删除与添加"></a>B.4 服务器的删除与添加</h5><blockquote><ul><li>如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化</li><li>如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</li></ul></blockquote><img src="/2021/05/21/fen-bu-shi-xi-tong/4.jpg" class title="服务器的删除与添加"><h5 id="B-5-虚拟节点"><a href="#B-5-虚拟节点" class="headerlink" title="B.5 虚拟节点"></a>B.5 虚拟节点</h5><p>​        <em>到目前为止一致性hash也可以算做完成了，但是有一个问题还需要解决，那就是<strong>平衡性</strong>。当服务器节点比较少的时候，会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。</em></p><img src="/2021/05/21/fen-bu-shi-xi-tong/5.jpg" class title="映射虚拟节点之前"><p>​        <em>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。</em></p><img src="/2021/05/21/fen-bu-shi-xi-tong/6.jpg" class title="映射虚拟节点之后"><h2 id="4-分布式ID"><a href="#4-分布式ID" class="headerlink" title="4. 分布式ID"></a>4. 分布式ID</h2><blockquote><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。</p></blockquote><h2 id="5-Dubbo"><a href="#5-Dubbo" class="headerlink" title="5. Dubbo"></a>5. Dubbo</h2><p>Dubbo的学习一定要看官网，这里粘一下关于负载均衡的源代码解析，整个源代码更迭过程很有启发:<a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/</a></p><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p><p>在Dubbo的官网文档有这样一张图</p><img src="/2021/05/21/fen-bu-shi-xi-tong/7.jpg" class title="dubbo架构演变"><h4 id="1-单一应用架构-All-in-One"><a href="#1-单一应用架构-All-in-One" class="headerlink" title="1. 单一应用架构(All in One)"></a>1. 单一应用架构(All in One)</h4><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><img src="/2021/05/21/fen-bu-shi-xi-tong/9" class title="单一应用架构"><p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p><p><strong>缺点：</strong></p><p>1、性能扩展比较难</p><p>2、协同开发问题</p><p>3、不利于升级维护</p><h4 id="2-垂直应用架构-Vertical-Application"><a href="#2-垂直应用架构-Vertical-Application" class="headerlink" title="2. 垂直应用架构(Vertical Application)"></a>2. 垂直应用架构(Vertical Application)</h4><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><img src="/2021/05/21/fen-bu-shi-xi-tong/10" class title="垂直应用架构"><p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p><p>缺点：公用模块无法重复利用，开发性的浪费</p><h4 id="3-分布式服务架构-Distributed-Service"><a href="#3-分布式服务架构-Distributed-Service" class="headerlink" title="3. 分布式服务架构(Distributed Service)"></a>3. 分布式服务架构(Distributed Service)</h4><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。</p><img src="/2021/05/21/fen-bu-shi-xi-tong/11" class title="分布式服务架构"><h4 id="4-弹性计算架构-Elastic-Computing"><a href="#4-弹性计算架构-Elastic-Computing" class="headerlink" title="4. 弹性计算架构(Elastic Computing)"></a>4. 弹性计算架构(Elastic Computing)</h4><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>(SOA)[ Service Oriented Architecture]是关键。</p><img src="/2021/05/21/fen-bu-shi-xi-tong/12" class title="弹性计算架构"><h2 id="6-RPC和HTTP"><a href="#6-RPC和HTTP" class="headerlink" title="6. RPC和HTTP"></a>6. RPC和HTTP</h2><p>无论是微服务还是分布式服务（都是SOA，都是面向服务编程），都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？</p><p>常见的远程调用方式有以下几种：</p><ul><li><p>RPC：是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。，类似的还有RMI（Remote Methods Invoke  远程方法调用，是JAVA中的概念，是JAVA十三大技术之一）。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型</p></li><li><ul><li>RPC的框架：webservie(cxf)、dubbo(阿里巴巴开源的基于 Java 的高性能 RPC)</li><li>RMI的框架：hessian</li></ul></li></ul><ul><li><p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。<br>现在热门的Rest风格，就可以通过http协议来实现。</p></li><li><ul><li>http的实现技术：HttpClient</li></ul></li></ul><p><strong>RPC基本原理</strong></p><img src="/2021/05/21/fen-bu-shi-xi-tong/13" class title="RPC基本原理图"><p><strong>步骤解析：</strong></p><img src="/2021/05/21/fen-bu-shi-xi-tong/14" class title="RPC流程图"><p>RPC两个核心模块：通讯，序列化。</p><p><strong>要实现一个RPC不算难，难的是实现一个高性能高可靠的RPC框架。</strong></p><p>比如，既然是分布式了，那么一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？</p><p>这时候就需要一个服务注册中心，比如在Dubbo里头，就可以使用Zookeeper作为注册中心，在调用时，从Zookeeper获取服务的实例列表，再从中选择一个进行调用。</p><p>那么选哪个调用好呢？这时候就需要负载均衡了，于是你又得考虑如何实现复杂均衡，比如Dubbo就提供了好几种负载均衡策略。</p><p>这还没完，总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题，blablabla……</p><p>你以为就这样结束了，没呢，还有这些：</p><ul><li>客户端总不能每次调用完都干等着服务端返回数据吧，于是就要支持异步调用；</li><li>服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；</li><li>服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；</li><li>服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？</li><li>……</li></ul><h3 id="RPC和HTTP认知误区勘误"><a href="#RPC和HTTP认知误区勘误" class="headerlink" title="RPC和HTTP认知误区勘误"></a>RPC和HTTP认知误区勘误</h3><p>rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。</p><p>传输协议包含: 如著名的gRPC 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。</p><p>序列化协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf hessian等。</p><p><strong>为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？</strong></p><p>要解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。</p><p>首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于连接的建立与断开。http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二一要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。</p><p>通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">HTTP/1.0 200 OK Content-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Hello World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使编码协议也就是body是使用二进制编码协议，报文元数据也就是header头的键值对却用了文本编码，非常占字节数。如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。</p><p>那么假如我们使用自定义tcp协议的报文如下</p><img src="/2021/05/21/fen-bu-shi-xi-tong/8.jpg" class title="自定义tcp协议报文"><p>报头占用的字节数也就只有16个byte，极大地精简了传输内容。</p><p>这也就是为什么后端进程间通常会采用自定义tcp协议的rpc来进行通信的原因。</p><p>但是现在越来越少使用RPC了，是因为RPC所谓的效率优势是针对http1.1协议来讲的，http2.0协议已经优化编码效率问题，像grpc这种rpc库使用的就是http2.0协议。</p><p>所以说成熟的rpc库相对http容器，更多的是封装了“服务发现”，”负载均衡”，“熔断降级”一类面向服务的高级特性。可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。因此良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> RPC </tag>
            
            <tag> Dubbo </tag>
            
            <tag> paxos </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之cron表达式</title>
      <link href="2021/05/21/springboot-zhi-cron-biao-da-shi/"/>
      <url>2021/05/21/springboot-zhi-cron-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot之cron表达式"><a href="#springboot之cron表达式" class="headerlink" title="springboot之cron表达式"></a>springboot之cron表达式</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>在学习springboot的定时任务时，在方法上的<code>@Scheduled(cron = &quot;0 * * * * 0-7&quot;)</code>注解可以用cron表达式来表示定时的时间，这个博客来详细讲下cron表达式</p><h3 id="2-Cron详解"><a href="#2-Cron详解" class="headerlink" title="2.Cron详解"></a>2.Cron详解</h3><h4 id="字段释义"><a href="#字段释义" class="headerlink" title="字段释义"></a>字段释义</h4><pre class="line-numbers language-none"><code class="language-none">0 0&#x2F;5 * * * ？秒    分    时    天(月)    月    天(周)    年份(一般省略)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="符号释义"><a href="#符号释义" class="headerlink" title="符号释义"></a>符号释义</h4><p><code>*</code>：表示所有可能的值</p><p><code>/</code>：表示数值的增量，简单来说，比如分写上<code>0/5</code>表示从0分开始，每隔5分钟</p><p><code>?</code>：仅用在天(月)和天(周)，表示不指定值，当其中一个有值时，另外一个需要设为`?</p><h4 id="字段允许字符"><a href="#字段允许字符" class="headerlink" title="字段允许字符"></a>字段允许字符</h4><h5 id="秒：0-59"><a href="#秒：0-59" class="headerlink" title="秒：0-59 , - * /"></a>秒：<code>0-59</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><ul><li>26：表示第26秒</li><li>5,16,27：表示第5秒、第16秒和第27秒</li><li>1-5：表示从1秒到5秒，就是1 2  3  4 5 秒</li><li>*：表示每一秒</li><li>2/15：表示从第2秒开始，每隔15秒，就是2 17 32 47 秒</li></ul><h5 id="分：0-59"><a href="#分：0-59" class="headerlink" title="分：0-59 , - * /"></a>分：<code>0-59</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><p>根据上述的秒，同理可得</p><ul><li>26：表示第26分钟</li><li>5,16,27：表示第5分钟、第16分钟和第27分钟</li><li>1-5：表示从1秒到5分，就是第1 2  3  4 5 分钟</li><li>*：表示每一分钟</li><li>2/15：表示从第2分钟开始，每隔15分钟，就是2 17 32 47 分钟</li></ul><h5 id="时：0-23"><a href="#时：0-23" class="headerlink" title="时：0-23 , - * /"></a>时：<code>0-23</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><ul><li>10：表示早上10点</li><li>22：表示晚上10点</li><li>2,8,18,23：表示凌晨2点，早上8点，傍晚6点和晚上11点</li><li>9-17：表示朝九晚五，就是9 10 11 12 13 14 15 16 17 点</li><li>*：表示每小时</li><li>10/2：表示从早上10点开始，每隔2小时</li></ul><h5 id="天（月）：1-31-L-W-C"><a href="#天（月）：1-31-L-W-C" class="headerlink" title="天（月）：1-31 , - * / ? L W C"></a>天（月）：<code>1-31</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code> <code>?</code> <code>L</code> <code>W</code> <code>C</code></h5><ul><li>31：表示31号（注意有的月份是没有31号的）</li><li>5,10,15：表示5号、10号和15号</li><li>8-17：表示8号到17号</li><li>*：表示所有可能的值（当指定为星号时，天（周）需指定为?）</li><li>5/9：表示从5号开始，每隔9天</li><li>？：当天（周）指定任意值的时候，天（月）需要设置为?</li><li>L：表示一个月中的最后一天</li><li>6L：表示倒数第6天</li><li>15W：W指工作日，如果15号不是周六日，则表示15号当天；如果15号是周六，则表示14号；如果15号是周日，则表示16号；如果31W是周日，则31W表示29号（周五），不会跨月</li><li>LW：指最后一个工作日</li><li>15C：表示第15天（不是很明白这个，使用15和15C貌似效果相同？）</li></ul><h5 id="月：1-12"><a href="#月：1-12" class="headerlink" title="月：1-12 , - * /"></a>月：<code>1-12</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><ul><li>10：表示10月份</li><li>5,10,11：表示5月份、10月份和11月份</li><li>4-8：表示4月份到8月份</li><li>*：表示所有可能的值</li><li>5/2：表示从5月份开始，每隔2个月，（就是5 7 9 11 次年5 次年7 次年9……）</li><li>1-12：也可以用JAN-DEC表示</li></ul><h5 id="天（周）：MON-SAT-L-C"><a href="#天（周）：MON-SAT-L-C" class="headerlink" title="天（周）：MON-SAT  , - * / ? L C #"></a>天（周）：<code>MON-SAT</code>  <code>,</code> <code>-</code> <code>*</code> <code>/</code> <code>?</code> <code>L</code> <code>C</code> <code>#</code></h5><ul><li>MON：表示周一</li><li>MON,TUE,FRI：表示周一，周二和周五</li><li>MON-FRI：表示从周一到周五</li><li>MON-WED,SAT：表示从周一到周三，和周六（就是周一、周二、周三和周六）</li><li>mon,tue,wed,thu,fri,sat,sun：表示周一到周日（大小写均可，取星期英文前三个字母，注意星期四是thu，而不是thur）</li><li>7L：表示最后一个周六（效果等同于SATL）（L表示last最后的意思，7表示周六，6表示周五，类推，1表示周日）</li><li>6C：表示周五以及之后包含周五的日期（感觉效果FRI一样，具体还没深究）</li><li>7#2：表示第二个周六（#前面的数字表示星期，1表示周日，2表示周一，以此类推；#后面的数字表示第几个）</li></ul><h5 id="年：留空-2020-2099"><a href="#年：留空-2020-2099" class="headerlink" title="年：留空  2020-2099 , - * /"></a>年：<code>留空</code>  <code>2020-2099</code> <code>,</code> <code>-</code> <code>*</code> <code>/</code></h5><ul><li>2050：表示2050年</li><li>2020,2030,2040：表示2020年、2030年和2040年</li><li>2020-2030：表示2020年到2030年</li><li>*：表示所有可能的值</li><li>2020/10：表示从2020年开始，每隔10年，（就是2020,2030,2040……）</li></ul><h3 id="3-例子"><a href="#3-例子" class="headerlink" title="3.例子"></a>3.例子</h3><ul><li><p>每隔5分钟执行一次（从0分开始）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span><span class="token operator">/</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">*</span> ？<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>从0时开始，每小时执行一次</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span><span class="token operator">/</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>每天的7点30分</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">30</span> <span class="token number">7</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>工作日的早上6点30分（即是周一到周五，每天早上的6点30分）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">30</span> <span class="token number">6</span> <span class="token operator">?</span> <span class="token operator">*</span> MON<span class="token operator">-</span>FRI<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>每个月的最后一天早上的10点整</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span> <span class="token number">10</span> <span class="token class-name">L</span> <span class="token operator">*</span>　<span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>每个月的最后一个工作日的晚上6点30分（18:30）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">30</span> <span class="token number">18</span> LW <span class="token operator">*</span> <span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>朝九晚五，每小时</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span> <span class="token number">9</span><span class="token operator">-</span><span class="token number">17</span> <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>2020年的8月份每个星期六和星期日早上10点28分28秒</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">28</span> <span class="token number">28</span> <span class="token number">10</span> <span class="token operator">?</span> <span class="token number">8</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token number">2020</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span>中，<span class="token number">1</span>表示周日，<span class="token number">7</span>表示周六<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>每个月的倒数第二天的早上8点整</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0</span> <span class="token number">0</span> <span class="token number">8</span> <span class="token class-name">L</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token operator">?</span><span class="token class-name">L</span>表示最后一天（倒数第一天），<span class="token class-name">L</span><span class="token operator">-</span><span class="token number">1</span>则表示倒数第二天，以此类推<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下面是网上一些例子，我直接拿过来了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token string">"0 0 12 * * ?"</span> 每天中午<span class="token number">12</span>点触发 <span class="token string">"0 15 10 ? * *"</span> 每天上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 * * ?"</span> 每天上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 * * ? *"</span> 每天上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 * * ? 2005"</span> <span class="token number">2005</span>年的每天上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 * 14 * * ?"</span> 在每天下午<span class="token number">2</span>点到下午<span class="token number">2</span><span class="token operator">:</span><span class="token number">59</span>期间的每<span class="token number">1</span>分钟触发 <span class="token string">"0 0/5 14 * * ?"</span> 在每天下午<span class="token number">2</span>点到下午<span class="token number">2</span><span class="token operator">:</span><span class="token number">55</span>期间的每<span class="token number">5</span>分钟触发 <span class="token string">"0 0/5 14,18 * * ?"</span> 在每天下午<span class="token number">2</span>点到<span class="token number">2</span><span class="token operator">:</span><span class="token number">55</span>期间和下午<span class="token number">6</span>点到<span class="token number">6</span><span class="token operator">:</span><span class="token number">55</span>期间的每<span class="token number">5</span>分钟触发 <span class="token string">"0 0-5 14 * * ?"</span> 在每天下午<span class="token number">2</span>点到下午<span class="token number">2</span><span class="token operator">:</span><span class="token number">05</span>期间的每<span class="token number">1</span>分钟触发 <span class="token string">"0 10,44 14 ? 3 WED"</span> 每年三月的星期三的下午<span class="token number">2</span><span class="token operator">:</span><span class="token number">10</span>和<span class="token number">2</span><span class="token operator">:</span><span class="token number">44</span>触发 <span class="token string">"0 15 10 ? * MON-FRI"</span> 周一至周五的上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 15 * ?"</span> 每月<span class="token number">15</span>日上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 L * ?"</span> 每月最后一日的上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 ? * 6L"</span> 每月的最后一个星期五上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 ? * 6L 2002-2005"</span> <span class="token number">2002</span>年至<span class="token number">2005</span>年的每月的最后一个星期五上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span class="token string">"0 15 10 ? * 6#3"</span> 每月的第三个星期五上午<span class="token number">10</span><span class="token operator">:</span><span class="token number">15</span>触发 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-要点"><a href="#4-要点" class="headerlink" title="4.要点"></a>4.要点</h3><ul><li>一般是有6个位置，分别表示 <strong>分 秒 时 天(月) 月 天(周)</strong>   第7个位置是年，一般省略</li><li>6个位置中的 <strong>天(月)</strong> 表示一个月中的第几天，即是几月几号中的几号；<strong>天(周)</strong> 表示一周中的第几天，周日为第一天，周六为第七天</li><li>**天(月)<strong>和</strong>天(周)**不能同时指定，其中必定有一个是 <strong>?</strong></li><li><strong>?</strong> 只能用在 <strong>天(月)<strong>和</strong>天(周)</strong></li><li>2-10：符号  <strong>-</strong>  表示范围区间</li><li>2/10：符号  <strong>/</strong>  表示频率，从2开始，每隔10，即2，12，22……类推</li><li>2,10：符号  <strong>,</strong>  表示和，<code>2,10</code>表示2和10</li><li>L：last的缩写，表示最后，只能用在<strong>天(月)<strong>和</strong>天(周)<strong>，一般和数字搭配使用，如L在天(月)中表示一个月中的最后一天，</strong>L-1</strong>则表示<strong>每个月的倒数第二天</strong>；3L在天(周)中则表示最后一个星期二</li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> cron表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之视图解析器</title>
      <link href="2021/05/21/springboot-zhi-shi-tu-jie-xi-qi/"/>
      <url>2021/05/21/springboot-zhi-shi-tu-jie-xi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot之视图解析器"><a href="#springboot之视图解析器" class="headerlink" title="springboot之视图解析器"></a>springboot之视图解析器</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>在springmvc中在web.xml配置完dispatcherServlet之后还有一个非常重要的步骤就是在application.xml文件中添加视图解析器ViewResolver的配置，如下：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--添加视图解析器--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>InternalResourceViewResolver<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--前缀--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/WEB-INF/jsp/<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!--后缀--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在springboot中没有了配置，那么springboot是怎么帮我们添加视图解析器的呢？我们通过源码来探析。</p><h3 id="2-源码探析"><a href="#2-源码探析" class="headerlink" title="2. 源码探析"></a>2. 源码探析</h3><p>通过官方文档我们发现springboot自带了两个视图解析器<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code></p><p>并且在我们导入thymeleaf模板引擎之后，thymeleaf也自带了视图解析器，默认路径是templates包下</p><p>查看ContentNegotiatingViewResolver和BeanNameViewResolver，发现这两个类都实现了一个公共接口ViewResolver。也都重写了接口方法resolveViewName</p><p>下面是ContentNegotiatingViewResolver重写的resolveViewName方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">View</span> <span class="token function">resolveViewName</span><span class="token punctuation">(</span><span class="token class-name">String</span> viewName<span class="token punctuation">,</span> <span class="token class-name">Locale</span> locale<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RequestAttributes</span> attrs <span class="token operator">=</span> <span class="token class-name">RequestContextHolder</span><span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>attrs <span class="token keyword">instanceof</span> <span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">,</span> <span class="token string">"No current ServletRequestAttributes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MediaType</span><span class="token punctuation">></span></span> requestedMediaTypes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMediaTypes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span>attrs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>requestedMediaTypes <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//重点就在这两行代码，它会通过getCandidateViews获取所有候选的视图解析器，</span>        <span class="token comment">//并通过getBestView选择最好的视图解析器</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">View</span><span class="token punctuation">></span></span> candidateViews <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCandidateViews</span><span class="token punctuation">(</span>viewName<span class="token punctuation">,</span> locale<span class="token punctuation">,</span> requestedMediaTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">View</span> bestView <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBestView</span><span class="token punctuation">(</span>candidateViews<span class="token punctuation">,</span> requestedMediaTypes<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bestView <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> bestView<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是BeanNameViewResolver重写的resolveViewName方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">View</span> <span class="token function">resolveViewName</span><span class="token punctuation">(</span><span class="token class-name">String</span> viewName<span class="token punctuation">,</span> <span class="token class-name">Locale</span> locale<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">obtainApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>context<span class="token punctuation">.</span><span class="token function">containsBean</span><span class="token punctuation">(</span>viewName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>context<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>viewName<span class="token punctuation">,</span> <span class="token class-name">View</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Found bean named '"</span> <span class="token operator">+</span> viewName <span class="token operator">+</span> <span class="token string">"' but it does not implement View"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">View</span><span class="token punctuation">)</span>context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>viewName<span class="token punctuation">,</span> <span class="token class-name">View</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-自定义视图解析器"><a href="#3-自定义视图解析器" class="headerlink" title="3. 自定义视图解析器"></a>3. 自定义视图解析器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//拓展springmvc配置</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">ViewResolver</span> <span class="token function">myViewResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyViewResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//自定义了一个自己的视图解析器MyViewResolver</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyViewResolver</span> <span class="token keyword">implements</span> <span class="token class-name">ViewResolver</span><span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">View</span> <span class="token function">resolveViewName</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">Locale</span> locale<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>双击shift找到DispatcherServlet类，ctrl+F找到doDispatch方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DispatcherServlet</span> <span class="token keyword">extends</span> <span class="token class-name">FrameworkServlet</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doDispatch</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在doDispatch方法上打上断点，并进行Debug，会有以下图：</p><img src="/2021/05/21/springboot-zhi-shi-tu-jie-xi-qi/1.png" class title="自定义视图解析器Debug图"><p>可以看到，我们的自定义视图解析器被springboot自动扫描上了</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 视图解析器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之首页配置</title>
      <link href="2021/05/21/springboot-zhi-shou-ye/"/>
      <url>2021/05/21/springboot-zhi-shou-ye/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot之首页配置"><a href="#springboot之首页配置" class="headerlink" title="springboot之首页配置"></a>springboot之首页配置</h2><p>在<code>WebMvcAutoConfiguration</code>中有如下方法有关首页配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">WelcomePageHandlerMapping</span> <span class="token function">welcomePageHandlerMapping</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">,</span> <span class="token class-name">FormattingConversionService</span> mvcConversionService<span class="token punctuation">,</span> <span class="token class-name">ResourceUrlProvider</span> mvcResourceUrlProvider<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//重点在于this.getWelcomePage()</span>    <span class="token class-name">WelcomePageHandlerMapping</span> welcomePageHandlerMapping <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WelcomePageHandlerMapping</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TemplateAvailabilityProviders</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">,</span> applicationContext<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getWelcomePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getStaticPathPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    welcomePageHandlerMapping<span class="token punctuation">.</span><span class="token function">setInterceptors</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getInterceptors</span><span class="token punctuation">(</span>mvcConversionService<span class="token punctuation">,</span> mvcResourceUrlProvider<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    welcomePageHandlerMapping<span class="token punctuation">.</span><span class="token function">setCorsConfigurations</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCorsConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> welcomePageHandlerMapping<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>this.getWelcomePage()</code>方法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Resource</span> <span class="token function">getWelcomePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getStaticLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> var2<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> location <span class="token operator">=</span> var1<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//获取首页</span>        <span class="token class-name">Resource</span> indexHtml <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIndexHtml</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>indexHtml <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> indexHtml<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">ServletContext</span> servletContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>servletContext <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIndexHtml</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Resource</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServletContextResource</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//根据首页位置获取首页</span><span class="token keyword">private</span> <span class="token class-name">Resource</span> <span class="token function">getIndexHtml</span><span class="token punctuation">(</span><span class="token class-name">String</span> location<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIndexHtml</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">Resource</span> <span class="token function">getIndexHtml</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> location<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//首页url为/index.html</span>        <span class="token class-name">Resource</span> resource <span class="token operator">=</span> location<span class="token punctuation">.</span><span class="token function">createRelative</span><span class="token punctuation">(</span><span class="token string">"index.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resource<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> resource<span class="token punctuation">.</span><span class="token function">getURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> resource<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var3<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 首页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spingboot之静态资源导出原理</title>
      <link href="2021/05/13/spingboot-jing-tai-zi-yuan-dao-chu-yuan-li-tan-jiu/"/>
      <url>2021/05/13/spingboot-jing-tai-zi-yuan-dao-chu-yuan-li-tan-jiu/</url>
      
        <content type="html"><![CDATA[<h2 id="spingboot静态资源导出原理探究"><a href="#spingboot静态资源导出原理探究" class="headerlink" title="spingboot静态资源导出原理探究"></a>spingboot静态资源导出原理探究</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>springboot相较于springmvc没有了webapp这个目录文件夹，那么springboot中静态资源应该存放在哪呢？</p><p>接下来我们通过探析源码的方式来解决这个问题</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//添加资源处理的方法</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addResourceHandlers</span><span class="token punctuation">(</span><span class="token class-name">ResourceHandlerRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">addResourceHandlers</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">isAddMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//如果自定义了静态资源处理，即在.properties或者.yaml文件中</span>        <span class="token comment">//即配置这个属性spring.mvc.static-path-pattern=/**</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Default resource handling disabled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ServletContext</span> servletContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//第一种是通过webjars下寻找</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token string">"/webjars/**"</span><span class="token punctuation">,</span> <span class="token string">"classpath:/META-INF/resources/webjars/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//第二种是通过getStaticLocations()获取this.staticLocations，</span>        <span class="token comment">//而this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span>        <span class="token comment">//CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;"classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"&#125;;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getStaticPathPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>registration<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            registration<span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getStaticLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>servletContext <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                registration<span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">ServletContextResource</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种方法：webjars，在pom文件中加入以下依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.webjars<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jquery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在lib中就会有以下结构的包</p><img src="/2021/05/13/spingboot-jing-tai-zi-yuan-dao-chu-yuan-li-tan-jiu/1.png" class title="webjars结构图及对应关系"><p>通过访问localhost:8080/webjars/jquery/3.6.0/jquery.js即可访问静态资源，但是一般不这么用</p><p>第二种方法：放在”classpath:/resources/“, “classpath:/static/“, “classpath:/public/“这三个路径下</p><p>目录结构如下</p><img src="/2021/05/13/spingboot-jing-tai-zi-yuan-dao-chu-yuan-li-tan-jiu/2.png" class title="静态资源存储路径"><p>访问路径为:localhost:8080/1.js</p><p>其中访问优先度为resources&gt;static&gt;public</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之@SpringBootApplication</title>
      <link href="2021/05/13/springboot-zhu-jie-springbootapplication/"/>
      <url>2021/05/13/springboot-zhu-jie-springbootapplication/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot-SpringBootApplication"><a href="#springboot-SpringBootApplication" class="headerlink" title="springboot-@SpringBootApplication"></a>springboot-@SpringBootApplication</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p><code>springboot</code>与<code>spring</code>的区别有两个地方：</p><p>（1）在<code>Springboot01HelloworldApplication</code>主启动类上添加了注解<code>@SpringBootApplication</code></p><p>（2）main方法调用了<code>SpringApplication.run(Springboot01HelloworldApplication.class, args);</code></p><p>这里主要先解析第一点。</p><h3 id="2-进入主题"><a href="#2-进入主题" class="headerlink" title="2.进入主题"></a>2.进入主题</h3><p>主启动类源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot01HelloworldApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Springboot01HelloworldApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@SpringBootApplication</code>是<code>Sprnig Boot</code>项目的核心注解，目的是开启自动配置。</p><p>进入到<code>@SpringBootApplication</code>的源码，可以看到里面组合了三个我们感兴趣的注解：<code>@ComponentScan</code>,<code>@EnableAutoConfiguration</code>,<code>@SpringBootConfiguration</code>.我们一一分析这三个注解．</p><h4 id="2-1-ComponentScan"><a href="#2-1-ComponentScan" class="headerlink" title="2.1@ComponentScan"></a>2.1@ComponentScan</h4><p>使用过spring框架的小伙伴都知道，spring里有四大注解：<code>@Service</code>,<code>@Repository</code>,<code>@Component</code>,<code>@Controller</code>用来定义一个bean.<code>@ComponentScan</code>注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean．可以通过设置<code>@ComponentScan</code>　basePackages，includeFilters，excludeFilters属性来动态确定自动扫描范围．如果不设置的话，spring默认的扫描范围是<code>@ComponentScan</code>注解所在配置类包及子包的类，</p><blockquote><p>注：使用<code>@SpringBootApplication</code>注解，就说明你使用了<code>@ComponentScan</code>的默认配置，这就建议你把使用<code>@SpringBootApplication</code>注解的类放置在root package，其他类都置在root package的子包里面，这样bean就不会被漏扫描</p></blockquote><p><code>@ComponentScan</code>的参数的作用</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">basePackageClasses：对basepackages<span class="token punctuation">(</span><span class="token punctuation">)</span>指定扫描注释组件包类型安全的替代。 excludeFilters：指定不适合组件扫描的类型。 includeFilters：指定哪些类型有资格用于组件扫描。 lazyInit：指定是否应注册扫描的beans为lazy初始化。 nameGenerator：用于在Spring容器中的检测到的组件命名。 resourcePattern：控制可用于组件检测的类文件。 scopedProxy：指出代理是否应该对检测元件产生，在使用过程中会在代理风格时尚的范围是必要的。 scopeResolver：用于解决检测到的组件的范围。 useDefaultFilters：指示是否自动检测类的注释 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-SpringBootConfiguration"><a href="#2-2-SpringBootConfiguration" class="headerlink" title="2.2@SpringBootConfiguration"></a>2.2@SpringBootConfiguration</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>        annotation <span class="token operator">=</span> <span class="token class-name">Configuration</span><span class="token punctuation">.</span><span class="token keyword">class</span>    <span class="token punctuation">)</span>    <span class="token keyword">boolean</span> <span class="token function">proxyBeanMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个注解的作用与<code>@Configuration</code>作用相同，都是用来声明当前类是一个配置类．可以通过<code>＠Bean</code>注解生成IOC容器管理的bean.</p><p>例子：在<code>Springboot01HelloworldApplication</code>中定义bean，并在<code>＠HelloController</code>中注入使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot01HelloworldApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Springboot01HelloworldApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">BeanTest</span> <span class="token function">beanTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BeanTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>HelloController</code>中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">BeanTest</span> beanTest<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/test"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">beanTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> beanTest<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-EnableAutoConfiguration"><a href="#2-3-EnableAutoConfiguration" class="headerlink" title="2.3@EnableAutoConfiguration"></a>2.3@EnableAutoConfiguration</h4><p><code>@EnableAutoConfiguration</code>是springboot实现自动化配置的核心注解，通过这个注解把spring应用所需的bean注入容器中．<code>@EnableAutoConfiguration</code>源码通过<code>@Import</code>注入了一个<code>ImportSelector</code>的实现类<code>AutoConfigurationImportSelector</code>,这个<code>ImportSelector</code>最终实现根据我们的配置，动态加载所需bean.</p><p>我们首先看<code>AutoConfigurationImportSelector</code>的<code>selectImports</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> NO_IMPORTS<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//重点在getAutoConfigurationEntry方法</span>    <span class="token class-name">AutoConfigurationEntry</span> autoConfigurationEntry <span class="token operator">=</span> <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//返回需要注入的bean的类路径</span>    <span class="token keyword">return</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getAutoConfigurationEntry</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//输入参数:annotationMetadata 是＠import所用在的注解．这里指定是@EnableAutoConfiguration</span><span class="token keyword">protected</span> <span class="token class-name">AutoConfigurationEntry</span> <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> EMPTY_ENTRY<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//获取注解里设置的属性，在＠SpringBootApplication设置的exclude,excludeName属性值，其实就是设置＠EnableAutoConfiguration的这两个属性值</span><span class="token class-name">AnnotationAttributes</span> attributes <span class="token operator">=</span> <span class="token function">getAttributes</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//这里getCandidateConfigurations调用了一个核心方法SpringFactoriesLoader.loadFactoryNames</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> configurations <span class="token operator">=</span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//去掉重复项</span>configurations <span class="token operator">=</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取自己配置的不需要生成bean的class</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> exclusions <span class="token operator">=</span> <span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//校验被exclude的类是否都是springboot自动化配置里的类</span><span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//删除被exclude掉的类</span>configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//过滤刷选，满足OnClassCondition的类</span>configurations <span class="token operator">=</span> <span class="token function">getConfigurationClassFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationEntry</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>getCandidateConfigurations</code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">AnnotationAttributes</span> attributes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//getSpringFactoriesLoaderFactoryClass()返回的是EnableAutoConfiguration.class</span>    <span class="token comment">//getBeanClassLoader()返回的是this.beanClassLoader</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> configurations <span class="token operator">=</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> <span class="token string">"No auto configuration classes found in META-INF/spring.factories. If you "</span><span class="token operator">+</span> <span class="token string">"are using a custom packaging, make sure that file is correct."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> configurations<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>SpringFactoriesLoader.loadFactoryNames</code>方法</p><p><strong>自动配置幕后英雄：<code>SpringFactoriesLoader</code>详解</strong><br><code>SpringFactoriesLoader</code>属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件<code>META-INF/spring.factories</code>加载配置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> factoryType<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ClassLoader</span> classLoaderToUse <span class="token operator">=</span> classLoader<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>classLoaderToUse <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>classLoaderToUse <span class="token operator">=</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">String</span> factoryTypeName <span class="token operator">=</span> factoryType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">loadSpringFactories</span><span class="token punctuation">(</span>classLoaderToUse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>factoryTypeName<span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">loadSpringFactories</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";</span>            <span class="token comment">//从spring-boot-autoconfigure　jar包里面META-INF/spring.factories加载配置类的名称，打开这个文件发现里面包含了springboot框架提供的所有配置类</span><span class="token class-name">Enumeration</span><span class="token generics"><span class="token punctuation">&lt;</span>URL<span class="token punctuation">></span></span> urls <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">URL</span> url <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">UrlResource</span> resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token class-name">PropertiesLoaderUtils</span><span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> properties<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> factoryTypeName <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> factoryImplementationNames <span class="token operator">=</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> factoryImplementationName <span class="token operator">:</span> factoryImplementationNames<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>factoryTypeName<span class="token punctuation">,</span> key <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>factoryImplementationName<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将所有列表替换为包含唯一元素的不可修改列表</span>result<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token punctuation">(</span>factoryType<span class="token punctuation">,</span> implementations<span class="token punctuation">)</span> <span class="token operator">-></span> implementations<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">collectingAndThen</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token operator">::</span><span class="token function">unmodifiableList</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unable to load factories from location ["</span> <span class="token operator">+</span>FACTORIES_RESOURCE_LOCATION <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> 注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot之@Import</title>
      <link href="2021/05/13/spring-zhu-jie-import/"/>
      <url>2021/05/13/spring-zhu-jie-import/</url>
      
        <content type="html"><![CDATA[<h2 id="spring-Import注解的作用"><a href="#spring-Import注解的作用" class="headerlink" title="spring-@Import注解的作用"></a>spring-@Import注解的作用</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>在平时看源码或者很多配置类上面都会出现@Import注解,功能就是和Spring XML 里面 的 一样. @Import注解是用来导入配置类或者一些需要前置加载的类.</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h3><h4 id="2-1-导入配置的三种类型"><a href="#2-1-导入配置的三种类型" class="headerlink" title="2.1 导入配置的三种类型"></a>2.1 导入配置的三种类型</h4><p>@Import支持 三种方式<br> 1.带有@Configuration的配置类(4.2 版本之前只可以导入配置类，4.2版本之后 也可以导入 普通类)<br> 2.ImportSelector 的实现<br> 3.ImportBeanDefinitionRegistrar 的实现</p><h4 id="2-2-源码解析"><a href="#2-2-源码解析" class="headerlink" title="2.2 源码解析"></a>2.2 源码解析</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 表示要导入的一个或多个component类，尤其是带有@Configuration的类 * Indicates one or more component classes to import; typically * @Configuration classes. * * 功能类似XML 里面的 &lt;import/> * 可以导入 @Configuration配置类，ImportSelector、ImportBeanDefinitionRegistrar 的实现 * 4.2 版本之后可以导入普通component类(类似AnnotationConfigApplicationContext#register) * &lt;p>Provides functionality equivalent to the &#123;@code &lt;import/>&#125; element in Spring XML. * Allows for importing &#123;@code @Configuration&#125; classes, &#123;@link ImportSelector&#125; and * &#123;@link ImportBeanDefinitionRegistrar&#125; implementations, as well as regular component * classes (as of 4.2; analogous to &#123;@link AnnotationConfigApplicationContext#register&#125;). * * &lt;p>&#123;@code @Bean&#125; definitions declared in imported &#123;@code @Configuration&#125; classes should be * accessed by using &#123;@link org.springframework.beans.factory.annotation.Autowired @Autowired&#125; * injection. Either the bean itself can be autowired, or the configuration class instance * declaring the bean can be autowired. The latter approach allows for explicit, IDE-friendly * navigation between &#123;@code @Configuration&#125; class methods. * 可以在类级别声明或作为元注释声明 * &lt;p>May be declared at the class level or as a meta-annotation. * 如需要引入XML或其他类型的文件，使用@ImportResource注解 * &lt;p>If XML or other non-&#123;@code @Configuration&#125; bean definition resources need to be * imported, use the &#123;@link ImportResource @ImportResource&#125; annotation instead. */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Import</span> <span class="token punctuation">&#123;</span><span class="token comment">/** * &#123;@link Configuration @Configuration&#125;, &#123;@link ImportSelector&#125;, * &#123;@link ImportBeanDefinitionRegistrar&#125;, or regular component classes to import. */</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-测试例子"><a href="#3-测试例子" class="headerlink" title="3.测试例子"></a>3.测试例子</h3><h4 id="3-1-导入普通类"><a href="#3-1-导入普通类" class="headerlink" title="3.1 导入普通类"></a>3.1 导入普通类</h4><p>1.新建一个普通类TestA</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类名:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.新建一个ImportConfig类，在类上加@Configuration，加上@Configuration是为了能让Spring 扫描到这个类，并且直接通过@Import引入TestA类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">TestA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImportConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3.测试结果</p><p>TestA 是一个普通的类，现在可以被@Autowired注释然后调用，就直接说明已经被Spring 注入并管理了，普通的类都是需要先实例化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringJUnit4ClassRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">AnnotationTestApplicationTests</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">TestA</span> testA<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        testA<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印：</p><pre class="line-numbers language-jav" data-language="jav"><code class="language-jav">类名:com.itxxj.annotationtest.TestA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-2-导入带有-Configuration的配置类"><a href="#3-2-导入带有-Configuration的配置类" class="headerlink" title="3.2 导入带有@Configuration的配置类"></a>3.2 导入带有@Configuration的配置类</h4><p>1.新建一个普通类TestB</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestB</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类名:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.在ImportConfig中直接引入TestB</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">TestA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">TestB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImportConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3.测试结果</p><p>TestB.class 的类上面已经有了@Configuration注解,本身就会被spring扫到并实例，@import引入带有@Configuration的配置文件，是需要先实例这个配置文件再进行相关操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token class-name">TestB</span> testB<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    testB<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">类名<span class="token operator">:</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>itxxj<span class="token punctuation">.</span>annotationtest<span class="token punctuation">.</span></span>TestB</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-3-通过ImportSelector方式导入类"><a href="#3-3-通过ImportSelector方式导入类" class="headerlink" title="3.3 通过ImportSelector方式导入类"></a>3.3 通过ImportSelector方式导入类</h4><p>1.新建TestC.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestC</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类名:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.新建SelfImportSelector.class 实现ImportSelector 接口,注入TestC.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelfImportSelector</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"com.itxxj.annotationtest.TestC"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.ImportConfig上面引入SelfImportSelector.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">TestA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">TestB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">SelfImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImportConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4.测试结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token class-name">TestC</span> testC<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    testC<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">类名<span class="token operator">:</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>itxxj<span class="token punctuation">.</span>annotationtest<span class="token punctuation">.</span></span>TestC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-4-通过-ImportBeanDefinitionRegistrar-方式导入的类"><a href="#3-4-通过-ImportBeanDefinitionRegistrar-方式导入的类" class="headerlink" title="3.4 通过 ImportBeanDefinitionRegistrar 方式导入的类"></a>3.4 通过 ImportBeanDefinitionRegistrar 方式导入的类</h4><p>1.新建TestD.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestD</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类名:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.新建SelfImportBeanDefinitionRegistrar.class,实现接口ImportBeanDefinitionRegistrar,注入TestD.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelfImportBeanDefinitionRegistrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RootBeanDefinition</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span><span class="token class-name">TestD</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"testD"</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.ImportConfig类上加上导入SelfImportBeanDefinitionRegistrar.class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">TestA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">TestB</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">SelfImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">SelfImportBeanDefinitionRegistrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImportConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4.测试结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token class-name">TestD</span> testD<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    testD<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">类名<span class="token operator">:</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>itxxj<span class="token punctuation">.</span>annotationtest<span class="token punctuation">.</span></span>TestD</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-详细过程解析"><a href="#4-详细过程解析" class="headerlink" title="4.详细过程解析"></a>4.详细过程解析</h3><blockquote><pre class="line-numbers language-none"><code class="language-none">ConfigurationClassParser所在包:org.springframework.context.annotation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>这里主要看 ConfigurationClassParser.java 里面的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Process any @Import annotations</span><span class="token function">processImports</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> sourceClass<span class="token punctuation">,</span> <span class="token function">getImports</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">)</span><span class="token punctuation">,</span> filter<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//具体在311行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-1-getImport方法"><a href="#4-1-getImport方法" class="headerlink" title="4.1 getImport方法"></a>4.1 getImport方法</h4><p>在分析这个方法之前，我们先看一下 getImports 方法，这个方法就是获取所有的@import 里面的类<br>这里是获取 @import 里面的类，大致流程如下：</p><ol><li>定义一个 visited 的集合，用作 是否已经 判断过的标志</li><li>这里就是获取sourceClass 上面的 所有的 annotation，并挨个判断， 如果不是 @import ,那就 进一步递归 调用 对应的 annotation,直到全部结束</li><li>加载sourceClass 里面 的@Import annotation 里面对应的类名 ,最后返回</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Returns &#123;@code @Import&#125; class, considering all meta-annotations. */</span><span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> <span class="token function">getImports</span><span class="token punctuation">(</span><span class="token class-name">SourceClass</span> sourceClass<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> imports <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">collectImports</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">,</span> imports<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> imports<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//这里就是获取sourceClass 上面的所有的 annotation， 如果不是 @import ,那就进一步递归调用对应的 annotation,直到全部结束</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">collectImports</span><span class="token punctuation">(</span><span class="token class-name">SourceClass</span> sourceClass<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> imports<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">></span></span> visited<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SourceClass</span> annotation <span class="token operator">:</span> sourceClass<span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> annName <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>annName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Import</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">collectImports</span><span class="token punctuation">(</span>annotation<span class="token punctuation">,</span> imports<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>imports<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">Import</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-processImports方法"><a href="#4-2-processImports方法" class="headerlink" title="4.2 processImports方法"></a>4.2 processImports方法</h4><p>processImports 这个方法 的代码逻辑也很清晰，流程图如下：</p><img src="/2021/05/13/spring-zhu-jie-import/1.png" class title="processImports逻辑流程"><p>大致的流程如下:</p><p>1.判断 importCandidates 是否为空，为空 退出</p><p>2.判断isChainedImportOnStack ，如果为true ,加入 problemReporter 里面的error ，并退出</p><p>3.把当前的 configClass 加入到 ImportStack里面，ImportStack 是继承了 ArrayDeque // TODO 和实现了 ImportRegistry// TODO</p><p>4.对 getImports 里面获取到的 需要import 的类 进行遍历 处理</p><blockquote><p>4.1 如果是 ImportSelector 类型，首先实例一个 ImportSelector 对象，然后 对其进行 Aware 扩展(如果 实现了 Aware 接口)</p><p>4.1.2 进一步判断 是否 是 DeferredImportSelector 类型，如果是 ，加入到 deferredImportSelectors 里面，最后处理 ，这里可以看一下 方法parse(Set configCandidates)， 里面最后一行才调用,这也就是 有的时候，如果想最后注入，就可以定义为deferredImportSelectors 类型</p><p>4.1.2 如果 不是 DeferredImportSelector 类型 ，那就 调用 selectImports 方法，获取到所有的需要 注入的类，这时 再次调用 processImports 方法，这里调用processImports 方法，其实 是把 这些需要注入的类当成普通的 @Configuration 处理</p></blockquote><p>5.如果是 ImportBeanDefinitionRegistrar 类型，这里也是 先实例一个对象，然后加入到 importBeanDefinitionRegistrars 里面，后续 会在 ConfigurationClassBeanDefinitionReader 这个类里面 的 loadBeanDefinitionsFromRegistrars 方法处理的<br>6.如果上面两种类型都不是，那就是当初普通的 带有@Configuration 的类进行处理了</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> 注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="2021/05/13/wei-fu-wu/"/>
      <url>2021/05/13/wei-fu-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><blockquote><p>简而言之，微服务架构风格是一种将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的进程中运行，并以轻量级机制（通常是 HTTP  资源  API）进行通信。</p><p>这些服务围绕业务功能构建，可通过全自动部署机制来独立部署。这些服务共用一个最小型的集中式管理，它们可以使用不同的编程语言编写，并使用不同的数据存储技术。</p></blockquote><p>单体(monolithic)（all in one）风格:</p><blockquote><p>单体应用程序被构建为单一单元。企业应用程序通常由三个部分构成：客户端用户界面（由用户机器上的浏览器中运行的 HTML 页面和 JS组成）、数据库（由许多表组成，通常是在关系型数据库中管理）系统、服务器端应用程序。服务器端应用程序处理 HTTP  请求，执行一些逻辑处理，从数据库检索和更新数据，选择数据并填充到要发送到浏览器的 HTML  视图中。这个服务器端应用程序是一个整体——那么发生任何更改都会影响到应用程序的构建和部署</p><p>优点：易于开发和测试，方便部署，当需要扩展的时候只需要把war包复制多份，然后放在多个服务器上，再做个负载均衡即可</p><p>缺点：在将更多应用程序部署到云的时候。变更周期被捆绑在一起——即使只是对应用程序的一小部分进行了更改，也需要重建和部署整个单体应用。随着时间的推移，通常很难保持良好的模块化结构。对系统进行扩展时，不得不扩展整个应用系统。</p></blockquote><p>微服务原文可见：<a href="https://www.martinfowler.com/articles/microservices.html">https://www.martinfowler.com/articles/microservices.html</a></p><p>微服务风格并不是新颖的或创新的，其根源至少可以追溯到 Unix 的设计原则</p><img src="/2021/05/13/wei-fu-wu/1.png" class title="微服务原理"><h2 id="从单体式架构到微服务架构"><a href="#从单体式架构到微服务架构" class="headerlink" title="从单体式架构到微服务架构"></a>从单体式架构到微服务架构</h2><h3 id="迁移到微服务综述"><a href="#迁移到微服务综述" class="headerlink" title="迁移到微服务综述"></a>迁移到微服务综述</h3><p>迁移单体式应用到微服务架构意味着一系列现代化过程，有点像这几代开发者一直在做的事情，实时上，当迁移时，我们可以重用一些想法。</p><p>一个策略是：不要大规模（big bang）重写代码（只有当你承担重建一套全新基于微服务的应用时候可以采用重写这种方法）。重写代码听起来很不错，但实际上充满了风险最终可能会失败，就如 Martin Fowler 所说：</p><blockquote><p>“the only thing a Big Bang rewrite guarantees is a Big Bang!”</p></blockquote><p>相反，应该采取逐步迁移单体式应用的策略，通过逐步生成微服务新应用，与旧的单体式应用集成，随着时间推移，单体式应用在整个架构中比例逐渐下降直到消失或者成为微服务架构一部分。这个策略有点像在高速路上限速到 70 迈对车做维护，尽管有挑战，但是比起重写的风险小很多。</p><p>Martin Fowler  将这种现代化策略成为绞杀（Strangler）应用，名字来源于雨林中的绞杀藤（strangler vine），也叫绞杀榕 (strangler  fig)。绞杀藤为了爬到森林顶端都要缠绕着大树生长，一段时间后，树死了，留下树形藤。这种应用也使用同一种模式，围绕着传统应用开发了新型微服务应用，传统应用会渐渐退出舞台。</p><p>我们来看看其他可行策略。</p><h3 id="策略-1——停止挖掘"><a href="#策略-1——停止挖掘" class="headerlink" title="策略 1——停止挖掘"></a>策略 1——停止挖掘</h3><p>Law of Holes 是说当自己进洞就应该停止挖掘。对于单体式应用不可管理时这是最佳建议。换句话说，应该停止让单体式应用继续变大，也就是说当开发新功能时不应该为旧单体应用添加新代码，最佳方法应该是将新功能开发成独立微服务。如下图所示：</p><img src="/2021/05/13/wei-fu-wu/2.png" class title="停止挖掘策略"><p>除了新服务和传统应用，还有两个模块，其一是请求路由器，负责处理入口（http）请求，有点像之前提到的 API 网关。路由器将新功能请求发送给新开发的服务，而将传统请求还发给单体式应用。</p><p>另外一个是胶水代码（glue code），将微服务和单体应用集成起来，微服务很少能独立存在，经常会访问单体应用的数据。胶水代码，可能在单体应用或者为服务或者二者兼而有之，负责数据整合。微服务通过胶水代码从单体应用中读写数据。</p><p>微服务有三种方式访问单体应用数据：</p><ul><li>换气单体应用提供的远程 API</li><li>直接访问单体应用数据库</li><li>自己维护一份从单体应用中同步的数据</li></ul><p>胶水代码也被称为容灾层（anti-corruption layer），这是因为胶水代码保护微服务全新域模型免受传统单体应用域模型污染。胶水代码在这两种模型间提供翻译功能。术语  anti-corruption layer 第一次出现在 Eric Evans 撰写的必读书 _Domain Driven  Design_，随后就被提炼为一篇白皮书。开发容灾层可能有点不是很重要，但却是避免单体式泥潭的必要部分。</p><p>将新功能以轻量级微服务方式实现由很多优点，例如可以阻止单体应用变的更加无法管理。微服务本身可以开发、部署和独立扩展。采用微服务架构会给开发者带来不同的切身感受。</p><p>然而，这方法并不解决任何单体式本身问题，为了解决单体式本身问题必须深入单体应用  做出改变。我们来看看这么做的策略。</p><h3 id="策略-2——将前端和后端分离"><a href="#策略-2——将前端和后端分离" class="headerlink" title="策略 2——将前端和后端分离"></a>策略 2——将前端和后端分离</h3><p>减小单体式应用复杂度的策略是讲表现层和业务逻辑、数据访问层分开。典型的企业应用至少有三个不同元素构成：</p><ol><li>表现层——处理 HTTP 请求，要么响应一个 RESTAPI 请求，要么是提供一个基于 HTML 的图形接口。对于一个复杂用户接口应用，表现层经常是代码重要的部分。</li><li>业务逻辑层——完成业务逻辑的应用核心。</li><li>数据访问层——访问基础元素，例如数据库和消息代理。</li></ol><p>在表现层与业务数据访问层之间有清晰的隔离。业务层有由若干方面组成的粗粒度（coarse-grained）的 API，内部包含了业务逻辑元素。API  是可以将单体业务分割成两个更小应用的天然边界，其中一个应用是表现层，另外一个是业务和数据访问逻辑。分割后，表现逻辑应用远程调用业务逻辑应用，下图表示迁移前后架构不同：</p><img src="/2021/05/13/wei-fu-wu/3.png" class title="前后端分离"><p>单体应用这么分割有两个好处，其一使得应用两部分开发、部署和扩展各自独立，特别地，允许表现层开发者在用户界面上快速选择，进行 A/B 测试；其二，使得一些远程 API 可以被微服务调用。</p><p>然而，这种策略只是部分的解决方案。很可能应用的两部分之一或者全部都是不可管理的，因此需要使用第三种策略来消除剩余的单体架构。</p><h3 id="策略-3——抽出服务"><a href="#策略-3——抽出服务" class="headerlink" title="策略 3——抽出服务"></a>策略 3——抽出服务</h3><p>第三种迁移策略就是从单体应用中抽取出某些模块成为独立微服务。每当抽取一个模块变成微服务，单体应用就变简单一些；一旦转换足够多的模块，单体应用本身已经不成为问题了，要么消失了，要么简单到成为一个服务。</p><h4 id="排序那个模块应该被转成微服务"><a href="#排序那个模块应该被转成微服务" class="headerlink" title="排序那个模块应该被转成微服务"></a>排序那个模块应该被转成微服务</h4><p>一个巨大的复杂单体应用由成十上百个模块构成，每个都是被抽取对象。决定第一个被抽取模块一般都是挑战，一般最好是从最容易抽取的模块开始，这会让开发者积累足够经验，这些经验可以为后续模块化工作带来巨大好处。</p><p>转换模块成为微服务一般很耗费时间，一般可以根据获益程度来排序，一般从经常变化模块开始会获益最大。一旦转换一个模块为微服务，就可以将其开发部署成独立模块，从而加速开发进程。</p><p>将资源消耗大户先抽取出来也是排序标准之一。例如，将内存数据库抽取出来成为一个微服务会非常有用，可以将其部署在大内存主机上。同样的，将对计算资源很敏感的算法应用抽取出来也是非常有益的，这种服务可以被部署在有很多 CPU 的主机上。通过将资源消耗模块转换成微服务，可以使得应用易于扩展。</p><p>查找现有粗粒度边界来决定哪个模块应该被抽取，也是很有益的，这使得移植工作更容易和简单。例如，只与其他应用异步同步消息的模块就是一个明显边界，可以很简单容易地将其转换为微服务。</p><h4 id="如何抽取模块"><a href="#如何抽取模块" class="headerlink" title="如何抽取模块"></a>如何抽取模块</h4><p>抽取模块第一步就是定义好模块和单体应用之间粗粒度接口，由于单体应用需要微服务的数据，反之亦然，因此更像是一个双向 API。因为必须在负责依赖关系和细粒度接口模式之间做好平衡，因此开发这种 API  很有挑战性，尤其对使用域模型模式的业务逻辑层来说更具有挑战，因此经常需要改变代码来解决依赖性问题，如图所示：</p><p>一旦完成粗粒度接口，也就将此模块转换成独立微服务。为了实现，必须写代码使得单体应用和微服务之间通过使用进程间通信（IPC）机制的 API 来交换信息。如图所示迁移前后对比：</p><img src="/2021/05/13/wei-fu-wu/4.png" class title="迁移前后对比"><p>此例中，正在使用 Y 模块的 Z 模块是备选抽取模块，其元素正在被 X 模块使用，迁移第一步就是定义一套粗粒度 APIs，第一个接口应该是被 X 模块使用的内部接口，用于激活 Z 模块；第二个接口是被 Z 模块使用的外部接口，用于激活 Y 模块。</p><p>迁移第二步就是将模块转换成独立服务。内部和外部接口都使用基于 IPC 机制的代码，一般都会将 Z 模块整合成一个微服务基础框架，来出来割接过程中的问题，例如服务发现。</p><p>抽取完模块，也就可以开发、部署和扩展另外一个服务，此服务独立于单体应用和其它服务。可以从头写代码实现服务；这种情况下，将服务和单体应用整合的 API  代码成为容灾层，在两种域模型之间进行翻译工作。每抽取一个服务，就朝着微服务方向前进一步。随着时间推移，单体应用将会越来越简单，用户就可以增加更多独立的微服务。 将现有应用迁移成微服务架构的现代化应用，不应该通过从头重写代码方式实现，相反，应该通过逐步迁移的方式。有三种策略可以考虑：将新功能以微服务方式实现；将表现层与业务数据访问层分离；将现存模块抽取变成微服务。随着时间推移，微服务数量会增加，开发团队的弹性和效率将会大大增加。</p><h2 id="微服务四大问题"><a href="#微服务四大问题" class="headerlink" title="微服务四大问题"></a>微服务四大问题</h2><blockquote><p>微服务架构问题</p><p>​    分布式架构会遇到的核心问题</p><pre><code>1. 这么多服务，客户端如何去访问（服务路由）2. 这么多服务，服务之间如何通信（异步调用）3. 这么多服务，如何治理（高可用）4. 服务挂了怎么办</code></pre></blockquote><h3 id="常见的两套解决方案"><a href="#常见的两套解决方案" class="headerlink" title="常见的两套解决方案"></a>常见的两套解决方案</h3><p><code>Spring Cloud</code>是一套生态，就是用来解决以上四个问题</p><ol><li><p><code>Spring Cloud Netflix</code> 第一套解决方案</p><p>针对第一个问题：API网关=》zuul组件</p><p>针对第二个问题：Feign=》HttpClient=》HTTP通信方式，同步并阻塞</p><p>针对第三个问题：服务注册与发现=》Eureka</p><p>针对第四个问题：熔断机制=》Hystrix</p></li><li><p><code>Apache Dubbo+Zookeeper</code> 第二套解决方案</p><p>针对第一个问题：API网关=》没有</p><p>针对第二个问题：Dubbo=》Java实现的高效RPC框架</p><p>针对第三个问题：服务注册与发现=》Zookeeper</p><p>针对第四个问题：熔断机制=》没有=&gt;借助Hystrix</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下mysql的rpm安装流程</title>
      <link href="2021/04/30/linux-xia-mysql-de-rpm-an-zhuang-liu-cheng/"/>
      <url>2021/04/30/linux-xia-mysql-de-rpm-an-zhuang-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步、前往mysql官网下载所需的版本"><a href="#第一步、前往mysql官网下载所需的版本" class="headerlink" title="第一步、前往mysql官网下载所需的版本"></a>第一步、前往mysql官网下载所需的版本</h2><blockquote><p>Mysql5.7的rpm包下载地址为<a href="https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar">https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</a></p><p>下载完成后就上传的CentOS系统上。</p></blockquote><h2 id="第二步、解压安装"><a href="#第二步、解压安装" class="headerlink" title="第二步、解压安装"></a>第二步、解压安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># mkdir mysql #创建mysql目录</span><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># tar xf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar -C mysql/ #解压至mysql目录下</span><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># yum -y install make gcc-c++ cmake bison ncurses-devel libaio libaio-devel net-tools #安装依赖包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于CentOS7（但是在CentOS8中好像没有，不过还是走一下流程)开始自带的数据库是mariadb，所以需要卸载系统中的mariadb组件，才能安装mysql的组件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># rpm -qa | grep mariadb #查看是否有mariadb</span><span class="token punctuation">[</span>root@xiaoxiangjie xiaoxiangjie<span class="token punctuation">]</span><span class="token comment"># yum -y remove mariadb-libs #卸载</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在开始安装mysql，由于依赖关系，所以顺序是固定的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm </span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm</span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-libs-compat-5.7.26-1.el7.x86_64.rpm </span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm </span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm </span>在安装mysql-community-server-5.7.26-1.el7.x86_64.rpm的时候出现如下错误：error: Failed dependencies:perl<span class="token punctuation">(</span>Getopt::Long<span class="token punctuation">)</span> is needed by mysql-community-server-5.7.26-1.el7.x86_64安装perl<span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># yum -y install perl</span>又出现问题：<span class="token punctuation">[</span>/usr/lib/tmpfiles.d/mysql.conf:16<span class="token punctuation">]</span> Line references path below legacy directory /var/run/, updating /var/run/mysqld → /run/mysqld<span class="token punctuation">;</span> please update the tmpfiles.d/ drop-in <span class="token function">file</span> accordingly.解决方案：<span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># vim /usr/lib/tmpfiles.d/mysql.conf #在16行将/var/run/mysqld改为/run/mysqld</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动数据库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#启动MySQL</span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># systemctl start mysqld</span><span class="token comment">#设置为开机自启</span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># systemctl enable mysqld</span><span class="token comment">#查看MySQL运行状态，运行状态如下</span><span class="token punctuation">[</span>root@xiaoxiangjie mysql<span class="token punctuation">]</span><span class="token comment"># systemctl status mysqld</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时MySQL已经正常运行，不过要想进入MySQL还得找出此时root用户的密码，通过以下命令可以在日志文件中找出密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># grep "password" /var/log/mysqld.log</span><span class="token number">2021</span>-04-28T08:44:07.870764Z <span class="token number">1</span> <span class="token punctuation">[</span>Note<span class="token punctuation">]</span> A temporary password is generated <span class="token keyword">for</span> root@localhost: J_<span class="token punctuation">;</span>TswJ<span class="token operator">&amp;</span>P3Xx <span class="token comment">#J_;TswJ&amp;P3Xx就是密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如下命令登录数据库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># mysql -uroot -p</span>Enter password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库，如下命令修改密码：</p><pre class="line-numbers language-mys" data-language="mys"><code class="language-mys">mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中‘new password’替换成你要设置的密码，注意:密码设置必须要<strong>大小写字母数字和特殊符号（,/‘;:等）</strong>,不然不能配置成功。</p><pre class="line-numbers language-my" data-language="my"><code class="language-my">mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Root28.&#x2F;&#39;;Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果出现如下错误：</p><pre class="line-numbers language-mysq" data-language="mysq"><code class="language-mysq">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是因为密码的复杂度不符合默认规定(还是需要先修改密码成功后)，如下命令查看mysql默认密码复杂度：</p><pre class="line-numbers language-mysq" data-language="mysq"><code class="language-mysq">mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;+--------------------------------------+--------+| Variable_name                        | Value  |+--------------------------------------+--------+| validate_password_check_user_name    | OFF    || validate_password_dictionary_file    |        || validate_password_length             | 8      || validate_password_mixed_case_count   | 1      || validate_password_number_count       | 1      || validate_password_policy             | MEDIUM || validate_password_special_char_count | 1      |+--------------------------------------+--------+7 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如需修改密码复杂度参考如下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">></span> <span class="token builtin class-name">set</span> global <span class="token assign-left variable">validate_password_policy</span><span class="token operator">=</span>LOW<span class="token punctuation">;</span> <span class="token comment">#修改验证策略</span>Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> SHOW VARIABLES LIKE <span class="token string">'validate_password%'</span><span class="token punctuation">;</span>+--------------------------------------+-------+<span class="token operator">|</span> Variable_name                        <span class="token operator">|</span> Value <span class="token operator">|</span>+--------------------------------------+-------+<span class="token operator">|</span> validate_password_check_user_name    <span class="token operator">|</span> OFF   <span class="token operator">|</span><span class="token operator">|</span> validate_password_dictionary_file    <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">|</span> validate_password_length             <span class="token operator">|</span> <span class="token number">8</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_mixed_case_count   <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_number_count       <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_policy             <span class="token operator">|</span> LOW   <span class="token operator">|</span> <span class="token comment">#修改为LOW后就只验证密码的长度了</span><span class="token operator">|</span> validate_password_special_char_count <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span>+--------------------------------------+-------+<span class="token number">7</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token builtin class-name">set</span> global <span class="token assign-left variable">validate_password_length</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">#修改密码验证的长度</span>Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> SHOW VARIABLES LIKE <span class="token string">'validate_password%'</span><span class="token punctuation">;</span>+--------------------------------------+-------+<span class="token operator">|</span> Variable_name                        <span class="token operator">|</span> Value <span class="token operator">|</span>+--------------------------------------+-------+<span class="token operator">|</span> validate_password_check_user_name    <span class="token operator">|</span> OFF   <span class="token operator">|</span><span class="token operator">|</span> validate_password_dictionary_file    <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">|</span> validate_password_length             <span class="token operator">|</span> <span class="token number">4</span>     <span class="token operator">|</span> <span class="token comment">#密码长度验证修改成功</span><span class="token operator">|</span> validate_password_mixed_case_count   <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_number_count       <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span><span class="token operator">|</span> validate_password_policy             <span class="token operator">|</span> LOW   <span class="token operator">|</span><span class="token operator">|</span> validate_password_special_char_count <span class="token operator">|</span> <span class="token number">1</span>     <span class="token operator">|</span>+--------------------------------------+-------+<span class="token number">7</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时再修改你想要的简单密码</p><pre class="line-numbers language-mys" data-language="mys"><code class="language-mys">mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第三步、开启mysql远程访问"><a href="#第三步、开启mysql远程访问" class="headerlink" title="第三步、开启mysql远程访问"></a>第三步、开启mysql远程访问</h2><p>执行以下命令开启远程访问限制</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select user,host from user;+---------------+---------------+| user          | host          |+---------------+---------------+| root          | 39.106.63.239 || mysql.session | localhost     || mysql.sys     | localhost     || root          | localhost     |+---------------+---------------+4 rows in set (0.00 sec)mysql&gt; update user set host&#x3D;&#39;%&#39; where user&#x3D;&#39;root&#39;;ERROR 1062 (23000): Duplicate entry &#39;%-root&#39; for key &#39;PRIMARY&#39; #虽然报错了，但是查看mysql表发现修改成功了mysql&gt; select user,host from user;+---------------+---------------+| user          | host          |+---------------+---------------+| root          | %             || root          | 39.106.63.239 || mysql.session | localhost     || mysql.sys     | localhost     |+---------------+---------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再输入下面两行命令</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; flush privileges;mysql&gt; quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第四步、开启防火墙端口"><a href="#第四步、开启防火墙端口" class="headerlink" title="第四步、开启防火墙端口"></a>第四步、开启防火墙端口</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --list-ports #查看已经开启的端口</span><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --permanent --add-port=3306/tcp #开放3306端口</span><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># firewall-cmd --reload #添加端口后，需要重新加载</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="第五步、更改mysql的语言"><a href="#第五步、更改mysql的语言" class="headerlink" title="第五步、更改mysql的语言"></a>第五步、更改mysql的语言</h2><p>首先重新登录mysql，然后输入status：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; status--------------mysql  Ver 14.14 Distrib 5.7.26, for Linux (x86_64) using  EditLine wrapperConnection id:2Current database:Current user:root@localhostSSL:Not in useCurrent pager:stdoutUsing outfile:&#39;&#39;Using delimiter:;Server version:5.7.26 MySQL Community Server (GPL)Protocol version:10Connection:Localhost via UNIX socketServer characterset:latin1  #不是utf-8Db     characterset:latin1  #不是utf-8Client characterset:utf8Conn.  characterset:utf8UNIX socket:&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sockUptime:46 secThreads: 1  Questions: 5  Slow queries: 0  Opens: 105  Flush tables: 1  Open tables: 98  Queries per second avg: 0.108--------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，Server和Db不是utf-8，修改为utf8即可。</p><p>因此我们先退出mysql，然后再到/etc目录下的my.cnf文件下修改一下文件内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@xiaoxiangjie ~<span class="token punctuation">]</span><span class="token comment"># vim /etc/my.cnf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">[client] #新增代码default-character-set&#x3D;utf8 #新增代码# For advice on how to change settings please see# http:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;server-configuration-defaults.html[mysqld]## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size &#x3D; 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size &#x3D; 128M# sort_buffer_size &#x3D; 2M# read_rnd_buffer_size &#x3D; 2Mdatadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysqlsocket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sockcharacter-set-server&#x3D;utf8 #新增代码collation-server&#x3D;utf8_general_ci #新增代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存更改后的my.cnf文件后，重启下mysql，然后输入status再次查看，你就会发现变化啦</p><pre class="line-numbers language-mys" data-language="mys"><code class="language-mys">[root@xiaoxiangjie ~]# service mysqld restartRedirecting to &#x2F;bin&#x2F;systemctl restart mysqld.service[root@xiaoxiangjie ~]# mysql -uroot -pEnter password: mysql&gt; status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>至此安装完毕</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客（1）</title>
      <link href="2021/04/24/hexo-da-jian-bo-ke-1/"/>
      <url>2021/04/24/hexo-da-jian-bo-ke-1/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>下载安装nodejs</p><p>通过npm配置淘宝源 cnpm</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g cnpm --registry<span class="token operator">=</span>https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看cnpm版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>通过cnpm下载安装hexo</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>hexo安装所在地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>Nodejs<span class="token punctuation">\</span>node_global<span class="token punctuation">\</span>node_modules<span class="token punctuation">\</span>hexo-cli<span class="token punctuation">\</span>bin<span class="token punctuation">\</span>hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>创建一个自己博客所在的文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">D:<span class="token punctuation">\</span>Myblog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过hexo初始化一个博客</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过hexo server 命令启动服务，默认是在</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://localhost:4000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客（2）</title>
      <link href="2021/04/24/hexo-da-jian-bo-ke-2/"/>
      <url>2021/04/24/hexo-da-jian-bo-ke-2/</url>
      
        <content type="html"><![CDATA[<h2 id="用github作为远程服务器搭建博客"><a href="#用github作为远程服务器搭建博客" class="headerlink" title="用github作为远程服务器搭建博客"></a>用github作为远程服务器搭建博客</h2><p>创建一个与GitHub账号名一样名字的仓库，我的是ciyaduxingxia</p><p>开启gitpage功能，那么就能通过ciyaduxingxia.github.io访问了</p><p>记住本地要安装git部署插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm <span class="token function">install</span> --save hexo-deployer-git <span class="token comment">#在blog目录下安装git部署插件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="在本地配置远程服务器地址"><a href="#在本地配置远程服务器地址" class="headerlink" title="在本地配置远程服务器地址"></a>在本地配置远程服务器地址</h2><p>打开博客根目录下的_config.yml文件</p><p>远端服务器配置如下修改如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:type: <span class="token function">git</span>repo: git@github.com:ciyaduxingxia/ciyaduxingxia.github.io.gitbranch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：repository不要写成git clone的https的地址</p><p>错误写法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repository: https://github.com/ciyaduxingxia/ciyaduxingxia.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="下载主题并配置"><a href="#下载主题并配置" class="headerlink" title="下载主题并配置"></a>下载主题并配置</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git themes <span class="token comment">#下载hexo-theme-matery主题到本地的themes文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改hexo根目录下的 _config.yml 文件 ： theme: hexo-theme-matery</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo c<span class="token comment">#清理一下</span>hexo g<span class="token comment">#生成</span>hexo d<span class="token comment">#部署到远程Github仓库</span>https://ciyaduxingxia.github.io/  <span class="token comment">#查看博客</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
